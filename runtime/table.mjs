// Generated by ReScript, PLEASE EDIT WITH CARE

import * as I32 from "../exec/i32.mjs";
import * as Lib from "../util/lib.mjs";
import * as $$Array from "rescript/lib/es6/array.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Values from "../syntax/values.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var Type = /* @__PURE__ */Caml_exceptions.create("Table.Type");

var Bounds = /* @__PURE__ */Caml_exceptions.create("Table.Bounds");

var SizeOverflow = /* @__PURE__ */Caml_exceptions.create("Table.SizeOverflow");

var SizeLimit = /* @__PURE__ */Caml_exceptions.create("Table.SizeLimit");

var OutOfMemory = /* @__PURE__ */Caml_exceptions.create("Table.OutOfMemory");

function valid_limits(param) {
  var max = param.max;
  if (max !== undefined) {
    return Curry._2(I32.le_u, param.min, max);
  } else {
    return true;
  }
}

function create(size, r) {
  try {
    return Lib.Array32.make(size, r);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Out_of_memory") {
      throw {
            RE_EXN_ID: OutOfMemory,
            Error: new Error()
          };
    }
    if (exn.RE_EXN_ID === "Invalid_argument") {
      throw {
            RE_EXN_ID: OutOfMemory,
            Error: new Error()
          };
    }
    throw exn;
  }
}

function alloc(ty, r) {
  var lim = ty._0;
  if (!valid_limits(lim)) {
    throw {
          RE_EXN_ID: Type,
          Error: new Error()
        };
  }
  return {
          ty: ty,
          content: create(lim.min, r)
        };
}

function size(tab) {
  return Lib.Array32.length(tab.content);
}

function type_of(tab) {
  return tab.ty;
}

function grow(tab, delta, r) {
  var match = tab.ty;
  var lim = match._0;
  if (lim.min !== Lib.Array32.length(tab.content)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "table.ml",
            38,
            2
          ],
          Error: new Error()
        };
  }
  var old_size = lim.min;
  var new_size = old_size + delta | 0;
  if (Curry._2(I32.gt_u, old_size, new_size)) {
    throw {
          RE_EXN_ID: SizeOverflow,
          Error: new Error()
        };
  }
  var lim$p_max = lim.max;
  var lim$p = {
    min: new_size,
    max: lim$p_max
  };
  if (!valid_limits(lim$p)) {
    throw {
          RE_EXN_ID: SizeLimit,
          Error: new Error()
        };
  }
  var after = create(new_size, r);
  $$Array.blit(tab.content, 0, after, 0, tab.content.length);
  tab.ty = /* TableType */{
    _0: lim$p,
    _1: match._1
  };
  tab.content = after;
  
}

function load(tab, i) {
  try {
    return Lib.Array32.get(tab.content, i);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      throw {
            RE_EXN_ID: Bounds,
            Error: new Error()
          };
    }
    throw exn;
  }
}

function store(tab, i, r) {
  var match = tab.ty;
  if (Values.type_of_ref(r) !== match._1) {
    throw {
          RE_EXN_ID: Type,
          Error: new Error()
        };
  }
  try {
    return Lib.Array32.set(tab.content, i, r);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      throw {
            RE_EXN_ID: Bounds,
            Error: new Error()
          };
    }
    throw exn;
  }
}

function blit(tab, offset, rs) {
  var data = $$Array.of_list(rs);
  try {
    return Lib.Array32.blit(data, 0, tab.content, offset, Lib.Array32.length(data));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      throw {
            RE_EXN_ID: Bounds,
            Error: new Error()
          };
    }
    throw exn;
  }
}

export {
  Type ,
  Bounds ,
  SizeOverflow ,
  SizeLimit ,
  OutOfMemory ,
  alloc ,
  type_of ,
  size ,
  grow ,
  load ,
  store ,
  blit ,
  
}
/* I32 Not a pure module */
