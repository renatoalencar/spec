// Generated by ReScript, PLEASE EDIT WITH CARE

import * as I32 from "../exec/i32.mjs";
import * as Lib from "../util/lib.mjs";
import * as $$Set from "rescript/lib/es6/set.js";
import * as Free from "../syntax/free.mjs";
import * as List from "rescript/lib/es6/list.js";
import * as V128 from "../exec/v128.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as $$Error from "../util/error.mjs";
import * as Int32 from "rescript/lib/es6/int32.js";
import * as Types from "../syntax/types.mjs";
import * as Source from "../util/source.mjs";
import * as $$String from "rescript/lib/es6/string.js";
import * as Values from "../syntax/values.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var Invalid = $$Error.Make({});

var error = Invalid.error;

function $$require(b, at, s) {
  if (!b) {
    return Curry._2(error, at, s);
  }
  
}

function lookup(category, list, x) {
  try {
    return Lib.List32.nth(list, x.it);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return Curry._2(error, x.at, "unknown " + (category + (" " + Curry._1(I32.to_string_u, x.it))));
    }
    throw exn;
  }
}

function type_(c, x) {
  return lookup("type", c.types, x);
}

function func(c, x) {
  return lookup("function", c.funcs, x);
}

function table(c, x) {
  return lookup("table", c.tables, x);
}

function memory(c, x) {
  return lookup("memory", c.memories, x);
}

function $$global(c, x) {
  return lookup("global", c.globals, x);
}

function elem(c, x) {
  return lookup("elem segment", c.elems, x);
}

function data(c, x) {
  return lookup("data segment", c.datas, x);
}

function local(c, x) {
  return lookup("local", c.locals, x);
}

function label(c, x) {
  return lookup("label", c.labels, x);
}

function refer_func(c, x) {
  var category = "function";
  var s = c.refs.funcs;
  if (!Curry._2(Free.$$Set.mem, x.it, s)) {
    return Curry._2(error, x.at, "undeclared " + (category + (" reference " + Int32.to_string(x.it))));
  }
  
}

function $neg$tilde$great(ts1, ts2) {
  return {
          ins: [
            /* NoEllipses */0,
            ts1
          ],
          outs: [
            /* NoEllipses */0,
            ts2
          ]
        };
}

function $neg$neg$great(ts1, ts2) {
  return {
          ins: [
            /* NoEllipses */0,
            List.map((function (t) {
                    return t;
                  }), ts1)
          ],
          outs: [
            /* NoEllipses */0,
            List.map((function (t) {
                    return t;
                  }), ts2)
          ]
        };
}

function $neg$neg$great$dot$dot$dot(ts1, ts2) {
  return {
          ins: [
            /* Ellipses */1,
            List.map((function (t) {
                    return t;
                  }), ts1)
          ],
          outs: [
            /* Ellipses */1,
            List.map((function (t) {
                    return t;
                  }), ts2)
          ]
        };
}

function string_of_infer_type(t) {
  return Lib.$$Option.get(Lib.$$Option.map(Types.string_of_value_type, t), "_");
}

function string_of_infer_types(ts) {
  return "[" + ($$String.concat(" ", List.map(string_of_infer_type, ts)) + "]");
}

function eq_ty(t1, t2) {
  if (Caml_obj.caml_equal(t1, t2) || t1 === undefined) {
    return true;
  } else {
    return t2 === undefined;
  }
}

function check_stack(ts1, ts2, at) {
  return $$require(List.length(ts1) === List.length(ts2) && List.for_all2(eq_ty, ts1, ts2), at, "type mismatch: instruction requires " + (string_of_infer_types(ts1) + (" but stack has " + string_of_infer_types(ts2))));
}

function pop(param, param$1, at) {
  var ts2 = param$1[1];
  var ell2 = param$1[0];
  var ts1 = param[1];
  var n1 = List.length(ts1);
  var n2 = List.length(ts2);
  var n = n1 < n2 ? n1 : n2;
  var n3 = ell2 === /* Ellipses */1 ? n1 - n | 0 : 0;
  check_stack(ts1, Pervasives.$at(Lib.List.make(n3, undefined), Lib.List.drop(n2 - n | 0, ts2)), at);
  return [
          ell2,
          param[0] === /* Ellipses */1 ? /* [] */0 : Lib.List.take(n2 - n | 0, ts2)
        ];
}

function peek(i, param) {
  try {
    return List.nth(List.rev(param[1]), i);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

function type_cvtop(at, cvtop) {
  switch (cvtop.TAG | 0) {
    case /* I32 */0 :
        var tmp;
        switch (cvtop._0) {
          case /* ExtendSI32 */0 :
          case /* ExtendUI32 */1 :
              tmp = Curry._2(error, at, "invalid conversion");
              break;
          case /* WrapI64 */2 :
              tmp = /* I64Type */1;
              break;
          case /* TruncSF64 */5 :
          case /* TruncUF64 */6 :
          case /* TruncSatSF64 */9 :
          case /* TruncSatUF64 */10 :
              tmp = /* F64Type */3;
              break;
          case /* TruncSF32 */3 :
          case /* TruncUF32 */4 :
          case /* TruncSatSF32 */7 :
          case /* TruncSatUF32 */8 :
          case /* ReinterpretFloat */11 :
              tmp = /* F32Type */2;
              break;
          
        }
        return [
                tmp,
                /* I32Type */0
              ];
    case /* I64 */1 :
        var tmp$1;
        switch (cvtop._0) {
          case /* ExtendSI32 */0 :
          case /* ExtendUI32 */1 :
              tmp$1 = /* I32Type */0;
              break;
          case /* WrapI64 */2 :
              tmp$1 = Curry._2(error, at, "invalid conversion");
              break;
          case /* TruncSF32 */3 :
          case /* TruncUF32 */4 :
          case /* TruncSatSF32 */7 :
          case /* TruncSatUF32 */8 :
              tmp$1 = /* F32Type */2;
              break;
          case /* TruncSF64 */5 :
          case /* TruncUF64 */6 :
          case /* TruncSatSF64 */9 :
          case /* TruncSatUF64 */10 :
          case /* ReinterpretFloat */11 :
              tmp$1 = /* F64Type */3;
              break;
          
        }
        return [
                tmp$1,
                /* I64Type */1
              ];
    case /* F32 */2 :
        var tmp$2;
        switch (cvtop._0) {
          case /* ConvertSI64 */2 :
          case /* ConvertUI64 */3 :
              tmp$2 = /* I64Type */1;
              break;
          case /* PromoteF32 */4 :
              tmp$2 = Curry._2(error, at, "invalid conversion");
              break;
          case /* DemoteF64 */5 :
              tmp$2 = /* F64Type */3;
              break;
          case /* ConvertSI32 */0 :
          case /* ConvertUI32 */1 :
          case /* ReinterpretInt */6 :
              tmp$2 = /* I32Type */0;
              break;
          
        }
        return [
                tmp$2,
                /* F32Type */2
              ];
    case /* F64 */3 :
        var tmp$3;
        switch (cvtop._0) {
          case /* ConvertSI32 */0 :
          case /* ConvertUI32 */1 :
              tmp$3 = /* I32Type */0;
              break;
          case /* PromoteF32 */4 :
              tmp$3 = /* F32Type */2;
              break;
          case /* DemoteF64 */5 :
              tmp$3 = Curry._2(error, at, "invalid conversion");
              break;
          case /* ConvertSI64 */2 :
          case /* ConvertUI64 */3 :
          case /* ReinterpretInt */6 :
              tmp$3 = /* I64Type */1;
              break;
          
        }
        return [
                tmp$3,
                /* F64Type */3
              ];
    
  }
}

function lane_extractop(extractop) {
  return extractop._0._0._0;
}

function lane_replaceop(replaceop) {
  return replaceop._0._0._0;
}

function check_pack(sz, t_sz, at) {
  return $$require(Types.packed_size(sz) < t_sz, at, "invalid sign extension");
}

function check_unop(unop, at) {
  switch (unop.TAG | 0) {
    case /* I32 */0 :
    case /* I64 */1 :
        break;
    case /* F32 */2 :
    case /* F64 */3 :
        return ;
    
  }
  var sz = unop._0;
  if (typeof sz === "number") {
    return ;
  } else {
    return check_pack(sz._0, Types.num_size(Values.type_of_num(unop)), at);
  }
}

function check_vec_binop(binop, at) {
  var match = binop._0;
  if (match.TAG !== /* I8x16 */0) {
    return ;
  }
  var is = match._0;
  if (typeof is === "number" || !List.exists((function (param) {
            return 32 <= param;
          }), is._0)) {
    return ;
  } else {
    return Curry._2(error, at, "invalid lane index");
  }
}

function check_memop(c, memop, ty_size, get_sz, at) {
  memory(c, Source.$at$at(0, at));
  var sz = Curry._1(get_sz, memop.pack);
  var size = sz !== undefined ? (check_pack(sz, Curry._1(ty_size, memop.ty), at), Types.packed_size(sz)) : Curry._1(ty_size, memop.ty);
  return $$require((1 << memop.align) <= size, at, "alignment must not be larger than natural");
}

function check_block_type(c, bt) {
  if (bt.TAG === /* VarBlockType */0) {
    return type_(c, bt._0);
  }
  var t = bt._0;
  if (t !== undefined) {
    return /* FuncType */{
            _0: /* [] */0,
            _1: {
              hd: t,
              tl: /* [] */0
            }
          };
  } else {
    return /* FuncType */{
            _0: /* [] */0,
            _1: /* [] */0
          };
  }
}

function check_instr(c, e, s) {
  var x = e.it;
  var exit = 0;
  if (typeof x === "number") {
    switch (x) {
      case /* Unreachable */0 :
          return $neg$neg$great$dot$dot$dot(/* [] */0, /* [] */0);
      case /* Nop */1 :
          return $neg$neg$great(/* [] */0, /* [] */0);
      case /* Drop */2 :
          return $neg$tilde$great({
                      hd: peek(0, s),
                      tl: /* [] */0
                    }, /* [] */0);
      case /* Return */3 :
          return $neg$neg$great$dot$dot$dot(c.results, /* [] */0);
      case /* MemorySize */4 :
          memory(c, Source.$at$at(0, e.at));
          return $neg$neg$great(/* [] */0, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    });
      case /* MemoryGrow */5 :
          memory(c, Source.$at$at(0, e.at));
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    });
      case /* MemoryFill */6 :
      case /* MemoryCopy */7 :
          exit = 1;
          break;
      case /* RefIsNull */8 :
          var t = peek(0, s);
          $$require(t !== undefined ? Types.is_ref_type(t) : true, e.at, "type mismatch: instruction requires reference type but stack has " + string_of_infer_type(t));
          return $neg$tilde$great({
                      hd: t,
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    });
      
    }
  } else {
    switch (x.TAG | 0) {
      case /* Select */0 :
          var ts = x._0;
          if (ts !== undefined) {
            $$require(List.length(ts) === 1, e.at, "invalid result arity other than 1 is not (yet) allowed");
            return $neg$neg$great(Pervasives.$at(ts, Pervasives.$at(ts, {
                                hd: {
                                  TAG: /* NumType */0,
                                  _0: /* I32Type */0
                                },
                                tl: /* [] */0
                              })), ts);
          }
          var t$1 = peek(1, s);
          $$require(t$1 !== undefined ? Types.is_num_type(t$1) || Types.is_vec_type(t$1) : true, e.at, "type mismatch: instruction requires numeric or vector type but stack has " + string_of_infer_type(t$1));
          return $neg$tilde$great({
                      hd: t$1,
                      tl: {
                        hd: t$1,
                        tl: {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }
                      }
                    }, {
                      hd: t$1,
                      tl: /* [] */0
                    });
      case /* Block */1 :
          var ft = check_block_type(c, x._0);
          var ts2 = ft._1;
          check_block({
                types: c.types,
                funcs: c.funcs,
                tables: c.tables,
                memories: c.memories,
                globals: c.globals,
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: {
                  hd: ts2,
                  tl: c.labels
                },
                refs: c.refs
              }, x._1, ft, e.at);
          return $neg$neg$great(ft._0, ts2);
      case /* Loop */2 :
          var ft$1 = check_block_type(c, x._0);
          var ts1 = ft$1._0;
          check_block({
                types: c.types,
                funcs: c.funcs,
                tables: c.tables,
                memories: c.memories,
                globals: c.globals,
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: {
                  hd: ts1,
                  tl: c.labels
                },
                refs: c.refs
              }, x._1, ft$1, e.at);
          return $neg$neg$great(ts1, ft$1._1);
      case /* If */3 :
          var ft$2 = check_block_type(c, x._0);
          var ts2$1 = ft$2._1;
          check_block({
                types: c.types,
                funcs: c.funcs,
                tables: c.tables,
                memories: c.memories,
                globals: c.globals,
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: {
                  hd: ts2$1,
                  tl: c.labels
                },
                refs: c.refs
              }, x._1, ft$2, e.at);
          check_block({
                types: c.types,
                funcs: c.funcs,
                tables: c.tables,
                memories: c.memories,
                globals: c.globals,
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: {
                  hd: ts2$1,
                  tl: c.labels
                },
                refs: c.refs
              }, x._2, ft$2, e.at);
          return $neg$neg$great(Pervasives.$at(ft$2._0, {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }), ts2$1);
      case /* Br */4 :
          return $neg$neg$great$dot$dot$dot(label(c, x._0), /* [] */0);
      case /* BrIf */5 :
          var x$1 = x._0;
          return $neg$neg$great(Pervasives.$at(label(c, x$1), {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }), label(c, x$1));
      case /* BrTable */6 :
          var x$2 = x._1;
          var n = List.length(label(c, x$2));
          var ts$1 = Lib.List.table(n, (function (i) {
                  return peek(n - i | 0, s);
                }));
          var param = label(c, x$2);
          check_stack(ts$1, List.map((function (t) {
                      return t;
                    }), param), x$2.at);
          List.iter((function (x$p) {
                  var param = label(c, x$p);
                  return check_stack(ts$1, List.map((function (t) {
                                    return t;
                                  }), param), x$p.at);
                }), x._0);
          var ts1$1 = Pervasives.$at(ts$1, {
                hd: {
                  TAG: /* NumType */0,
                  _0: /* I32Type */0
                },
                tl: /* [] */0
              });
          var ts2$2 = /* [] */0;
          return {
                  ins: [
                    /* Ellipses */1,
                    ts1$1
                  ],
                  outs: [
                    /* Ellipses */1,
                    ts2$2
                  ]
                };
      case /* Call */7 :
          var match = func(c, x._0);
          return $neg$neg$great(match._0, match._1);
      case /* CallIndirect */8 :
          var x$3 = x._0;
          var match$1 = table(c, x$3);
          var t$2 = match$1._1;
          var match$2 = type_(c, x._1);
          $$require(t$2 === /* FuncRefType */0, x$3.at, "type mismatch: instruction requires table of functions but table has " + Types.string_of_ref_type(t$2));
          return $neg$neg$great(Pervasives.$at(match$2._0, {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }), match$2._1);
      case /* LocalGet */9 :
          return $neg$neg$great(/* [] */0, {
                      hd: local(c, x._0),
                      tl: /* [] */0
                    });
      case /* LocalSet */10 :
          return $neg$neg$great({
                      hd: local(c, x._0),
                      tl: /* [] */0
                    }, /* [] */0);
      case /* LocalTee */11 :
          var x$4 = x._0;
          return $neg$neg$great({
                      hd: local(c, x$4),
                      tl: /* [] */0
                    }, {
                      hd: local(c, x$4),
                      tl: /* [] */0
                    });
      case /* GlobalGet */12 :
          var match$3 = $$global(c, x._0);
          return $neg$neg$great(/* [] */0, {
                      hd: match$3._0,
                      tl: /* [] */0
                    });
      case /* GlobalSet */13 :
          var x$5 = x._0;
          var match$4 = $$global(c, x$5);
          $$require(match$4._1 === /* Mutable */1, x$5.at, "global is immutable");
          return $neg$neg$great({
                      hd: match$4._0,
                      tl: /* [] */0
                    }, /* [] */0);
      case /* TableGet */14 :
          var match$5 = table(c, x._0);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* RefType */2,
                        _0: match$5._1
                      },
                      tl: /* [] */0
                    });
      case /* TableSet */15 :
          var match$6 = table(c, x._0);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* RefType */2,
                          _0: match$6._1
                        },
                        tl: /* [] */0
                      }
                    }, /* [] */0);
      case /* TableSize */16 :
          table(c, x._0);
          return $neg$neg$great(/* [] */0, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    });
      case /* TableGrow */17 :
          var match$7 = table(c, x._0);
          return $neg$neg$great({
                      hd: {
                        TAG: /* RefType */2,
                        _0: match$7._1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: /* I32Type */0
                        },
                        tl: /* [] */0
                      }
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    });
      case /* TableFill */18 :
          var match$8 = table(c, x._0);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* RefType */2,
                          _0: match$8._1
                        },
                        tl: {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }
                      }
                    }, /* [] */0);
      case /* TableCopy */19 :
          var x$6 = x._0;
          var match$9 = table(c, x$6);
          var t1 = match$9._1;
          var match$10 = table(c, x._1);
          var t2 = match$10._1;
          $$require(t1 === t2, x$6.at, "type mismatch: source element type " + (Types.string_of_ref_type(t1) + (" does not match destination element type " + Types.string_of_ref_type(t2))));
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: /* I32Type */0
                        },
                        tl: {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }
                      }
                    }, /* [] */0);
      case /* TableInit */20 :
          var x$7 = x._0;
          var match$11 = table(c, x$7);
          var t1$1 = match$11._1;
          var t2$1 = elem(c, x._1);
          $$require(t1$1 === t2$1, x$7.at, "type mismatch: element segment's type " + (Types.string_of_ref_type(t1$1) + (" does not match table's element type " + Types.string_of_ref_type(t2$1))));
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: /* I32Type */0
                        },
                        tl: {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }
                      }
                    }, /* [] */0);
      case /* ElemDrop */21 :
          elem(c, x._0);
          return $neg$neg$great(/* [] */0, /* [] */0);
      case /* Load */22 :
          var memop = x._0;
          check_memop(c, memop, Types.num_size, (function (param) {
                  return Lib.$$Option.map((function (prim) {
                                return prim[0];
                              }), param);
                }), e.at);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: memop.ty
                      },
                      tl: /* [] */0
                    });
      case /* Store */23 :
          var memop$1 = x._0;
          check_memop(c, memop$1, Types.num_size, (function (sz) {
                  return sz;
                }), e.at);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: memop$1.ty
                        },
                        tl: /* [] */0
                      }
                    }, /* [] */0);
      case /* VecLoad */24 :
          var memop$2 = x._0;
          check_memop(c, memop$2, Types.vec_size, (function (param) {
                  return Lib.$$Option.map((function (prim) {
                                return prim[0];
                              }), param);
                }), e.at);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* VecType */1,
                        _0: memop$2.ty
                      },
                      tl: /* [] */0
                    });
      case /* VecStore */25 :
          var memop$3 = x._0;
          check_memop(c, memop$3, Types.vec_size, (function (param) {
                  
                }), e.at);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* VecType */1,
                          _0: memop$3.ty
                        },
                        tl: /* [] */0
                      }
                    }, /* [] */0);
      case /* VecLoadLane */26 :
          var match$12 = x._0;
          var memop$4 = match$12[0];
          check_memop(c, memop$4, Types.vec_size, (function (sz) {
                  return sz;
                }), e.at);
          $$require(match$12[1] < Caml_int32.div(Types.vec_size(memop$4.ty), Types.packed_size(memop$4.pack)), e.at, "invalid lane index");
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* VecType */1,
                          _0: memop$4.ty
                        },
                        tl: /* [] */0
                      }
                    }, {
                      hd: {
                        TAG: /* VecType */1,
                        _0: memop$4.ty
                      },
                      tl: /* [] */0
                    });
      case /* VecStoreLane */27 :
          var match$13 = x._0;
          var memop$5 = match$13[0];
          check_memop(c, memop$5, Types.vec_size, (function (sz) {
                  return sz;
                }), e.at);
          $$require(match$13[1] < Caml_int32.div(Types.vec_size(memop$5.ty), Types.packed_size(memop$5.pack)), e.at, "invalid lane index");
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* VecType */1,
                          _0: memop$5.ty
                        },
                        tl: /* [] */0
                      }
                    }, /* [] */0);
      case /* MemoryInit */28 :
          memory(c, Source.$at$at(0, e.at));
          data(c, x._0);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: /* I32Type */0
                        },
                        tl: {
                          hd: {
                            TAG: /* NumType */0,
                            _0: /* I32Type */0
                          },
                          tl: /* [] */0
                        }
                      }
                    }, /* [] */0);
      case /* DataDrop */29 :
          data(c, x._0);
          return $neg$neg$great(/* [] */0, /* [] */0);
      case /* RefNull */30 :
          return $neg$neg$great(/* [] */0, {
                      hd: {
                        TAG: /* RefType */2,
                        _0: x._0
                      },
                      tl: /* [] */0
                    });
      case /* RefFunc */31 :
          var x$8 = x._0;
          func(c, x$8);
          refer_func(c, x$8);
          return $neg$neg$great(/* [] */0, {
                      hd: {
                        TAG: /* RefType */2,
                        _0: /* FuncRefType */0
                      },
                      tl: /* [] */0
                    });
      case /* Const */32 :
          var t$3 = {
            TAG: /* NumType */0,
            _0: Values.type_of_num(x._0.it)
          };
          return $neg$neg$great(/* [] */0, {
                      hd: t$3,
                      tl: /* [] */0
                    });
      case /* Test */33 :
          var t$4 = {
            TAG: /* NumType */0,
            _0: Values.type_of_num(x._0)
          };
          return $neg$neg$great({
                      hd: t$4,
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    });
      case /* Compare */34 :
          var t$5 = {
            TAG: /* NumType */0,
            _0: Values.type_of_num(x._0)
          };
          return $neg$neg$great({
                      hd: t$5,
                      tl: {
                        hd: t$5,
                        tl: /* [] */0
                      }
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: /* [] */0
                    });
      case /* Unary */35 :
          var unop = x._0;
          check_unop(unop, e.at);
          var t$6 = {
            TAG: /* NumType */0,
            _0: Values.type_of_num(unop)
          };
          return $neg$neg$great({
                      hd: t$6,
                      tl: /* [] */0
                    }, {
                      hd: t$6,
                      tl: /* [] */0
                    });
      case /* Binary */36 :
          var t$7 = {
            TAG: /* NumType */0,
            _0: Values.type_of_num(x._0)
          };
          return $neg$neg$great({
                      hd: t$7,
                      tl: {
                        hd: t$7,
                        tl: /* [] */0
                      }
                    }, {
                      hd: t$7,
                      tl: /* [] */0
                    });
      case /* Convert */37 :
          var match$14 = type_cvtop(e.at, x._0);
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: match$14[0]
                      },
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: match$14[1]
                      },
                      tl: /* [] */0
                    });
      case /* VecConst */38 :
          var t$8 = {
            TAG: /* VecType */1,
            _0: Values.type_of_vec(x._0.it)
          };
          return $neg$neg$great(/* [] */0, {
                      hd: t$8,
                      tl: /* [] */0
                    });
      case /* VecBinary */42 :
          var binop = x._0;
          check_vec_binop(binop, e.at);
          var t$9 = {
            TAG: /* VecType */1,
            _0: Values.type_of_vec(binop)
          };
          return $neg$neg$great({
                      hd: t$9,
                      tl: {
                        hd: t$9,
                        tl: /* [] */0
                      }
                    }, {
                      hd: t$9,
                      tl: /* [] */0
                    });
      case /* VecShift */44 :
          var t$10 = {
            TAG: /* VecType */1,
            _0: Values.type_of_vec(x._0)
          };
          return $neg$neg$great({
                      hd: t$10,
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: /* I32Type */0
                        },
                        tl: /* [] */0
                      }
                    }, {
                      hd: {
                        TAG: /* VecType */1,
                        _0: /* V128Type */0
                      },
                      tl: /* [] */0
                    });
      case /* VecUnary */41 :
      case /* VecConvert */43 :
      case /* VecUnaryBits */47 :
          exit = 3;
          break;
      case /* VecCompare */40 :
      case /* VecBinaryBits */48 :
          exit = 2;
          break;
      case /* VecTernaryBits */49 :
          var t$11 = {
            TAG: /* VecType */1,
            _0: Values.type_of_vec(x._0)
          };
          return $neg$neg$great({
                      hd: t$11,
                      tl: {
                        hd: t$11,
                        tl: {
                          hd: t$11,
                          tl: /* [] */0
                        }
                      }
                    }, {
                      hd: t$11,
                      tl: /* [] */0
                    });
      case /* VecSplat */50 :
          var splatop = x._0;
          var t1$2 = V128.type_of_lane(splatop._0);
          var t2$2 = {
            TAG: /* VecType */1,
            _0: Values.type_of_vec(splatop)
          };
          return $neg$neg$great({
                      hd: {
                        TAG: /* NumType */0,
                        _0: t1$2
                      },
                      tl: /* [] */0
                    }, {
                      hd: t2$2,
                      tl: /* [] */0
                    });
      case /* VecExtract */51 :
          var extractop = x._0;
          var t$12 = {
            TAG: /* VecType */1,
            _0: Values.type_of_vec(extractop)
          };
          var t2$3 = V128.type_of_lane(extractop._0);
          $$require(lane_extractop(extractop) < V128.num_lanes(extractop._0), e.at, "invalid lane index");
          return $neg$neg$great({
                      hd: t$12,
                      tl: /* [] */0
                    }, {
                      hd: {
                        TAG: /* NumType */0,
                        _0: t2$3
                      },
                      tl: /* [] */0
                    });
      case /* VecReplace */52 :
          var replaceop = x._0;
          var t$13 = {
            TAG: /* VecType */1,
            _0: Values.type_of_vec(replaceop)
          };
          var t2$4 = V128.type_of_lane(replaceop._0);
          $$require(lane_replaceop(replaceop) < V128.num_lanes(replaceop._0), e.at, "invalid lane index");
          return $neg$neg$great({
                      hd: t$13,
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: t2$4
                        },
                        tl: /* [] */0
                      }
                    }, {
                      hd: t$13,
                      tl: /* [] */0
                    });
      default:
        var t$14 = {
          TAG: /* VecType */1,
          _0: Values.type_of_vec(x._0)
        };
        return $neg$neg$great({
                    hd: t$14,
                    tl: /* [] */0
                  }, {
                    hd: {
                      TAG: /* NumType */0,
                      _0: /* I32Type */0
                    },
                    tl: /* [] */0
                  });
    }
  }
  switch (exit) {
    case 1 :
        memory(c, Source.$at$at(0, e.at));
        return $neg$neg$great({
                    hd: {
                      TAG: /* NumType */0,
                      _0: /* I32Type */0
                    },
                    tl: {
                      hd: {
                        TAG: /* NumType */0,
                        _0: /* I32Type */0
                      },
                      tl: {
                        hd: {
                          TAG: /* NumType */0,
                          _0: /* I32Type */0
                        },
                        tl: /* [] */0
                      }
                    }
                  }, /* [] */0);
    case 2 :
        var t$15 = {
          TAG: /* VecType */1,
          _0: Values.type_of_vec(x._0)
        };
        return $neg$neg$great({
                    hd: t$15,
                    tl: {
                      hd: t$15,
                      tl: /* [] */0
                    }
                  }, {
                    hd: t$15,
                    tl: /* [] */0
                  });
    case 3 :
        var t$16 = {
          TAG: /* VecType */1,
          _0: Values.type_of_vec(x._0)
        };
        return $neg$neg$great({
                    hd: t$16,
                    tl: /* [] */0
                  }, {
                    hd: t$16,
                    tl: /* [] */0
                  });
    
  }
}

function check_seq(c, s, es) {
  if (!es) {
    return s;
  }
  var match = Lib.List.split_last(es);
  var e = match[1];
  var s$p = check_seq(c, s, match[0]);
  var match$1 = check_instr(c, e, s$p);
  var param = match$1.outs;
  var param$1 = pop(match$1.ins, s$p, e.at);
  var ts2 = param$1[1];
  var ell1 = param[0];
  if (!(ell1 === /* NoEllipses */0 || ts2 === /* [] */0)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "valid.ml",
            103,
            2
          ],
          Error: new Error()
        };
  }
  return [
          ell1 === /* Ellipses */1 || param$1[0] === /* Ellipses */1 ? /* Ellipses */1 : /* NoEllipses */0,
          Pervasives.$at(ts2, param[1])
        ];
}

function check_block(c, es, ft, at) {
  var ts2 = ft._1;
  var s = check_seq(c, [
        /* NoEllipses */0,
        List.map((function (t) {
                return t;
              }), ft._0)
      ], es);
  var s$p = pop([
        /* NoEllipses */0,
        List.map((function (t) {
                return t;
              }), ts2)
      ], s, at);
  return $$require(s$p[1] === /* [] */0, at, "type mismatch: block requires " + (Types.string_of_result_type(ts2) + (" but stack has " + string_of_infer_types(s[1]))));
}

function check_limits(param, range, at, msg) {
  var max = param.max;
  var min = param.min;
  $$require(Curry._2(I32.le_u, min, range), at, msg);
  if (max !== undefined) {
    $$require(Curry._2(I32.le_u, max, range), at, msg);
    return $$require(Curry._2(I32.le_u, min, max), at, "size minimum must not be greater than maximum");
  }
  
}

function check_value_type(t, at) {
  switch (t.TAG | 0) {
    case /* NumType */0 :
    case /* VecType */1 :
    case /* RefType */2 :
        return ;
    
  }
}

function check_table_type(tt, at) {
  check_limits(tt._0, -1, at, "table size must be at most 2^32-1");
  
}

function check_memory_type(mt, at) {
  return check_limits(mt._0, 65536, at, "memory size must be at most 65536 pages (4GiB)");
}

function check_global_type(gt, at) {
  return check_value_type(gt._0, at);
}

function check_type(t) {
  var ft = t.it;
  var at = t.at;
  List.iter((function (t) {
          return check_value_type(t, at);
        }), ft._0);
  return List.iter((function (t) {
                return check_value_type(t, at);
              }), ft._1);
}

function check_const(c, $$const, t) {
  $$require(List.for_all((function (param) {
              var x = param.it;
              if (typeof x === "number") {
                return false;
              }
              switch (x.TAG | 0) {
                case /* GlobalGet */12 :
                    var match = $$global(c, x._0);
                    return match._1 === /* Immutable */0;
                case /* RefNull */30 :
                case /* RefFunc */31 :
                case /* Const */32 :
                case /* VecConst */38 :
                    return true;
                default:
                  return false;
              }
            }), $$const.it), $$const.at, "constant expression required");
  return check_block(c, $$const.it, /* FuncType */{
              _0: /* [] */0,
              _1: {
                hd: t,
                tl: /* [] */0
              }
            }, $$const.at);
}

function check_import(im, c) {
  var match = im.it;
  var idesc = match.idesc;
  var x = idesc.it;
  switch (x.TAG | 0) {
    case /* FuncImport */0 :
        return {
                types: c.types,
                funcs: {
                  hd: type_(c, x._0),
                  tl: c.funcs
                },
                tables: c.tables,
                memories: c.memories,
                globals: c.globals,
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: c.labels,
                refs: c.refs
              };
    case /* TableImport */1 :
        var tt = x._0;
        check_table_type(tt, idesc.at);
        return {
                types: c.types,
                funcs: c.funcs,
                tables: {
                  hd: tt,
                  tl: c.tables
                },
                memories: c.memories,
                globals: c.globals,
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: c.labels,
                refs: c.refs
              };
    case /* MemoryImport */2 :
        var mt = x._0;
        check_memory_type(mt, idesc.at);
        return {
                types: c.types,
                funcs: c.funcs,
                tables: c.tables,
                memories: {
                  hd: mt,
                  tl: c.memories
                },
                globals: c.globals,
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: c.labels,
                refs: c.refs
              };
    case /* GlobalImport */3 :
        var gt = x._0;
        check_global_type(gt, idesc.at);
        return {
                types: c.types,
                funcs: c.funcs,
                tables: c.tables,
                memories: c.memories,
                globals: {
                  hd: gt,
                  tl: c.globals
                },
                elems: c.elems,
                datas: c.datas,
                locals: c.locals,
                results: c.results,
                labels: c.labels,
                refs: c.refs
              };
    
  }
}

var compare = Caml_obj.caml_compare;

var NameSet = $$Set.Make({
      compare: compare
    });

function check_module(m) {
  var match = m.it;
  var datas = match.datas;
  var elems = match.elems;
  var funcs = match.funcs;
  var memories = match.memories;
  var tables = match.tables;
  var globals = match.globals;
  var types = match.types;
  var init = m.it;
  var c0 = List.fold_right(check_import, match.imports, {
        types: List.map((function (ty) {
                return ty.it;
              }), types),
        funcs: /* [] */0,
        tables: /* [] */0,
        memories: /* [] */0,
        globals: /* [] */0,
        elems: /* [] */0,
        datas: /* [] */0,
        locals: /* [] */0,
        results: /* [] */0,
        labels: /* [] */0,
        refs: Free.module_(Source.$at$at({
                  types: init.types,
                  globals: init.globals,
                  tables: init.tables,
                  memories: init.memories,
                  funcs: /* [] */0,
                  start: undefined,
                  elems: init.elems,
                  datas: init.datas,
                  imports: init.imports,
                  exports: init.exports
                }, m.at))
      });
  var c1_types = c0.types;
  var c1_funcs = Pervasives.$at(c0.funcs, List.map((function (f) {
              return type_(c0, f.it.ftype);
            }), funcs));
  var c1_tables = Pervasives.$at(c0.tables, List.map((function (tab) {
              return tab.it.ttype;
            }), tables));
  var c1_memories = Pervasives.$at(c0.memories, List.map((function (mem) {
              return mem.it.mtype;
            }), memories));
  var c1_globals = c0.globals;
  var c1_elems = List.map((function (elem) {
          return elem.it.etype;
        }), elems);
  var c1_datas = List.map((function (_data) {
          
        }), datas);
  var c1_locals = c0.locals;
  var c1_results = c0.results;
  var c1_labels = c0.labels;
  var c1_refs = c0.refs;
  var c1 = {
    types: c1_types,
    funcs: c1_funcs,
    tables: c1_tables,
    memories: c1_memories,
    globals: c1_globals,
    elems: c1_elems,
    datas: c1_datas,
    locals: c1_locals,
    results: c1_results,
    labels: c1_labels,
    refs: c1_refs
  };
  var c_types = c1_types;
  var c_funcs = c1_funcs;
  var c_tables = c1_tables;
  var c_memories = c1_memories;
  var c_globals = Pervasives.$at(c1_globals, List.map((function (g) {
              return g.it.gtype;
            }), globals));
  var c_elems = c1_elems;
  var c_datas = c1_datas;
  var c_locals = c1_locals;
  var c_results = c1_results;
  var c_labels = c1_labels;
  var c_refs = c1_refs;
  var c = {
    types: c_types,
    funcs: c_funcs,
    tables: c_tables,
    memories: c_memories,
    globals: c_globals,
    elems: c_elems,
    datas: c_datas,
    locals: c_locals,
    results: c_results,
    labels: c_labels,
    refs: c_refs
  };
  List.iter(check_type, types);
  List.iter((function (param) {
          var match = param.it;
          return check_const(c1, match.ginit, match.gtype._0);
        }), globals);
  List.iter((function (param) {
          var match = param.it;
          return check_table_type(match.ttype, param.at);
        }), tables);
  List.iter((function (param) {
          var match = param.it;
          return check_memory_type(match.mtype, param.at);
        }), memories);
  List.iter((function (param) {
          var match = param.it;
          var etype = match.etype;
          List.iter((function ($$const) {
                  return check_const(c1, $$const, {
                              TAG: /* RefType */2,
                              _0: etype
                            });
                }), match.einit);
          var mode = match.emode;
          var match$1 = mode.it;
          if (typeof match$1 === "number") {
            return ;
          }
          var match$2 = table(c1, match$1.index);
          var et = match$2._1;
          $$require(etype === et, mode.at, "type mismatch: element segment's type " + (Types.string_of_ref_type(etype) + (" does not match table's element type " + Types.string_of_ref_type(et))));
          return check_const(c1, match$1.offset, {
                      TAG: /* NumType */0,
                      _0: /* I32Type */0
                    });
        }), elems);
  List.iter((function (param) {
          var match = param.it;
          var mode = match.dmode;
          var match$1 = mode.it;
          if (typeof match$1 === "number") {
            if (match$1 === 0) {
              return ;
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "valid.ml",
                    656,
                    19
                  ],
                  Error: new Error()
                };
          }
          memory(c1, match$1.index);
          return check_const(c1, match$1.offset, {
                      TAG: /* NumType */0,
                      _0: /* I32Type */0
                    });
        }), datas);
  List.iter((function (param) {
          var match = param.it;
          var match$1 = type_(c, match.ftype);
          var ts2 = match$1._1;
          var c$p_types = c_types;
          var c$p_funcs = c_funcs;
          var c$p_tables = c_tables;
          var c$p_memories = c_memories;
          var c$p_globals = c_globals;
          var c$p_elems = c_elems;
          var c$p_datas = c_datas;
          var c$p_locals = Pervasives.$at(match$1._0, match.locals);
          var c$p_labels = {
            hd: ts2,
            tl: /* [] */0
          };
          var c$p_refs = c_refs;
          var c$p = {
            types: c$p_types,
            funcs: c$p_funcs,
            tables: c$p_tables,
            memories: c$p_memories,
            globals: c$p_globals,
            elems: c$p_elems,
            datas: c$p_datas,
            locals: c$p_locals,
            results: ts2,
            labels: c$p_labels,
            refs: c$p_refs
          };
          return check_block(c$p, match.body, /* FuncType */{
                      _0: /* [] */0,
                      _1: ts2
                    }, param.at);
        }), funcs);
  Lib.$$Option.app((function (param) {
          var match = param.it;
          return $$require(Caml_obj.caml_equal(func(c, match.sfunc), /* FuncType */{
                          _0: /* [] */0,
                          _1: /* [] */0
                        }), param.at, "start function must not have parameters or results");
        }), match.start);
  List.fold_left((function (param, param$1) {
          var match = param$1.it;
          var name = match.name;
          var x = match.edesc.it;
          switch (x.TAG | 0) {
            case /* FuncExport */0 :
                func(c, x._0);
                break;
            case /* TableExport */1 :
                table(c, x._0);
                break;
            case /* MemoryExport */2 :
                memory(c, x._0);
                break;
            case /* GlobalExport */3 :
                $$global(c, x._0);
                break;
            
          }
          $$require(!Curry._2(NameSet.mem, name, param), param$1.at, "duplicate export name");
          return Curry._2(NameSet.add, name, param);
        }), NameSet.empty, match.exports);
  return $$require(List.length(c_memories) <= 1, m.at, "multiple memories are not allowed (yet)");
}

var Invalid$1 = Invalid.$$Error;

export {
  Invalid$1 as Invalid,
  check_module ,
  
}
/* Invalid Not a pure module */
