// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as List from "rescript/lib/es6/list.js";
import * as $$Array from "rescript/lib/es6/array.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Int32 from "rescript/lib/es6/int32.js";
import * as $$Buffer from "rescript/lib/es6/buffer.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_int64 from "rescript/lib/es6/caml_int64.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function id(x) {
  return x;
}

function curry(f, x, y) {
  return Curry._1(f, [
              x,
              y
            ]);
}

function uncurry(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function repeat(_n, f, x) {
  while(true) {
    var n = _n;
    if (n === 0) {
      return ;
    }
    Curry._1(f, x);
    _n = n - 1 | 0;
    continue ;
  };
}

var Fun = {
  id: id,
  curry: curry,
  uncurry: uncurry,
  repeat: repeat
};

function log2(n) {
  if (n <= 0) {
    Pervasives.failwith("log2");
  }
  var _acc = 0;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var acc = _acc;
    if (n$1 === 1) {
      return acc;
    }
    _n = (n$1 >>> 1);
    _acc = acc + 1 | 0;
    continue ;
  };
}

function is_power_of_two(n) {
  if (n < 0) {
    Pervasives.failwith("is_power_of_two");
  }
  if (n !== 0) {
    return (n & (n - 1 | 0)) === 0;
  } else {
    return false;
  }
}

var Int = {
  log2: log2,
  is_power_of_two: is_power_of_two
};

function implode(cs) {
  var buf = $$Buffer.create(80);
  List.iter((function (param) {
          return $$Buffer.add_char(buf, param);
        }), cs);
  return $$Buffer.contents(buf);
}

function explode(s) {
  var cs = /* [] */0;
  for(var i = s.length - 1 | 0; i >= 0; --i){
    cs = {
      hd: Caml_string.get(s, i),
      tl: cs
    };
  }
  return cs;
}

function split(s, c) {
  var len = s.length;
  var loop = function (i) {
    if (i > len) {
      return /* [] */0;
    }
    var j;
    try {
      j = $$String.index_from(s, i, c);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        j = len;
      } else {
        throw exn;
      }
    }
    return {
            hd: $$String.sub(s, i, j - i | 0),
            tl: loop(j + 1 | 0)
          };
  };
  return loop(0);
}

function breakup(s, n) {
  var loop = function (i) {
    var len = Caml.caml_int_min(n, s.length - i | 0);
    if (len === 0) {
      return /* [] */0;
    } else {
      return {
              hd: $$String.sub(s, i, len),
              tl: loop(i + len | 0)
            };
    }
  };
  return loop(0);
}

function find_from_opt(f, s, _i) {
  while(true) {
    var i = _i;
    if (i === s.length) {
      return ;
    }
    if (Curry._1(f, Caml_string.get(s, i))) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

var $$String$1 = {
  implode: implode,
  explode: explode,
  split: split,
  breakup: breakup,
  find_from_opt: find_from_opt
};

function make(n, x) {
  var _n = n;
  var _xs = /* [] */0;
  while(true) {
    var xs = _xs;
    var n$1 = _n;
    if (n$1 === 0) {
      return xs;
    }
    _xs = {
      hd: x,
      tl: xs
    };
    _n = n$1 - 1 | 0;
    continue ;
  };
}

function table(n, f) {
  var _n = n;
  var _xs = /* [] */0;
  while(true) {
    var xs = _xs;
    var n$1 = _n;
    if (n$1 === 0) {
      return xs;
    }
    _xs = {
      hd: Curry._1(f, n$1 - 1 | 0),
      tl: xs
    };
    _n = n$1 - 1 | 0;
    continue ;
  };
}

function take(n, xs) {
  if (n !== 0) {
    if (xs && n > 0) {
      return {
              hd: xs.hd,
              tl: take(n - 1 | 0, xs.tl)
            };
    } else {
      return Pervasives.failwith("take");
    }
  } else {
    return /* [] */0;
  }
}

function drop(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n === 0) {
      return xs;
    }
    if (!xs) {
      return Pervasives.failwith("drop");
    }
    if (n <= 0) {
      return Pervasives.failwith("drop");
    }
    _xs = xs.tl;
    _n = n - 1 | 0;
    continue ;
  };
}

function last(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return Pervasives.failwith("last");
    }
    var xs = param.tl;
    if (!xs) {
      return param.hd;
    }
    _param = xs;
    continue ;
  };
}

function split_last(param) {
  if (!param) {
    return Pervasives.failwith("split_last");
  }
  var xs = param.tl;
  var x = param.hd;
  if (!xs) {
    return [
            /* [] */0,
            x
          ];
  }
  var match = split_last(xs);
  return [
          {
            hd: x,
            tl: match[0]
          },
          match[1]
        ];
}

function index_where$p(p, _xs, _i) {
  while(true) {
    var i = _i;
    var xs = _xs;
    if (!xs) {
      return ;
    }
    if (Curry._1(p, xs.hd)) {
      return i;
    }
    _i = i + 1 | 0;
    _xs = xs.tl;
    continue ;
  };
}

function index_where(p, xs) {
  return index_where$p(p, xs, 0);
}

function index_of(x) {
  return function (param) {
    return index_where$p((function (param) {
                  return Caml_obj.caml_equal(x, param);
                }), param, 0);
  };
}

function map_filter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var xs = param.tl;
    var y = Curry._1(f, param.hd);
    if (y !== undefined) {
      return {
              hd: Caml_option.valFromOption(y),
              tl: map_filter(f, xs)
            };
    }
    _param = xs;
    continue ;
  };
}

function concat_map(f, param) {
  if (param) {
    return Pervasives.$at(Curry._1(f, param.hd), concat_map(f, param.tl));
  } else {
    return /* [] */0;
  }
}

function pairwise(f, param) {
  if (!param) {
    return /* [] */0;
  }
  var match = param.tl;
  if (match) {
    return {
            hd: Curry._2(f, param.hd, match.hd),
            tl: pairwise(f, match.tl)
          };
  } else {
    return Pervasives.failwith("pairwise");
  }
}

function make$1(n, x) {
  var _n = n;
  var _xs = /* [] */0;
  while(true) {
    var xs = _xs;
    var n$1 = _n;
    if (n$1 === 0) {
      return xs;
    }
    _xs = {
      hd: x,
      tl: xs
    };
    _n = n$1 - 1 | 0;
    continue ;
  };
}

function length(xs) {
  var _xs = xs;
  var _n = 0;
  while(true) {
    var n = _n;
    var xs$1 = _xs;
    if (!xs$1) {
      return n;
    }
    if (n >= Int32.max_int) {
      return Pervasives.failwith("length");
    }
    _n = n + 1 | 0;
    _xs = xs$1.tl;
    continue ;
  };
}

function nth(_xs, _n) {
  while(true) {
    var n = _n;
    var xs = _xs;
    if (n === 0) {
      if (xs) {
        return xs.hd;
      } else {
        return Pervasives.failwith("nth");
      }
    }
    if (!xs) {
      return Pervasives.failwith("nth");
    }
    if (n <= 0) {
      return Pervasives.failwith("nth");
    }
    _n = n - 1 | 0;
    _xs = xs.tl;
    continue ;
  };
}

function take$1(n, xs) {
  if (n !== 0) {
    if (xs && n > 0) {
      return {
              hd: xs.hd,
              tl: take$1(n - 1 | 0, xs.tl)
            };
    } else {
      return Pervasives.failwith("take");
    }
  } else {
    return /* [] */0;
  }
}

function drop$1(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n === 0) {
      return xs;
    }
    if (!xs) {
      return Pervasives.failwith("drop");
    }
    if (n <= 0) {
      return Pervasives.failwith("drop");
    }
    _xs = xs.tl;
    _n = n - 1 | 0;
    continue ;
  };
}

function mapi$p(f, i, param) {
  if (param) {
    return {
            hd: Curry._2(f, i, param.hd),
            tl: mapi$p(f, i + 1 | 0, param.tl)
          };
  } else {
    return /* [] */0;
  }
}

function mapi(f, xs) {
  return mapi$p(f, 0, xs);
}

function make$2(n, x) {
  if (n < 0 || Caml.i64_gt(Caml_int64.of_int32(n), Caml_int64.of_int32(Pervasives.max_int))) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array32.make",
          Error: new Error()
        };
  }
  return Caml_array.make(n, x);
}

function length$1(a) {
  return a.length;
}

function index_of_int32(i) {
  if (i < 0 || Caml.i64_gt(Caml_int64.of_int32(i), Caml_int64.of_int32(Pervasives.max_int))) {
    return -1;
  } else {
    return i;
  }
}

function get(a, i) {
  return Caml_array.get(a, index_of_int32(i));
}

function set(a, i, x) {
  return Caml_array.set(a, index_of_int32(i), x);
}

function blit(a1, i1, a2, i2, n) {
  return $$Array.blit(a1, index_of_int32(i1), a2, index_of_int32(i2), index_of_int32(n));
}

function get$1(o, x) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  } else {
    return x;
  }
}

function force(o) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "Option.force",
        Error: new Error()
      };
}

function map(f, x) {
  if (x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

function app(f, x) {
  if (x !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(x));
  }
  
}

var $$Option = {
  get: get$1,
  force: force,
  map: map,
  app: app
};

var List$1 = {
  make: make,
  table: table,
  take: take,
  drop: drop,
  last: last,
  split_last: split_last,
  index_of: index_of,
  index_where: index_where,
  map_filter: map_filter,
  concat_map: concat_map,
  pairwise: pairwise
};

var List32 = {
  make: make$1,
  length: length,
  nth: nth,
  take: take$1,
  drop: drop$1,
  mapi: mapi
};

var Array32 = {
  make: make$2,
  length: length$1,
  get: get,
  set: set,
  blit: blit
};

export {
  Fun ,
  List$1 as List,
  List32 ,
  Array32 ,
  $$Option ,
  Int ,
  $$String$1 as $$String,
  
}
/* No side effect */
