// Generated by ReScript, PLEASE EDIT WITH CARE

import * as F32 from "../exec/f32.bs.js";
import * as F64 from "../exec/f64.bs.js";
import * as I32 from "../exec/i32.bs.js";
import * as I64 from "../exec/i64.bs.js";
import * as Lib from "../util/lib.bs.js";
import * as Free from "../syntax/free.bs.js";
import * as List from "rescript/lib/es6/list.js";
import * as Utf8 from "./utf8.bs.js";
import * as V128 from "../exec/v128.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as $$Error from "../util/error.bs.js";
import * as Types from "../syntax/types.bs.js";
import * as Encode from "./encode.bs.js";
import * as Printf from "rescript/lib/es6/printf.js";
import * as Source from "../util/source.bs.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Operators from "../syntax/operators.bs.js";
import * as Caml_int64 from "rescript/lib/es6/caml_int64.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";
import * as I32_convert from "../exec/i32_convert.bs.js";
import * as I64_convert from "../exec/i64_convert.bs.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var EOS = /* @__PURE__ */Caml_exceptions.create("Decode.EOS");

function stream(name, bs) {
  return {
          name: name,
          bytes: bs,
          pos: {
            contents: 0
          }
        };
}

function eos(s) {
  return s.pos.contents === s.bytes.length;
}

function check(n, s) {
  if ((s.pos.contents + n | 0) <= s.bytes.length) {
    return ;
  }
  throw {
        RE_EXN_ID: EOS,
        Error: new Error()
      };
}

function skip(n, s) {
  if (n < 0) {
    throw {
          RE_EXN_ID: EOS,
          Error: new Error()
        };
  }
  check(n, s);
  s.pos.contents = s.pos.contents + n | 0;
  
}

function read(s) {
  return Caml_string.get(s.bytes, s.pos.contents);
}

function peek(s) {
  if (eos(s)) {
    return ;
  } else {
    return read(s);
  }
}

function get(s) {
  check(1, s);
  var b = read(s);
  skip(1, s);
  return b;
}

var Code = $$Error.Make({});

var Code$1 = Code.$$Error;

function string_of_byte(b) {
  return Curry._1(Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* Int */4,
                    _0: /* Int_x */6,
                    _1: {
                      TAG: /* Lit_padding */0,
                      _0: /* Zeros */2,
                      _1: 2
                    },
                    _2: /* No_precision */0,
                    _3: /* End_of_format */0
                  },
                  _1: "%02x"
                }), b);
}

function string_of_multi(n) {
  return Curry._1(Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* Int32 */5,
                    _0: /* Int_x */6,
                    _1: {
                      TAG: /* Lit_padding */0,
                      _0: /* Zeros */2,
                      _1: 2
                    },
                    _2: /* No_precision */0,
                    _3: /* End_of_format */0
                  },
                  _1: "%02lx"
                }), n);
}

function position(s, pos) {
  return {
          file: s.name,
          line: -1,
          column: pos
        };
}

function region(s, left, right) {
  return {
          left: position(s, left),
          right: position(s, right)
        };
}

function error(s, pos, msg) {
  throw {
        RE_EXN_ID: Code$1,
        _1: region(s, pos, pos),
        _2: msg,
        Error: new Error()
      };
}

function $$require(b, s, pos, msg) {
  if (!b) {
    return error(s, pos, msg);
  }
  
}

function guard(f, s) {
  try {
    return Curry._1(f, s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === EOS) {
      return error(s, s.bytes.length, "unexpected end of section or function");
    }
    throw exn;
  }
}

function get$1(param) {
  return guard(get, param);
}

function get_string(n) {
  return function (param) {
    return guard((function (param) {
                  var i = param.pos.contents;
                  skip(n, param);
                  return $$String.sub(param.bytes, i, n);
                }), param);
  };
}

function skip$1(n) {
  return function (param) {
    return guard((function (param) {
                  return skip(n, param);
                }), param);
  };
}

function expect(b, s, msg) {
  return $$require(guard(get$1, s) === b, s, s.pos.contents - 1 | 0, msg);
}

function illegal(s, pos, b) {
  return error(s, pos, "illegal opcode " + string_of_byte(b));
}

function at(f, s) {
  var left = s.pos.contents;
  var x = Curry._1(f, s);
  var right = s.pos.contents;
  return Source.$at$at(x, region(s, left, right));
}

function u16(s) {
  var lo = guard(get, s);
  var hi = guard(get, s);
  return (hi << 8) + lo | 0;
}

function u32(s) {
  var lo = u16(s);
  var hi = u16(s);
  return lo + (hi << 16) | 0;
}

function u64(s) {
  var lo = I64_convert.extend_i32_u(u32(s));
  var hi = I64_convert.extend_i32_u(u32(s));
  return Caml_int64.add(lo, Caml_int64.lsl_(hi, 32));
}

function vuN(n, s) {
  $$require(n > 0, s, s.pos.contents, "integer representation too long");
  var b = guard(get, s);
  $$require(n >= 7 || (b & 127) < (1 << n), s, s.pos.contents - 1 | 0, "integer too large");
  var x = Caml_int64.of_int32(b & 127);
  if ((b & 128) === 0) {
    return x;
  } else {
    return Caml_int64.or_(x, Caml_int64.lsl_(vuN(n - 7 | 0, s), 7));
  }
}

function vsN(n, s) {
  $$require(n > 0, s, s.pos.contents, "integer representation too long");
  var b = guard(get, s);
  var mask = (-1 << (n - 1 | 0)) & 127;
  $$require(n >= 7 || (b & mask) === 0 || (b & mask) === mask, s, s.pos.contents - 1 | 0, "integer too large");
  var x = Caml_int64.of_int32(b & 127);
  if ((b & 128) === 0) {
    if ((b & 64) === 0) {
      return x;
    } else {
      return Caml_int64.or_(x, [
                  -1,
                  4294967168
                ]);
    }
  } else {
    return Caml_int64.or_(x, Caml_int64.lsl_(vsN(n - 7 | 0, s), 7));
  }
}

function vu32(s) {
  return Caml_int64.to_int32(vuN(32, s));
}

function vs32(s) {
  return Caml_int64.to_int32(vsN(32, s));
}

function vs33(s) {
  return I32_convert.wrap_i64(vsN(33, s));
}

function vs64(s) {
  return vsN(64, s);
}

function f32(s) {
  return Curry._1(F32.of_bits, u32(s));
}

function f64(s) {
  return Curry._1(F64.of_bits, u64(s));
}

function v128(s) {
  return V128.of_bits(get_string(Types.vec_size(/* V128Type */0))(s));
}

function len32(s) {
  var pos = s.pos.contents;
  var n = Caml_int64.to_int32(vuN(32, s));
  if (Curry._2(I32.le_u, n, s.bytes.length - pos | 0)) {
    return n;
  } else {
    return error(s, pos, "length out of bounds");
  }
}

function string(s) {
  var n = len32(s);
  return get_string(n)(s);
}

function list(f, n, s) {
  if (n === 0) {
    return /* [] */0;
  }
  var x = Curry._1(f, s);
  return {
          hd: x,
          tl: list(f, n - 1 | 0, s)
        };
}

function opt(f, b, s) {
  if (b) {
    return Caml_option.some(Curry._1(f, s));
  }
  
}

function vec(f, s) {
  var n = len32(s);
  return list(f, n, s);
}

function name(s) {
  var pos = s.pos.contents;
  try {
    return Utf8.decode(string(s));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Utf8.Utf8) {
      return error(s, pos, "malformed UTF-8 encoding");
    }
    throw exn;
  }
}

function sized(f, s) {
  var size = len32(s);
  var start = s.pos.contents;
  var x = Curry._2(f, size, s);
  $$require(s.pos.contents === (start + size | 0), s, start, "section size mismatch");
  return x;
}

function num_type(s) {
  var match = Caml_int64.to_int32(vsN(7, s));
  switch (match) {
    case -4 :
        return /* F64Type */3;
    case -3 :
        return /* F32Type */2;
    case -2 :
        return /* I64Type */1;
    case -1 :
        return /* I32Type */0;
    default:
      return error(s, s.pos.contents - 1 | 0, "malformed number type");
  }
}

function vec_type(s) {
  var match = Caml_int64.to_int32(vsN(7, s));
  if (match !== -5) {
    return error(s, s.pos.contents - 1 | 0, "malformed vector type");
  } else {
    return /* V128Type */0;
  }
}

function ref_type(s) {
  var match = Caml_int64.to_int32(vsN(7, s));
  if (match !== -17) {
    if (match !== -16) {
      return error(s, s.pos.contents - 1 | 0, "malformed reference type");
    } else {
      return /* FuncRefType */0;
    }
  } else {
    return /* ExternRefType */1;
  }
}

function value_type(s) {
  var n = peek(s);
  if (n !== undefined) {
    if (n >= 124) {
      return {
              TAG: /* NumType */0,
              _0: num_type(s)
            };
    } else if (n >= 113) {
      return {
              TAG: /* VecType */1,
              _0: vec_type(s)
            };
    } else {
      return {
              TAG: /* RefType */2,
              _0: ref_type(s)
            };
    }
  } else {
    return {
            TAG: /* RefType */2,
            _0: ref_type(s)
          };
  }
}

function func_type(s) {
  var match = Caml_int64.to_int32(vsN(7, s));
  if (match !== -32) {
    return error(s, s.pos.contents - 1 | 0, "malformed function type");
  }
  var ins = vec(value_type, s);
  var out = vec(value_type, s);
  return /* FuncType */{
          _0: ins,
          _1: out
        };
}

function limits(vu, s) {
  var has_max = Caml_int64.to_int32(vuN(1, s)) === 1;
  var min = Curry._1(vu, s);
  var max = opt(vu, has_max, s);
  return {
          min: min,
          max: max
        };
}

function table_type(s) {
  var t = ref_type(s);
  var lim = limits(vu32, s);
  return /* TableType */{
          _0: lim,
          _1: t
        };
}

function memory_type(s) {
  var lim = limits(vu32, s);
  return /* MemoryType */{
          _0: lim
        };
}

function mutability(s) {
  var match = guard(get, s);
  if (match !== 0) {
    if (match !== 1) {
      return error(s, s.pos.contents - 1 | 0, "malformed mutability");
    } else {
      return /* Mutable */1;
    }
  } else {
    return /* Immutable */0;
  }
}

function global_type(s) {
  var t = value_type(s);
  var mut = mutability(s);
  return /* GlobalType */{
          _0: t,
          _1: mut
        };
}

function $$var(s) {
  return Caml_int64.to_int32(vuN(32, s));
}

function memop(s) {
  var align = Caml_int64.to_int32(vuN(32, s));
  $$require(Curry._2(I32.le_u, align, 32), s, s.pos.contents - 1 | 0, "malformed memop flags");
  var offset = Caml_int64.to_int32(vuN(32, s));
  return [
          align,
          offset
        ];
}

function block_type(s) {
  var b = peek(s);
  if (b !== undefined) {
    if (b !== 64) {
      if ((b & 192) === 64) {
        return {
                TAG: /* ValBlockType */1,
                _0: value_type(s)
              };
      } else {
        return {
                TAG: /* VarBlockType */0,
                _0: at(vs33, s)
              };
      }
    } else {
      guard((function (param) {
              return skip(1, param);
            }), s);
      return {
              TAG: /* ValBlockType */1,
              _0: undefined
            };
    }
  } else {
    return {
            TAG: /* VarBlockType */0,
            _0: at(vs33, s)
          };
  }
}

function instr(s) {
  var pos = s.pos.contents;
  var b = guard(get, s);
  switch (b) {
    case 0 :
        return Operators.unreachable;
    case 1 :
        return Operators.nop;
    case 2 :
        var bt = block_type(s);
        var es$p = List.rev(instr_block$p(s, /* [] */0));
        expect(11, s, "END opcode expected");
        return Operators.block(bt, es$p);
    case 3 :
        var bt$1 = block_type(s);
        var es$p$1 = List.rev(instr_block$p(s, /* [] */0));
        expect(11, s, "END opcode expected");
        return Operators.loop(bt$1, es$p$1);
    case 4 :
        var bt$2 = block_type(s);
        var es1 = List.rev(instr_block$p(s, /* [] */0));
        if (Caml_obj.caml_equal(peek(s), 5)) {
          expect(5, s, "ELSE or END opcode expected");
          var es2 = List.rev(instr_block$p(s, /* [] */0));
          expect(11, s, "END opcode expected");
          return Operators.if_(bt$2, es1, es2);
        }
        expect(11, s, "END opcode expected");
        return Operators.if_(bt$2, es1, /* [] */0);
    case 5 :
        return error(s, pos, "misplaced ELSE opcode");
    case 11 :
        return error(s, pos, "misplaced END opcode");
    case 12 :
        return Operators.br(at($$var, s));
    case 13 :
        return Operators.br_if(at($$var, s));
    case 14 :
        var xs = vec((function (param) {
                return at($$var, param);
              }), s);
        var x = at($$var, s);
        return Operators.br_table(xs, x);
    case 15 :
        return Operators.$$return;
    case 16 :
        return Operators.call(at($$var, s));
    case 17 :
        var y = at($$var, s);
        var x$1 = at($$var, s);
        return Operators.call_indirect(x$1, y);
    case 26 :
        return Operators.drop;
    case 27 :
        return Operators.select(undefined);
    case 28 :
        return Operators.select(vec(value_type, s));
    case 32 :
        return Operators.local_get(at($$var, s));
    case 33 :
        return Operators.local_set(at($$var, s));
    case 34 :
        return Operators.local_tee(at($$var, s));
    case 35 :
        return Operators.global_get(at($$var, s));
    case 36 :
        return Operators.global_set(at($$var, s));
    case 37 :
        return Operators.table_get(at($$var, s));
    case 38 :
        return Operators.table_set(at($$var, s));
    case 40 :
        var match = memop(s);
        return Operators.i32_load(match[0], match[1]);
    case 41 :
        var match$1 = memop(s);
        return Operators.i64_load(match$1[0], match$1[1]);
    case 42 :
        var match$2 = memop(s);
        return Operators.f32_load(match$2[0], match$2[1]);
    case 43 :
        var match$3 = memop(s);
        return Operators.f64_load(match$3[0], match$3[1]);
    case 44 :
        var match$4 = memop(s);
        return Operators.i32_load8_s(match$4[0], match$4[1]);
    case 45 :
        var match$5 = memop(s);
        return Operators.i32_load8_u(match$5[0], match$5[1]);
    case 46 :
        var match$6 = memop(s);
        return Operators.i32_load16_s(match$6[0], match$6[1]);
    case 47 :
        var match$7 = memop(s);
        return Operators.i32_load16_u(match$7[0], match$7[1]);
    case 48 :
        var match$8 = memop(s);
        return Operators.i64_load8_s(match$8[0], match$8[1]);
    case 49 :
        var match$9 = memop(s);
        return Operators.i64_load8_u(match$9[0], match$9[1]);
    case 50 :
        var match$10 = memop(s);
        return Operators.i64_load16_s(match$10[0], match$10[1]);
    case 51 :
        var match$11 = memop(s);
        return Operators.i64_load16_u(match$11[0], match$11[1]);
    case 52 :
        var match$12 = memop(s);
        return Operators.i64_load32_s(match$12[0], match$12[1]);
    case 53 :
        var match$13 = memop(s);
        return Operators.i64_load32_u(match$13[0], match$13[1]);
    case 54 :
        var match$14 = memop(s);
        return Operators.i32_store(match$14[0], match$14[1]);
    case 55 :
        var match$15 = memop(s);
        return Operators.i64_store(match$15[0], match$15[1]);
    case 56 :
        var match$16 = memop(s);
        return Operators.f32_store(match$16[0], match$16[1]);
    case 57 :
        var match$17 = memop(s);
        return Operators.f64_store(match$17[0], match$17[1]);
    case 58 :
        var match$18 = memop(s);
        return Operators.i32_store8(match$18[0], match$18[1]);
    case 59 :
        var match$19 = memop(s);
        return Operators.i32_store16(match$19[0], match$19[1]);
    case 60 :
        var match$20 = memop(s);
        return Operators.i64_store8(match$20[0], match$20[1]);
    case 61 :
        var match$21 = memop(s);
        return Operators.i64_store16(match$21[0], match$21[1]);
    case 62 :
        var match$22 = memop(s);
        return Operators.i64_store32(match$22[0], match$22[1]);
    case 63 :
        expect(0, s, "zero byte expected");
        return Operators.memory_size;
    case 64 :
        expect(0, s, "zero byte expected");
        return Operators.memory_grow;
    case 65 :
        return Operators.i32_const(at(vs32, s));
    case 66 :
        return Operators.i64_const(at(vs64, s));
    case 67 :
        return Operators.f32_const(at(f32, s));
    case 68 :
        return Operators.f64_const(at(f64, s));
    case 69 :
        return Operators.i32_eqz;
    case 70 :
        return Operators.i32_eq;
    case 71 :
        return Operators.i32_ne;
    case 72 :
        return Operators.i32_lt_s;
    case 73 :
        return Operators.i32_lt_u;
    case 74 :
        return Operators.i32_gt_s;
    case 75 :
        return Operators.i32_gt_u;
    case 76 :
        return Operators.i32_le_s;
    case 77 :
        return Operators.i32_le_u;
    case 78 :
        return Operators.i32_ge_s;
    case 79 :
        return Operators.i32_ge_u;
    case 80 :
        return Operators.i64_eqz;
    case 81 :
        return Operators.i64_eq;
    case 82 :
        return Operators.i64_ne;
    case 83 :
        return Operators.i64_lt_s;
    case 84 :
        return Operators.i64_lt_u;
    case 85 :
        return Operators.i64_gt_s;
    case 86 :
        return Operators.i64_gt_u;
    case 87 :
        return Operators.i64_le_s;
    case 88 :
        return Operators.i64_le_u;
    case 89 :
        return Operators.i64_ge_s;
    case 90 :
        return Operators.i64_ge_u;
    case 91 :
        return Operators.f32_eq;
    case 92 :
        return Operators.f32_ne;
    case 93 :
        return Operators.f32_lt;
    case 94 :
        return Operators.f32_gt;
    case 95 :
        return Operators.f32_le;
    case 96 :
        return Operators.f32_ge;
    case 97 :
        return Operators.f64_eq;
    case 98 :
        return Operators.f64_ne;
    case 99 :
        return Operators.f64_lt;
    case 100 :
        return Operators.f64_gt;
    case 101 :
        return Operators.f64_le;
    case 102 :
        return Operators.f64_ge;
    case 103 :
        return Operators.i32_clz;
    case 104 :
        return Operators.i32_ctz;
    case 105 :
        return Operators.i32_popcnt;
    case 106 :
        return Operators.i32_add;
    case 107 :
        return Operators.i32_sub;
    case 108 :
        return Operators.i32_mul;
    case 109 :
        return Operators.i32_div_s;
    case 110 :
        return Operators.i32_div_u;
    case 111 :
        return Operators.i32_rem_s;
    case 112 :
        return Operators.i32_rem_u;
    case 113 :
        return Operators.i32_and;
    case 114 :
        return Operators.i32_or;
    case 115 :
        return Operators.i32_xor;
    case 116 :
        return Operators.i32_shl;
    case 117 :
        return Operators.i32_shr_s;
    case 118 :
        return Operators.i32_shr_u;
    case 119 :
        return Operators.i32_rotl;
    case 120 :
        return Operators.i32_rotr;
    case 121 :
        return Operators.i64_clz;
    case 122 :
        return Operators.i64_ctz;
    case 123 :
        return Operators.i64_popcnt;
    case 124 :
        return Operators.i64_add;
    case 125 :
        return Operators.i64_sub;
    case 126 :
        return Operators.i64_mul;
    case 127 :
        return Operators.i64_div_s;
    case 128 :
        return Operators.i64_div_u;
    case 129 :
        return Operators.i64_rem_s;
    case 130 :
        return Operators.i64_rem_u;
    case 131 :
        return Operators.i64_and;
    case 132 :
        return Operators.i64_or;
    case 133 :
        return Operators.i64_xor;
    case 134 :
        return Operators.i64_shl;
    case 135 :
        return Operators.i64_shr_s;
    case 136 :
        return Operators.i64_shr_u;
    case 137 :
        return Operators.i64_rotl;
    case 138 :
        return Operators.i64_rotr;
    case 139 :
        return Operators.f32_abs;
    case 140 :
        return Operators.f32_neg;
    case 141 :
        return Operators.f32_ceil;
    case 142 :
        return Operators.f32_floor;
    case 143 :
        return Operators.f32_trunc;
    case 144 :
        return Operators.f32_nearest;
    case 145 :
        return Operators.f32_sqrt;
    case 146 :
        return Operators.f32_add;
    case 147 :
        return Operators.f32_sub;
    case 148 :
        return Operators.f32_mul;
    case 149 :
        return Operators.f32_div;
    case 150 :
        return Operators.f32_min;
    case 151 :
        return Operators.f32_max;
    case 152 :
        return Operators.f32_copysign;
    case 153 :
        return Operators.f64_abs;
    case 154 :
        return Operators.f64_neg;
    case 155 :
        return Operators.f64_ceil;
    case 156 :
        return Operators.f64_floor;
    case 157 :
        return Operators.f64_trunc;
    case 158 :
        return Operators.f64_nearest;
    case 159 :
        return Operators.f64_sqrt;
    case 160 :
        return Operators.f64_add;
    case 161 :
        return Operators.f64_sub;
    case 162 :
        return Operators.f64_mul;
    case 163 :
        return Operators.f64_div;
    case 164 :
        return Operators.f64_min;
    case 165 :
        return Operators.f64_max;
    case 166 :
        return Operators.f64_copysign;
    case 167 :
        return Operators.i32_wrap_i64;
    case 168 :
        return Operators.i32_trunc_f32_s;
    case 169 :
        return Operators.i32_trunc_f32_u;
    case 170 :
        return Operators.i32_trunc_f64_s;
    case 171 :
        return Operators.i32_trunc_f64_u;
    case 172 :
        return Operators.i64_extend_i32_s;
    case 173 :
        return Operators.i64_extend_i32_u;
    case 174 :
        return Operators.i64_trunc_f32_s;
    case 175 :
        return Operators.i64_trunc_f32_u;
    case 176 :
        return Operators.i64_trunc_f64_s;
    case 177 :
        return Operators.i64_trunc_f64_u;
    case 178 :
        return Operators.f32_convert_i32_s;
    case 179 :
        return Operators.f32_convert_i32_u;
    case 180 :
        return Operators.f32_convert_i64_s;
    case 181 :
        return Operators.f32_convert_i64_u;
    case 182 :
        return Operators.f32_demote_f64;
    case 183 :
        return Operators.f64_convert_i32_s;
    case 184 :
        return Operators.f64_convert_i32_u;
    case 185 :
        return Operators.f64_convert_i64_s;
    case 186 :
        return Operators.f64_convert_i64_u;
    case 187 :
        return Operators.f64_promote_f32;
    case 188 :
        return Operators.i32_reinterpret_f32;
    case 189 :
        return Operators.i64_reinterpret_f64;
    case 190 :
        return Operators.f32_reinterpret_i32;
    case 191 :
        return Operators.f64_reinterpret_i64;
    case 192 :
        return Operators.i32_extend8_s;
    case 193 :
        return Operators.i32_extend16_s;
    case 194 :
        return Operators.i64_extend8_s;
    case 195 :
        return Operators.i64_extend16_s;
    case 196 :
        return Operators.i64_extend32_s;
    case 208 :
        return Operators.ref_null(ref_type(s));
    case 209 :
        return Operators.ref_is_null;
    case 210 :
        return Operators.ref_func(at($$var, s));
    case 6 :
    case 7 :
    case 8 :
    case 9 :
    case 10 :
    case 18 :
    case 19 :
    case 20 :
    case 21 :
    case 22 :
    case 23 :
    case 24 :
    case 25 :
    case 29 :
    case 30 :
    case 31 :
    case 39 :
    case 197 :
    case 198 :
    case 199 :
    case 200 :
    case 201 :
    case 202 :
    case 203 :
    case 204 :
    case 205 :
    case 206 :
    case 207 :
    case 211 :
    case 212 :
    case 213 :
    case 214 :
    case 215 :
    case 216 :
    case 217 :
    case 218 :
    case 219 :
    case 220 :
    case 221 :
    case 222 :
    case 223 :
    case 224 :
    case 225 :
    case 226 :
    case 227 :
    case 228 :
    case 229 :
    case 230 :
    case 231 :
    case 232 :
    case 233 :
    case 234 :
    case 235 :
    case 236 :
    case 237 :
    case 238 :
    case 239 :
    case 240 :
    case 241 :
    case 242 :
    case 243 :
    case 244 :
    case 245 :
    case 246 :
    case 247 :
    case 248 :
    case 249 :
    case 250 :
    case 251 :
        return illegal(s, pos, b);
    case 252 :
        var n = Caml_int64.to_int32(vuN(32, s));
        if (n < 9) {
          if (n < 4) {
            if (n < 2) {
              if (n === 0) {
                return Operators.i32_trunc_sat_f32_s;
              }
              if (n === 1) {
                return Operators.i32_trunc_sat_f32_u;
              }
              
            } else {
              if (n === 2) {
                return Operators.i32_trunc_sat_f64_s;
              }
              if (n === 3) {
                return Operators.i32_trunc_sat_f64_u;
              }
              
            }
          } else if (n < 6) {
            if (n === 4) {
              return Operators.i64_trunc_sat_f32_s;
            }
            if (n === 5) {
              return Operators.i64_trunc_sat_f32_u;
            }
            
          } else {
            if (n === 6) {
              return Operators.i64_trunc_sat_f64_s;
            }
            if (n === 7) {
              return Operators.i64_trunc_sat_f64_u;
            }
            if (n === 8) {
              var x$2 = at($$var, s);
              expect(0, s, "zero byte expected");
              return Operators.memory_init(x$2);
            }
            
          }
        } else if (n < 13) {
          if (n < 11) {
            if (n === 9) {
              return Operators.data_drop(at($$var, s));
            }
            if (n === 10) {
              expect(0, s, "zero byte expected");
              expect(0, s, "zero byte expected");
              return Operators.memory_copy;
            }
            
          } else if (n !== 11) {
            if (n === 12) {
              var y$1 = at($$var, s);
              var x$3 = at($$var, s);
              return Operators.table_init(x$3, y$1);
            }
            
          } else {
            expect(0, s, "zero byte expected");
            return Operators.memory_fill;
          }
        } else if (n < 15) {
          if (n === 13) {
            return Operators.elem_drop(at($$var, s));
          }
          if (n === 14) {
            var x$4 = at($$var, s);
            var y$2 = at($$var, s);
            return Operators.table_copy(x$4, y$2);
          }
          
        } else {
          if (n === 15) {
            return Operators.table_grow(at($$var, s));
          }
          if (n === 16) {
            return Operators.table_size(at($$var, s));
          }
          if (n === 17) {
            return Operators.table_fill(at($$var, s));
          }
          
        }
        return error(s, pos, "illegal opcode " + (string_of_byte(b) + (" " + string_of_multi(n))));
    case 253 :
        var n$1 = Caml_int64.to_int32(vuN(32, s));
        if (n$1 < 118) {
          if (n$1 < 59) {
            if (n$1 < 29) {
              if (n$1 < 14) {
                if (n$1 < 7) {
                  if (n$1 < 3) {
                    if (n$1 !== 0) {
                      if (n$1 !== 1) {
                        if (n$1 === 2) {
                          var match$23 = memop(s);
                          return Operators.v128_load8x8_u(match$23[0], match$23[1]);
                        }
                        
                      } else {
                        var match$24 = memop(s);
                        return Operators.v128_load8x8_s(match$24[0], match$24[1]);
                      }
                    } else {
                      var match$25 = memop(s);
                      return Operators.v128_load(match$25[0], match$25[1]);
                    }
                  } else if (n$1 < 5) {
                    if (n$1 !== 3) {
                      if (n$1 === 4) {
                        var match$26 = memop(s);
                        return Operators.v128_load16x4_u(match$26[0], match$26[1]);
                      }
                      
                    } else {
                      var match$27 = memop(s);
                      return Operators.v128_load16x4_s(match$27[0], match$27[1]);
                    }
                  } else if (n$1 !== 5) {
                    if (n$1 === 6) {
                      var match$28 = memop(s);
                      return Operators.v128_load32x2_u(match$28[0], match$28[1]);
                    }
                    
                  } else {
                    var match$29 = memop(s);
                    return Operators.v128_load32x2_s(match$29[0], match$29[1]);
                  }
                } else if (n$1 < 10) {
                  if (n$1 !== 7) {
                    if (n$1 !== 8) {
                      if (n$1 === 9) {
                        var match$30 = memop(s);
                        return Operators.v128_load32_splat(match$30[0], match$30[1]);
                      }
                      
                    } else {
                      var match$31 = memop(s);
                      return Operators.v128_load16_splat(match$31[0], match$31[1]);
                    }
                  } else {
                    var match$32 = memop(s);
                    return Operators.v128_load8_splat(match$32[0], match$32[1]);
                  }
                } else if (n$1 < 12) {
                  if (n$1 !== 10) {
                    if (n$1 === 11) {
                      var match$33 = memop(s);
                      return Operators.v128_store(match$33[0], match$33[1]);
                    }
                    
                  } else {
                    var match$34 = memop(s);
                    return Operators.v128_load64_splat(match$34[0], match$34[1]);
                  }
                } else {
                  if (n$1 === 12) {
                    return Operators.v128_const(at(v128, s));
                  }
                  if (n$1 === 13) {
                    return Operators.i8x16_shuffle(List.init(16, (function (x) {
                                      return guard(get, s);
                                    })));
                  }
                  
                }
              } else if (n$1 < 21) {
                if (n$1 < 17) {
                  if (n$1 === 14) {
                    return Operators.i8x16_swizzle;
                  }
                  if (n$1 === 15) {
                    return Operators.i8x16_splat;
                  }
                  if (n$1 === 16) {
                    return Operators.i16x8_splat;
                  }
                  
                } else if (n$1 < 19) {
                  if (n$1 === 17) {
                    return Operators.i32x4_splat;
                  }
                  if (n$1 === 18) {
                    return Operators.i64x2_splat;
                  }
                  
                } else {
                  if (n$1 === 19) {
                    return Operators.f32x4_splat;
                  }
                  if (n$1 === 20) {
                    return Operators.f64x2_splat;
                  }
                  
                }
              } else if (n$1 < 25) {
                if (n$1 < 23) {
                  if (n$1 === 21) {
                    return Operators.i8x16_extract_lane_s(guard(get, s));
                  }
                  if (n$1 === 22) {
                    return Operators.i8x16_extract_lane_u(guard(get, s));
                  }
                  
                } else {
                  if (n$1 === 23) {
                    return Operators.i8x16_replace_lane(guard(get, s));
                  }
                  if (n$1 === 24) {
                    return Operators.i16x8_extract_lane_s(guard(get, s));
                  }
                  
                }
              } else if (n$1 < 27) {
                if (n$1 === 25) {
                  return Operators.i16x8_extract_lane_u(guard(get, s));
                }
                if (n$1 === 26) {
                  return Operators.i16x8_replace_lane(guard(get, s));
                }
                
              } else {
                if (n$1 === 27) {
                  return Operators.i32x4_extract_lane(guard(get, s));
                }
                if (n$1 === 28) {
                  return Operators.i32x4_replace_lane(guard(get, s));
                }
                
              }
            } else if (n$1 < 44) {
              if (n$1 < 36) {
                if (n$1 < 32) {
                  if (n$1 === 29) {
                    return Operators.i64x2_extract_lane(guard(get, s));
                  }
                  if (n$1 === 30) {
                    return Operators.i64x2_replace_lane(guard(get, s));
                  }
                  if (n$1 === 31) {
                    return Operators.f32x4_extract_lane(guard(get, s));
                  }
                  
                } else if (n$1 < 34) {
                  if (n$1 === 32) {
                    return Operators.f32x4_replace_lane(guard(get, s));
                  }
                  if (n$1 === 33) {
                    return Operators.f64x2_extract_lane(guard(get, s));
                  }
                  
                } else {
                  if (n$1 === 34) {
                    return Operators.f64x2_replace_lane(guard(get, s));
                  }
                  if (n$1 === 35) {
                    return Operators.i8x16_eq;
                  }
                  
                }
              } else if (n$1 < 40) {
                if (n$1 < 38) {
                  if (n$1 === 36) {
                    return Operators.i8x16_ne;
                  }
                  if (n$1 === 37) {
                    return Operators.i8x16_lt_s;
                  }
                  
                } else {
                  if (n$1 === 38) {
                    return Operators.i8x16_lt_u;
                  }
                  if (n$1 === 39) {
                    return Operators.i8x16_gt_s;
                  }
                  
                }
              } else if (n$1 < 42) {
                if (n$1 === 40) {
                  return Operators.i8x16_gt_u;
                }
                if (n$1 === 41) {
                  return Operators.i8x16_le_s;
                }
                
              } else {
                if (n$1 === 42) {
                  return Operators.i8x16_le_u;
                }
                if (n$1 === 43) {
                  return Operators.i8x16_ge_s;
                }
                
              }
            } else if (n$1 < 51) {
              if (n$1 < 47) {
                if (n$1 === 44) {
                  return Operators.i8x16_ge_u;
                }
                if (n$1 === 45) {
                  return Operators.i16x8_eq;
                }
                if (n$1 === 46) {
                  return Operators.i16x8_ne;
                }
                
              } else if (n$1 < 49) {
                if (n$1 === 47) {
                  return Operators.i16x8_lt_s;
                }
                if (n$1 === 48) {
                  return Operators.i16x8_lt_u;
                }
                
              } else {
                if (n$1 === 49) {
                  return Operators.i16x8_gt_s;
                }
                if (n$1 === 50) {
                  return Operators.i16x8_gt_u;
                }
                
              }
            } else if (n$1 < 55) {
              if (n$1 < 53) {
                if (n$1 === 51) {
                  return Operators.i16x8_le_s;
                }
                if (n$1 === 52) {
                  return Operators.i16x8_le_u;
                }
                
              } else {
                if (n$1 === 53) {
                  return Operators.i16x8_ge_s;
                }
                if (n$1 === 54) {
                  return Operators.i16x8_ge_u;
                }
                
              }
            } else if (n$1 < 57) {
              if (n$1 === 55) {
                return Operators.i32x4_eq;
              }
              if (n$1 === 56) {
                return Operators.i32x4_ne;
              }
              
            } else {
              if (n$1 === 57) {
                return Operators.i32x4_lt_s;
              }
              if (n$1 === 58) {
                return Operators.i32x4_lt_u;
              }
              
            }
          } else if (n$1 < 88) {
            if (n$1 < 73) {
              if (n$1 < 66) {
                if (n$1 < 62) {
                  if (n$1 === 59) {
                    return Operators.i32x4_gt_s;
                  }
                  if (n$1 === 60) {
                    return Operators.i32x4_gt_u;
                  }
                  if (n$1 === 61) {
                    return Operators.i32x4_le_s;
                  }
                  
                } else if (n$1 < 64) {
                  if (n$1 === 62) {
                    return Operators.i32x4_le_u;
                  }
                  if (n$1 === 63) {
                    return Operators.i32x4_ge_s;
                  }
                  
                } else {
                  if (n$1 === 64) {
                    return Operators.i32x4_ge_u;
                  }
                  if (n$1 === 65) {
                    return Operators.f32x4_eq;
                  }
                  
                }
              } else if (n$1 < 69) {
                if (n$1 === 66) {
                  return Operators.f32x4_ne;
                }
                if (n$1 === 67) {
                  return Operators.f32x4_lt;
                }
                if (n$1 === 68) {
                  return Operators.f32x4_gt;
                }
                
              } else if (n$1 < 71) {
                if (n$1 === 69) {
                  return Operators.f32x4_le;
                }
                if (n$1 === 70) {
                  return Operators.f32x4_ge;
                }
                
              } else {
                if (n$1 === 71) {
                  return Operators.f64x2_eq;
                }
                if (n$1 === 72) {
                  return Operators.f64x2_ne;
                }
                
              }
            } else if (n$1 < 80) {
              if (n$1 < 76) {
                if (n$1 === 73) {
                  return Operators.f64x2_lt;
                }
                if (n$1 === 74) {
                  return Operators.f64x2_gt;
                }
                if (n$1 === 75) {
                  return Operators.f64x2_le;
                }
                
              } else if (n$1 < 78) {
                if (n$1 === 76) {
                  return Operators.f64x2_ge;
                }
                if (n$1 === 77) {
                  return Operators.v128_not;
                }
                
              } else {
                if (n$1 === 78) {
                  return Operators.v128_and;
                }
                if (n$1 === 79) {
                  return Operators.v128_andnot;
                }
                
              }
            } else if (n$1 < 84) {
              if (n$1 < 82) {
                if (n$1 === 80) {
                  return Operators.v128_or;
                }
                if (n$1 === 81) {
                  return Operators.v128_xor;
                }
                
              } else {
                if (n$1 === 82) {
                  return Operators.v128_bitselect;
                }
                if (n$1 === 83) {
                  return Operators.v128_any_true;
                }
                
              }
            } else if (n$1 < 86) {
              if (n$1 !== 84) {
                if (n$1 === 85) {
                  var match$35 = memop(s);
                  var lane = guard(get, s);
                  return Operators.v128_load16_lane(match$35[0], match$35[1], lane);
                }
                
              } else {
                var match$36 = memop(s);
                var lane$1 = guard(get, s);
                return Operators.v128_load8_lane(match$36[0], match$36[1], lane$1);
              }
            } else if (n$1 !== 86) {
              if (n$1 === 87) {
                var match$37 = memop(s);
                var lane$2 = guard(get, s);
                return Operators.v128_load64_lane(match$37[0], match$37[1], lane$2);
              }
              
            } else {
              var match$38 = memop(s);
              var lane$3 = guard(get, s);
              return Operators.v128_load32_lane(match$38[0], match$38[1], lane$3);
            }
          } else if (n$1 < 103) {
            if (n$1 < 95) {
              if (n$1 < 91) {
                if (n$1 !== 88) {
                  if (n$1 !== 89) {
                    if (n$1 === 90) {
                      var match$39 = memop(s);
                      var lane$4 = guard(get, s);
                      return Operators.v128_store32_lane(match$39[0], match$39[1], lane$4);
                    }
                    
                  } else {
                    var match$40 = memop(s);
                    var lane$5 = guard(get, s);
                    return Operators.v128_store16_lane(match$40[0], match$40[1], lane$5);
                  }
                } else {
                  var match$41 = memop(s);
                  var lane$6 = guard(get, s);
                  return Operators.v128_store8_lane(match$41[0], match$41[1], lane$6);
                }
              } else if (n$1 < 93) {
                if (n$1 !== 91) {
                  if (n$1 === 92) {
                    var match$42 = memop(s);
                    return Operators.v128_load32_zero(match$42[0], match$42[1]);
                  }
                  
                } else {
                  var match$43 = memop(s);
                  var lane$7 = guard(get, s);
                  return Operators.v128_store64_lane(match$43[0], match$43[1], lane$7);
                }
              } else if (n$1 !== 93) {
                if (n$1 === 94) {
                  return Operators.f32x4_demote_f64x2_zero;
                }
                
              } else {
                var match$44 = memop(s);
                return Operators.v128_load64_zero(match$44[0], match$44[1]);
              }
            } else if (n$1 < 99) {
              if (n$1 < 97) {
                if (n$1 === 95) {
                  return Operators.f64x2_promote_low_f32x4;
                }
                if (n$1 === 96) {
                  return Operators.i8x16_abs;
                }
                
              } else {
                if (n$1 === 97) {
                  return Operators.i8x16_neg;
                }
                if (n$1 === 98) {
                  return Operators.i8x16_popcnt;
                }
                
              }
            } else if (n$1 < 101) {
              if (n$1 === 99) {
                return Operators.i8x16_all_true;
              }
              if (n$1 === 100) {
                return Operators.i8x16_bitmask;
              }
              
            } else {
              if (n$1 === 101) {
                return Operators.i8x16_narrow_i16x8_s;
              }
              if (n$1 === 102) {
                return Operators.i8x16_narrow_i16x8_u;
              }
              
            }
          } else if (n$1 < 110) {
            if (n$1 < 106) {
              if (n$1 === 103) {
                return Operators.f32x4_ceil;
              }
              if (n$1 === 104) {
                return Operators.f32x4_floor;
              }
              if (n$1 === 105) {
                return Operators.f32x4_trunc;
              }
              
            } else if (n$1 < 108) {
              if (n$1 === 106) {
                return Operators.f32x4_nearest;
              }
              if (n$1 === 107) {
                return Operators.i8x16_shl;
              }
              
            } else {
              if (n$1 === 108) {
                return Operators.i8x16_shr_s;
              }
              if (n$1 === 109) {
                return Operators.i8x16_shr_u;
              }
              
            }
          } else if (n$1 < 114) {
            if (n$1 < 112) {
              if (n$1 === 110) {
                return Operators.i8x16_add;
              }
              if (n$1 === 111) {
                return Operators.i8x16_add_sat_s;
              }
              
            } else {
              if (n$1 === 112) {
                return Operators.i8x16_add_sat_u;
              }
              if (n$1 === 113) {
                return Operators.i8x16_sub;
              }
              
            }
          } else if (n$1 < 116) {
            if (n$1 === 114) {
              return Operators.i8x16_sub_sat_s;
            }
            if (n$1 === 115) {
              return Operators.i8x16_sub_sat_u;
            }
            
          } else {
            if (n$1 === 116) {
              return Operators.f64x2_ceil;
            }
            if (n$1 === 117) {
              return Operators.f64x2_floor;
            }
            
          }
        } else if (n$1 < 186) {
          if (n$1 < 147) {
            if (n$1 < 132) {
              if (n$1 < 125) {
                if (n$1 < 121) {
                  if (n$1 === 118) {
                    return Operators.i8x16_min_s;
                  }
                  if (n$1 === 119) {
                    return Operators.i8x16_min_u;
                  }
                  if (n$1 === 120) {
                    return Operators.i8x16_max_s;
                  }
                  
                } else if (n$1 < 123) {
                  if (n$1 === 121) {
                    return Operators.i8x16_max_u;
                  }
                  if (n$1 === 122) {
                    return Operators.f64x2_trunc;
                  }
                  
                } else {
                  if (n$1 === 123) {
                    return Operators.i8x16_avgr_u;
                  }
                  if (n$1 === 124) {
                    return Operators.i16x8_extadd_pairwise_i8x16_s;
                  }
                  
                }
              } else if (n$1 < 128) {
                if (n$1 === 125) {
                  return Operators.i16x8_extadd_pairwise_i8x16_u;
                }
                if (n$1 === 126) {
                  return Operators.i32x4_extadd_pairwise_i16x8_s;
                }
                if (n$1 === 127) {
                  return Operators.i32x4_extadd_pairwise_i16x8_u;
                }
                
              } else if (n$1 < 130) {
                if (n$1 === 128) {
                  return Operators.i16x8_abs;
                }
                if (n$1 === 129) {
                  return Operators.i16x8_neg;
                }
                
              } else {
                if (n$1 === 130) {
                  return Operators.i16x8_q15mulr_sat_s;
                }
                if (n$1 === 131) {
                  return Operators.i16x8_all_true;
                }
                
              }
            } else if (n$1 < 139) {
              if (n$1 < 135) {
                if (n$1 === 132) {
                  return Operators.i16x8_bitmask;
                }
                if (n$1 === 133) {
                  return Operators.i16x8_narrow_i32x4_s;
                }
                if (n$1 === 134) {
                  return Operators.i16x8_narrow_i32x4_u;
                }
                
              } else if (n$1 < 137) {
                if (n$1 === 135) {
                  return Operators.i16x8_extend_low_i8x16_s;
                }
                if (n$1 === 136) {
                  return Operators.i16x8_extend_high_i8x16_s;
                }
                
              } else {
                if (n$1 === 137) {
                  return Operators.i16x8_extend_low_i8x16_u;
                }
                if (n$1 === 138) {
                  return Operators.i16x8_extend_high_i8x16_u;
                }
                
              }
            } else if (n$1 < 143) {
              if (n$1 < 141) {
                if (n$1 === 139) {
                  return Operators.i16x8_shl;
                }
                if (n$1 === 140) {
                  return Operators.i16x8_shr_s;
                }
                
              } else {
                if (n$1 === 141) {
                  return Operators.i16x8_shr_u;
                }
                if (n$1 === 142) {
                  return Operators.i16x8_add;
                }
                
              }
            } else if (n$1 < 145) {
              if (n$1 === 143) {
                return Operators.i16x8_add_sat_s;
              }
              if (n$1 === 144) {
                return Operators.i16x8_add_sat_u;
              }
              
            } else {
              if (n$1 === 145) {
                return Operators.i16x8_sub;
              }
              if (n$1 === 146) {
                return Operators.i16x8_sub_sat_s;
              }
              
            }
          } else if (n$1 < 164) {
            if (n$1 < 155) {
              if (n$1 < 150) {
                if (n$1 === 147) {
                  return Operators.i16x8_sub_sat_u;
                }
                if (n$1 === 148) {
                  return Operators.f64x2_nearest;
                }
                if (n$1 === 149) {
                  return Operators.i16x8_mul;
                }
                
              } else if (n$1 < 152) {
                if (n$1 === 150) {
                  return Operators.i16x8_min_s;
                }
                if (n$1 === 151) {
                  return Operators.i16x8_min_u;
                }
                
              } else {
                if (n$1 === 152) {
                  return Operators.i16x8_max_s;
                }
                if (n$1 === 153) {
                  return Operators.i16x8_max_u;
                }
                
              }
            } else if (n$1 < 159) {
              if (n$1 < 157) {
                if (n$1 === 155) {
                  return Operators.i16x8_avgr_u;
                }
                if (n$1 === 156) {
                  return Operators.i16x8_extmul_low_i8x16_s;
                }
                
              } else {
                if (n$1 === 157) {
                  return Operators.i16x8_extmul_high_i8x16_s;
                }
                if (n$1 === 158) {
                  return Operators.i16x8_extmul_low_i8x16_u;
                }
                
              }
            } else if (n$1 < 161) {
              if (n$1 === 159) {
                return Operators.i16x8_extmul_high_i8x16_u;
              }
              if (n$1 === 160) {
                return Operators.i32x4_abs;
              }
              
            } else {
              if (n$1 === 161) {
                return Operators.i32x4_neg;
              }
              if (n$1 === 163) {
                return Operators.i32x4_all_true;
              }
              
            }
          } else if (n$1 < 173) {
            if (n$1 < 169) {
              if (n$1 === 164) {
                return Operators.i32x4_bitmask;
              }
              if (n$1 === 167) {
                return Operators.i32x4_extend_low_i16x8_s;
              }
              if (n$1 === 168) {
                return Operators.i32x4_extend_high_i16x8_s;
              }
              
            } else if (n$1 < 171) {
              if (n$1 === 169) {
                return Operators.i32x4_extend_low_i16x8_u;
              }
              if (n$1 === 170) {
                return Operators.i32x4_extend_high_i16x8_u;
              }
              
            } else {
              if (n$1 === 171) {
                return Operators.i32x4_shl;
              }
              if (n$1 === 172) {
                return Operators.i32x4_shr_s;
              }
              
            }
          } else if (n$1 < 182) {
            if (n$1 < 177) {
              if (n$1 === 173) {
                return Operators.i32x4_shr_u;
              }
              if (n$1 === 174) {
                return Operators.i32x4_add;
              }
              
            } else {
              if (n$1 === 177) {
                return Operators.i32x4_sub;
              }
              if (n$1 === 181) {
                return Operators.i32x4_mul;
              }
              
            }
          } else if (n$1 < 184) {
            if (n$1 === 182) {
              return Operators.i32x4_min_s;
            }
            if (n$1 === 183) {
              return Operators.i32x4_min_u;
            }
            
          } else {
            if (n$1 === 184) {
              return Operators.i32x4_max_s;
            }
            if (n$1 === 185) {
              return Operators.i32x4_max_u;
            }
            
          }
        } else if (n$1 < 224) {
          if (n$1 < 204) {
            if (n$1 < 195) {
              if (n$1 < 190) {
                if (n$1 === 186) {
                  return Operators.i32x4_dot_i16x8_s;
                }
                if (n$1 === 188) {
                  return Operators.i32x4_extmul_low_i16x8_s;
                }
                if (n$1 === 189) {
                  return Operators.i32x4_extmul_high_i16x8_s;
                }
                
              } else if (n$1 < 192) {
                if (n$1 === 190) {
                  return Operators.i32x4_extmul_low_i16x8_u;
                }
                if (n$1 === 191) {
                  return Operators.i32x4_extmul_high_i16x8_u;
                }
                
              } else {
                if (n$1 === 192) {
                  return Operators.i64x2_abs;
                }
                if (n$1 === 193) {
                  return Operators.i64x2_neg;
                }
                
              }
            } else if (n$1 < 200) {
              if (n$1 === 195) {
                return Operators.i64x2_all_true;
              }
              if (n$1 === 196) {
                return Operators.i64x2_bitmask;
              }
              if (n$1 === 199) {
                return Operators.i64x2_extend_low_i32x4_s;
              }
              
            } else if (n$1 < 202) {
              if (n$1 === 200) {
                return Operators.i64x2_extend_high_i32x4_s;
              }
              if (n$1 === 201) {
                return Operators.i64x2_extend_low_i32x4_u;
              }
              
            } else {
              if (n$1 === 202) {
                return Operators.i64x2_extend_high_i32x4_u;
              }
              if (n$1 === 203) {
                return Operators.i64x2_shl;
              }
              
            }
          } else if (n$1 < 216) {
            if (n$1 < 209) {
              if (n$1 === 204) {
                return Operators.i64x2_shr_s;
              }
              if (n$1 === 205) {
                return Operators.i64x2_shr_u;
              }
              if (n$1 === 206) {
                return Operators.i64x2_add;
              }
              
            } else if (n$1 < 214) {
              if (n$1 === 209) {
                return Operators.i64x2_sub;
              }
              if (n$1 === 213) {
                return Operators.i64x2_mul;
              }
              
            } else {
              if (n$1 === 214) {
                return Operators.i64x2_eq;
              }
              if (n$1 === 215) {
                return Operators.i64x2_ne;
              }
              
            }
          } else if (n$1 < 220) {
            if (n$1 < 218) {
              if (n$1 === 216) {
                return Operators.i64x2_lt_s;
              }
              if (n$1 === 217) {
                return Operators.i64x2_gt_s;
              }
              
            } else {
              if (n$1 === 218) {
                return Operators.i64x2_le_s;
              }
              if (n$1 === 219) {
                return Operators.i64x2_ge_s;
              }
              
            }
          } else if (n$1 < 222) {
            if (n$1 === 220) {
              return Operators.i64x2_extmul_low_i32x4_s;
            }
            if (n$1 === 221) {
              return Operators.i64x2_extmul_high_i32x4_s;
            }
            
          } else {
            if (n$1 === 222) {
              return Operators.i64x2_extmul_low_i32x4_u;
            }
            if (n$1 === 223) {
              return Operators.i64x2_extmul_high_i32x4_u;
            }
            
          }
        } else if (n$1 < 241) {
          if (n$1 < 232) {
            if (n$1 < 228) {
              if (n$1 === 224) {
                return Operators.f32x4_abs;
              }
              if (n$1 === 225) {
                return Operators.f32x4_neg;
              }
              if (n$1 === 227) {
                return Operators.f32x4_sqrt;
              }
              
            } else if (n$1 < 230) {
              if (n$1 === 228) {
                return Operators.f32x4_add;
              }
              if (n$1 === 229) {
                return Operators.f32x4_sub;
              }
              
            } else {
              if (n$1 === 230) {
                return Operators.f32x4_mul;
              }
              if (n$1 === 231) {
                return Operators.f32x4_div;
              }
              
            }
          } else if (n$1 < 236) {
            if (n$1 < 234) {
              if (n$1 === 232) {
                return Operators.f32x4_min;
              }
              if (n$1 === 233) {
                return Operators.f32x4_max;
              }
              
            } else {
              if (n$1 === 234) {
                return Operators.f32x4_pmin;
              }
              if (n$1 === 235) {
                return Operators.f32x4_pmax;
              }
              
            }
          } else if (n$1 < 239) {
            if (n$1 === 236) {
              return Operators.f64x2_abs;
            }
            if (n$1 === 237) {
              return Operators.f64x2_neg;
            }
            
          } else {
            if (n$1 === 239) {
              return Operators.f64x2_sqrt;
            }
            if (n$1 === 240) {
              return Operators.f64x2_add;
            }
            
          }
        } else if (n$1 < 248) {
          if (n$1 < 244) {
            if (n$1 === 241) {
              return Operators.f64x2_sub;
            }
            if (n$1 === 242) {
              return Operators.f64x2_mul;
            }
            if (n$1 === 243) {
              return Operators.f64x2_div;
            }
            
          } else if (n$1 < 246) {
            if (n$1 === 244) {
              return Operators.f64x2_min;
            }
            if (n$1 === 245) {
              return Operators.f64x2_max;
            }
            
          } else {
            if (n$1 === 246) {
              return Operators.f64x2_pmin;
            }
            if (n$1 === 247) {
              return Operators.f64x2_pmax;
            }
            
          }
        } else if (n$1 < 252) {
          if (n$1 < 250) {
            if (n$1 === 248) {
              return Operators.i32x4_trunc_sat_f32x4_s;
            }
            if (n$1 === 249) {
              return Operators.i32x4_trunc_sat_f32x4_u;
            }
            
          } else {
            if (n$1 === 250) {
              return Operators.f32x4_convert_i32x4_s;
            }
            if (n$1 === 251) {
              return Operators.f32x4_convert_i32x4_u;
            }
            
          }
        } else if (n$1 < 254) {
          if (n$1 === 252) {
            return Operators.i32x4_trunc_sat_f64x2_s_zero;
          }
          if (n$1 === 253) {
            return Operators.i32x4_trunc_sat_f64x2_u_zero;
          }
          
        } else {
          if (n$1 === 254) {
            return Operators.f64x2_convert_low_i32x4_s;
          }
          if (n$1 === 255) {
            return Operators.f64x2_convert_low_i32x4_u;
          }
          
        }
        return illegal(s, pos, Curry._1(I32.to_int_u, n$1));
    default:
      return illegal(s, pos, b);
  }
}

function instr_block$p(s, _es) {
  while(true) {
    var es = _es;
    var match = peek(s);
    if (match === undefined) {
      return es;
    }
    if (match === 5) {
      return es;
    }
    if (match === 11) {
      return es;
    }
    var pos = s.pos.contents;
    var e$p = instr(s);
    _es = {
      hd: Source.$at$at(e$p, region(s, pos, pos)),
      tl: es
    };
    continue ;
  };
}

function instr_block(s) {
  return List.rev(instr_block$p(s, /* [] */0));
}

function $$const(s) {
  var c = at(instr_block, s);
  expect(11, s, "END opcode expected");
  return c;
}

function id(s) {
  var bo = peek(s);
  return Lib.$$Option.map((function (param) {
                switch (param) {
                  case 0 :
                      return "CustomSection";
                  case 1 :
                      return "TypeSection";
                  case 2 :
                      return "ImportSection";
                  case 3 :
                      return "FuncSection";
                  case 4 :
                      return "TableSection";
                  case 5 :
                      return "MemorySection";
                  case 6 :
                      return "GlobalSection";
                  case 7 :
                      return "ExportSection";
                  case 8 :
                      return "StartSection";
                  case 9 :
                      return "ElemSection";
                  case 10 :
                      return "CodeSection";
                  case 11 :
                      return "DataSection";
                  case 12 :
                      return "DataCountSection";
                  default:
                    return error(s, s.pos.contents, "malformed section id");
                }
              }), bo);
}

function section_with_size(tag, f, $$default, s) {
  var tag$p = id(s);
  if (tag$p !== undefined && Caml_obj.caml_equal(tag$p, tag)) {
    guard(get, s);
    return sized(f, s);
  } else {
    return $$default;
  }
}

function section(tag, f, $$default, s) {
  return section_with_size(tag, (function (param) {
                return f;
              }), $$default, s);
}

function type_(s) {
  return at(func_type, s);
}

function type_section(s) {
  return section("TypeSection", (function (param) {
                return vec(type_, param);
              }), /* [] */0, s);
}

function import_desc(s) {
  var match = guard(get, s);
  switch (match) {
    case 0 :
        return {
                TAG: /* FuncImport */0,
                _0: at($$var, s)
              };
    case 1 :
        return {
                TAG: /* TableImport */1,
                _0: table_type(s)
              };
    case 2 :
        return {
                TAG: /* MemoryImport */2,
                _0: memory_type(s)
              };
    case 3 :
        return {
                TAG: /* GlobalImport */3,
                _0: global_type(s)
              };
    default:
      return error(s, s.pos.contents - 1 | 0, "malformed import kind");
  }
}

function $$import(s) {
  var module_name = name(s);
  var item_name = name(s);
  var idesc = at(import_desc, s);
  return {
          module_name: module_name,
          item_name: item_name,
          idesc: idesc
        };
}

function import_section(s) {
  return section("ImportSection", (function (param) {
                return vec((function (param) {
                              return at($$import, param);
                            }), param);
              }), /* [] */0, s);
}

function func_section(s) {
  return section("FuncSection", (function (param) {
                return vec((function (param) {
                              return at($$var, param);
                            }), param);
              }), /* [] */0, s);
}

function table(s) {
  var ttype = table_type(s);
  return {
          ttype: ttype
        };
}

function table_section(s) {
  return section("TableSection", (function (param) {
                return vec((function (param) {
                              return at(table, param);
                            }), param);
              }), /* [] */0, s);
}

function memory(s) {
  var mtype = memory_type(s);
  return {
          mtype: mtype
        };
}

function memory_section(s) {
  return section("MemorySection", (function (param) {
                return vec((function (param) {
                              return at(memory, param);
                            }), param);
              }), /* [] */0, s);
}

function $$global(s) {
  var gtype = global_type(s);
  var ginit = $$const(s);
  return {
          gtype: gtype,
          ginit: ginit
        };
}

function global_section(s) {
  return section("GlobalSection", (function (param) {
                return vec((function (param) {
                              return at($$global, param);
                            }), param);
              }), /* [] */0, s);
}

function export_desc(s) {
  var match = guard(get, s);
  switch (match) {
    case 0 :
        return {
                TAG: /* FuncExport */0,
                _0: at($$var, s)
              };
    case 1 :
        return {
                TAG: /* TableExport */1,
                _0: at($$var, s)
              };
    case 2 :
        return {
                TAG: /* MemoryExport */2,
                _0: at($$var, s)
              };
    case 3 :
        return {
                TAG: /* GlobalExport */3,
                _0: at($$var, s)
              };
    default:
      return error(s, s.pos.contents - 1 | 0, "malformed export kind");
  }
}

function $$export(s) {
  var name$1 = name(s);
  var edesc = at(export_desc, s);
  return {
          name: name$1,
          edesc: edesc
        };
}

function export_section(s) {
  return section("ExportSection", (function (param) {
                return vec((function (param) {
                              return at($$export, param);
                            }), param);
              }), /* [] */0, s);
}

function start(s) {
  var sfunc = at($$var, s);
  return {
          sfunc: sfunc
        };
}

function start_section(s) {
  return section("StartSection", (function (param) {
                return Caml_option.some(at(start, param));
              }), undefined, s);
}

function local(s) {
  var n = Caml_int64.to_int32(vuN(32, s));
  var t = value_type(s);
  return [
          n,
          t
        ];
}

function code(param, s) {
  var pos = s.pos.contents;
  var nts = vec(local, s);
  var ns = List.map((function (param) {
          return I64_convert.extend_i32_u(param[0]);
        }), nts);
  $$require(Curry._2(I64.lt_u, List.fold_left(I64.add, Caml_int64.zero, ns), [
            1,
            0
          ]), s, pos, "too many locals");
  var locals = List.flatten(List.map((function (param) {
              return Lib.Fun.uncurry(Lib.List32.make, param);
            }), nts));
  var body = List.rev(instr_block$p(s, /* [] */0));
  expect(11, s, "END opcode expected");
  return {
          ftype: Source.$at$at(-1, Source.no_region),
          locals: locals,
          body: body
        };
}

function code_section(s) {
  return section("CodeSection", (function (param) {
                return vec((function (param) {
                              return at((function (param) {
                                            return sized(code, param);
                                          }), param);
                            }), param);
              }), /* [] */0, s);
}

function passive(s) {
  return /* Passive */0;
}

function active(s) {
  var index = at($$var, s);
  var offset = $$const(s);
  return /* Active */{
          index: index,
          offset: offset
        };
}

function active_zero(s) {
  var index = Source.$at$at(0, Source.no_region);
  var offset = $$const(s);
  return /* Active */{
          index: index,
          offset: offset
        };
}

function declarative(s) {
  return /* Declarative */1;
}

function elem_index(s) {
  var x = at($$var, s);
  return {
          hd: Source.$at$at(Operators.ref_func(x), x.at),
          tl: /* [] */0
        };
}

function elem_kind(s) {
  var match = guard(get, s);
  if (match !== 0) {
    return error(s, s.pos.contents - 1 | 0, "malformed element kind");
  } else {
    return /* FuncRefType */0;
  }
}

function elem(s) {
  var match = Caml_int64.to_int32(vuN(32, s));
  if (match < 4) {
    if (match < 2) {
      if (match !== 0) {
        if (match === 1) {
          var emode = at(passive, s);
          var etype = elem_kind(s);
          var einit = vec((function (param) {
                  return at(elem_index, param);
                }), s);
          return {
                  etype: etype,
                  einit: einit,
                  emode: emode
                };
        }
        
      } else {
        var emode$1 = at(active_zero, s);
        var einit$1 = vec((function (param) {
                return at(elem_index, param);
              }), s);
        return {
                etype: /* FuncRefType */0,
                einit: einit$1,
                emode: emode$1
              };
      }
    } else if (match !== 2) {
      if (match === 3) {
        var emode$2 = at(declarative, s);
        var etype$1 = elem_kind(s);
        var einit$2 = vec((function (param) {
                return at(elem_index, param);
              }), s);
        return {
                etype: etype$1,
                einit: einit$2,
                emode: emode$2
              };
      }
      
    } else {
      var emode$3 = at(active, s);
      var etype$2 = elem_kind(s);
      var einit$3 = vec((function (param) {
              return at(elem_index, param);
            }), s);
      return {
              etype: etype$2,
              einit: einit$3,
              emode: emode$3
            };
    }
  } else if (match < 6) {
    if (match !== 4) {
      if (match === 5) {
        var emode$4 = at(passive, s);
        var etype$3 = ref_type(s);
        var einit$4 = vec($$const, s);
        return {
                etype: etype$3,
                einit: einit$4,
                emode: emode$4
              };
      }
      
    } else {
      var emode$5 = at(active_zero, s);
      var einit$5 = vec($$const, s);
      return {
              etype: /* FuncRefType */0,
              einit: einit$5,
              emode: emode$5
            };
    }
  } else if (match !== 6) {
    if (match === 7) {
      var emode$6 = at(declarative, s);
      var etype$4 = ref_type(s);
      var einit$6 = vec($$const, s);
      return {
              etype: etype$4,
              einit: einit$6,
              emode: emode$6
            };
    }
    
  } else {
    var emode$7 = at(active, s);
    var etype$5 = ref_type(s);
    var einit$7 = vec($$const, s);
    return {
            etype: etype$5,
            einit: einit$7,
            emode: emode$7
          };
  }
  return error(s, s.pos.contents - 1 | 0, "malformed elements segment kind");
}

function elem_section(s) {
  return section("ElemSection", (function (param) {
                return vec((function (param) {
                              return at(elem, param);
                            }), param);
              }), /* [] */0, s);
}

function data(s) {
  var match = Caml_int64.to_int32(vuN(32, s));
  if (match !== 0) {
    if (match !== 1) {
      if (match !== 2) {
        return error(s, s.pos.contents - 1 | 0, "malformed data segment kind");
      }
      var dmode = at(active, s);
      var dinit = string(s);
      return {
              dinit: dinit,
              dmode: dmode
            };
    }
    var dmode$1 = at(passive, s);
    var dinit$1 = string(s);
    return {
            dinit: dinit$1,
            dmode: dmode$1
          };
  }
  var dmode$2 = at(active_zero, s);
  var dinit$2 = string(s);
  return {
          dinit: dinit$2,
          dmode: dmode$2
        };
}

function data_section(s) {
  return section("DataSection", (function (param) {
                return vec((function (param) {
                              return at(data, param);
                            }), param);
              }), /* [] */0, s);
}

function data_count(s) {
  return Caml_int64.to_int32(vuN(32, s));
}

function data_count_section(s) {
  return section("DataCountSection", data_count, undefined, s);
}

function custom(size, s) {
  var start = s.pos.contents;
  var id = name(s);
  var bs = get_string(size - (s.pos.contents - start | 0) | 0)(s);
  return [
          id,
          bs
        ];
}

function custom_section(s) {
  return section_with_size("CustomSection", custom, undefined, s);
}

function non_custom_section(s) {
  var match = id(s);
  if (match !== undefined && match !== "CustomSection") {
    guard((function (param) {
            return skip(1, param);
          }), s);
    sized(skip$1, s);
    return Caml_option.some(undefined);
  }
  
}

function iterate(f, s) {
  while(true) {
    if (Curry._1(f, s) === undefined) {
      return ;
    }
    continue ;
  };
}

function module_(s) {
  var header = u32(s);
  $$require(header === 1836278016, s, 0, "magic header not detected");
  var version = u32(s);
  $$require(version === Encode.version, s, 4, "unknown binary version");
  iterate(custom_section, s);
  var types = type_section(s);
  iterate(custom_section, s);
  var imports = import_section(s);
  iterate(custom_section, s);
  var func_types = func_section(s);
  iterate(custom_section, s);
  var tables = table_section(s);
  iterate(custom_section, s);
  var memories = memory_section(s);
  iterate(custom_section, s);
  var globals = global_section(s);
  iterate(custom_section, s);
  var $$exports = export_section(s);
  iterate(custom_section, s);
  var start = start_section(s);
  iterate(custom_section, s);
  var elems = elem_section(s);
  iterate(custom_section, s);
  var data_count = data_count_section(s);
  iterate(custom_section, s);
  var func_bodies = code_section(s);
  iterate(custom_section, s);
  var datas = data_section(s);
  iterate(custom_section, s);
  $$require(s.pos.contents === s.bytes.length, s, s.bytes.length, "unexpected content after last section");
  $$require(List.length(func_types) === List.length(func_bodies), s, s.bytes.length, "function and code section have inconsistent lengths");
  $$require(data_count === undefined || Caml_obj.caml_equal(data_count, Lib.List32.length(datas)), s, s.bytes.length, "data count and data section have inconsistent lengths");
  $$require(data_count !== undefined || List.for_all((function (f) {
              return Caml_obj.caml_equal(Free.func(f).datas, Free.$$Set.empty);
            }), func_bodies), s, s.bytes.length, "data count section required");
  var funcs = List.map2((function (t, f) {
          var init = f.it;
          return Source.$at$at({
                      ftype: t,
                      locals: init.locals,
                      body: init.body
                    }, f.at);
        }), func_types, func_bodies);
  return {
          types: types,
          globals: globals,
          tables: tables,
          memories: memories,
          funcs: funcs,
          start: start,
          elems: elems,
          datas: datas,
          imports: imports,
          exports: $$exports
        };
}

function decode(name, bs) {
  return at(module_, stream(name, bs));
}

function decode_custom(tag, name, bs) {
  var s = stream(name, bs);
  var header = u32(s);
  $$require(header === 1836278016, s, 0, "magic header not detected");
  var version = u32(s);
  $$require(version === Encode.version, s, 4, "unknown binary version");
  var collect = function (_param) {
    while(true) {
      iterate(non_custom_section, s);
      var match = custom_section(s);
      if (match === undefined) {
        return /* [] */0;
      }
      if (Caml_obj.caml_equal(match[0], tag)) {
        return {
                hd: match[1],
                tl: collect(undefined)
              };
      }
      _param = undefined;
      continue ;
    };
  };
  return collect(undefined);
}

export {
  Code$1 as Code,
  decode ,
  decode_custom ,
  
}
/* Code Not a pure module */
