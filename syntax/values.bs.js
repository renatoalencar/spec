// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var F32 = require("../exec/f32.bs.js");
var F64 = require("../exec/f64.bs.js");
var I32 = require("../exec/i32.bs.js");
var I64 = require("../exec/i64.bs.js");
var List = require("rescript/lib/js/list.js");
var V128 = require("../exec/v128.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var $$String = require("rescript/lib/js/string.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var NullRef = /* @__PURE__ */Caml_exceptions.create("Values.NullRef");

function as_num(n) {
  switch (n.TAG | 0) {
    case /* Num */0 :
        return n._0;
    case /* Vec */1 :
    case /* Ref */2 :
        return Pervasives.failwith("as_num");
    
  }
}

function as_vec(i) {
  switch (i.TAG | 0) {
    case /* Vec */1 :
        return i._0;
    case /* Num */0 :
    case /* Ref */2 :
        return Pervasives.failwith("as_vec");
    
  }
}

function as_ref(r) {
  switch (r.TAG | 0) {
    case /* Num */0 :
    case /* Vec */1 :
        return Pervasives.failwith("as_ref");
    case /* Ref */2 :
        return r._0;
    
  }
}

var $$TypeError = /* @__PURE__ */Caml_exceptions.create("Values.TypeError");

function to_num(i) {
  return {
          TAG: /* I32 */0,
          _0: i
        };
}

function of_num(n, i) {
  if (i.TAG === /* I32 */0) {
    return i._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: i,
        _3: /* I32Type */0,
        Error: new Error()
      };
}

var I32Num = {
  to_num: to_num,
  of_num: of_num
};

function to_num$1(i) {
  return {
          TAG: /* I64 */1,
          _0: i
        };
}

function of_num$1(n, i) {
  if (i.TAG === /* I64 */1) {
    return i._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: i,
        _3: /* I64Type */1,
        Error: new Error()
      };
}

var I64Num = {
  to_num: to_num$1,
  of_num: of_num$1
};

function to_num$2(i) {
  return {
          TAG: /* F32 */2,
          _0: i
        };
}

function of_num$2(n, z) {
  if (z.TAG === /* F32 */2) {
    return z._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: z,
        _3: /* F32Type */2,
        Error: new Error()
      };
}

var F32Num = {
  to_num: to_num$2,
  of_num: of_num$2
};

function to_num$3(i) {
  return {
          TAG: /* F64 */3,
          _0: i
        };
}

function of_num$3(n, z) {
  if (z.TAG === /* F64 */3) {
    return z._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: z,
        _3: /* F64Type */3,
        Error: new Error()
      };
}

var F64Num = {
  to_num: to_num$3,
  of_num: of_num$3
};

function to_vec(i) {
  return /* V128 */{
          _0: i
        };
}

function of_vec(n, z) {
  return z._0;
}

var V128Vec = {
  to_vec: to_vec,
  of_vec: of_vec
};

function type_of_num(param) {
  switch (param.TAG | 0) {
    case /* I32 */0 :
        return /* I32Type */0;
    case /* I64 */1 :
        return /* I64Type */1;
    case /* F32 */2 :
        return /* F32Type */2;
    case /* F64 */3 :
        return /* F64Type */3;
    
  }
}

function type_of_vec(param) {
  return /* V128Type */0;
}

var type_of_ref$p = {
  contents: (function (t) {
      if (t.RE_EXN_ID === NullRef) {
        return t._1;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "values.ml",
              99,
              55
            ],
            Error: new Error()
          };
    })
};

function type_of_ref(r) {
  return Curry._1(type_of_ref$p.contents, r);
}

function type_of_value(n) {
  switch (n.TAG | 0) {
    case /* Num */0 :
        return {
                TAG: /* NumType */0,
                _0: type_of_num(n._0)
              };
    case /* Vec */1 :
        return {
                TAG: /* VecType */1,
                _0: /* V128Type */0
              };
    case /* Ref */2 :
        return {
                TAG: /* RefType */2,
                _0: Curry._1(type_of_ref$p.contents, n._0)
              };
    
  }
}

var eq_num = Caml_obj.caml_equal;

var eq_vec = Caml_obj.caml_equal;

var eq_ref$p = {
  contents: (function (r1, r2) {
      if (r1.RE_EXN_ID === NullRef) {
        return r2.RE_EXN_ID === NullRef;
      } else {
        return false;
      }
    })
};

function eq_ref(r1, r2) {
  return Curry._2(eq_ref$p.contents, r1, r2);
}

function eq(v1, v2) {
  switch (v1.TAG | 0) {
    case /* Num */0 :
        switch (v2.TAG | 0) {
          case /* Num */0 :
              return Caml_obj.caml_equal(v1._0, v2._0);
          case /* Vec */1 :
          case /* Ref */2 :
              return false;
          
        }
    case /* Vec */1 :
        switch (v2.TAG | 0) {
          case /* Vec */1 :
              return Caml_obj.caml_equal(v1._0, v2._0);
          case /* Num */0 :
          case /* Ref */2 :
              return false;
          
        }
    case /* Ref */2 :
        switch (v2.TAG | 0) {
          case /* Num */0 :
          case /* Vec */1 :
              return false;
          case /* Ref */2 :
              return Curry._2(eq_ref$p.contents, v1._0, v2._0);
          
        }
    
  }
}

function default_num(param) {
  switch (param) {
    case /* I32Type */0 :
        return {
                TAG: /* I32 */0,
                _0: I32.zero
              };
    case /* I64Type */1 :
        return {
                TAG: /* I64 */1,
                _0: I64.zero
              };
    case /* F32Type */2 :
        return {
                TAG: /* F32 */2,
                _0: F32.zero
              };
    case /* F64Type */3 :
        return {
                TAG: /* F64 */3,
                _0: F64.zero
              };
    
  }
}

function default_vec(param) {
  return /* V128 */{
          _0: V128.zero
        };
}

function default_ref(t) {
  return {
          RE_EXN_ID: NullRef,
          _1: t
        };
}

function default_value(t$p) {
  switch (t$p.TAG | 0) {
    case /* NumType */0 :
        return {
                TAG: /* Num */0,
                _0: default_num(t$p._0)
              };
    case /* VecType */1 :
        return {
                TAG: /* Vec */1,
                _0: /* V128 */{
                  _0: V128.zero
                }
              };
    case /* RefType */2 :
        return {
                TAG: /* Ref */2,
                _0: {
                  RE_EXN_ID: NullRef,
                  _1: t$p._0
                }
              };
    
  }
}

function value_of_bool(b) {
  return {
          TAG: /* Num */0,
          _0: {
            TAG: /* I32 */0,
            _0: b ? 1 : 0
          }
        };
}

function string_of_num(i) {
  switch (i.TAG | 0) {
    case /* I32 */0 :
        return Curry._1(I32.to_string_s, i._0);
    case /* I64 */1 :
        return Curry._1(I64.to_string_s, i._0);
    case /* F32 */2 :
        return Curry._1(F32.to_string, i._0);
    case /* F64 */3 :
        return Curry._1(F64.to_string, i._0);
    
  }
}

function hex_string_of_num(i) {
  switch (i.TAG | 0) {
    case /* I32 */0 :
        return Curry._1(I32.to_hex_string, i._0);
    case /* I64 */1 :
        return Curry._1(I64.to_hex_string, i._0);
    case /* F32 */2 :
        return Curry._1(F32.to_hex_string, i._0);
    case /* F64 */3 :
        return Curry._1(F64.to_hex_string, i._0);
    
  }
}

function string_of_vec(v) {
  return V128.to_string(v._0);
}

function hex_string_of_vec(v) {
  return V128.to_hex_string(v._0);
}

var string_of_ref$p = {
  contents: (function (t) {
      if (t.RE_EXN_ID === NullRef) {
        return "null";
      } else {
        return "ref";
      }
    })
};

function string_of_ref(r) {
  return Curry._1(string_of_ref$p.contents, r);
}

function string_of_value(n) {
  switch (n.TAG | 0) {
    case /* Num */0 :
        return string_of_num(n._0);
    case /* Vec */1 :
        return V128.to_string(n._0._0);
    case /* Ref */2 :
        return Curry._1(string_of_ref$p.contents, n._0);
    
  }
}

function string_of_values(vs) {
  if (vs && !vs.tl) {
    return string_of_value(vs.hd);
  }
  return "[" + ($$String.concat(" ", List.map(string_of_value, vs)) + "]");
}

exports.NullRef = NullRef;
exports.as_num = as_num;
exports.as_vec = as_vec;
exports.as_ref = as_ref;
exports.$$TypeError = $$TypeError;
exports.I32Num = I32Num;
exports.I64Num = I64Num;
exports.F32Num = F32Num;
exports.F64Num = F64Num;
exports.V128Vec = V128Vec;
exports.type_of_num = type_of_num;
exports.type_of_vec = type_of_vec;
exports.type_of_ref$p = type_of_ref$p;
exports.type_of_ref = type_of_ref;
exports.type_of_value = type_of_value;
exports.eq_num = eq_num;
exports.eq_vec = eq_vec;
exports.eq_ref$p = eq_ref$p;
exports.eq_ref = eq_ref;
exports.eq = eq;
exports.default_num = default_num;
exports.default_vec = default_vec;
exports.default_ref = default_ref;
exports.default_value = default_value;
exports.value_of_bool = value_of_bool;
exports.string_of_num = string_of_num;
exports.hex_string_of_num = hex_string_of_num;
exports.string_of_vec = string_of_vec;
exports.hex_string_of_vec = hex_string_of_vec;
exports.string_of_ref$p = string_of_ref$p;
exports.string_of_ref = string_of_ref;
exports.string_of_value = string_of_value;
exports.string_of_values = string_of_values;
/* F32 Not a pure module */
