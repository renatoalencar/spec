// Generated by ReScript, PLEASE EDIT WITH CARE

import * as F32 from "../exec/f32.bs.js";
import * as F64 from "../exec/f64.bs.js";
import * as I32 from "../exec/i32.bs.js";
import * as I64 from "../exec/i64.bs.js";
import * as List from "rescript/lib/es6/list.js";
import * as V128 from "../exec/v128.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var NullRef = /* @__PURE__ */Caml_exceptions.create("Values.NullRef");

function as_num(n) {
  switch (n.TAG | 0) {
    case /* Num */0 :
        return n._0;
    case /* Vec */1 :
    case /* Ref */2 :
        return Pervasives.failwith("as_num");
    
  }
}

function as_vec(i) {
  switch (i.TAG | 0) {
    case /* Vec */1 :
        return i._0;
    case /* Num */0 :
    case /* Ref */2 :
        return Pervasives.failwith("as_vec");
    
  }
}

function as_ref(r) {
  switch (r.TAG | 0) {
    case /* Num */0 :
    case /* Vec */1 :
        return Pervasives.failwith("as_ref");
    case /* Ref */2 :
        return r._0;
    
  }
}

var $$TypeError = /* @__PURE__ */Caml_exceptions.create("Values.TypeError");

function to_num(i) {
  return {
          TAG: /* I32 */0,
          _0: i
        };
}

function of_num(n, i) {
  if (i.TAG === /* I32 */0) {
    return i._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: i,
        _3: /* I32Type */0,
        Error: new Error()
      };
}

var I32Num = {
  to_num: to_num,
  of_num: of_num
};

function to_num$1(i) {
  return {
          TAG: /* I64 */1,
          _0: i
        };
}

function of_num$1(n, i) {
  if (i.TAG === /* I64 */1) {
    return i._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: i,
        _3: /* I64Type */1,
        Error: new Error()
      };
}

var I64Num = {
  to_num: to_num$1,
  of_num: of_num$1
};

function to_num$2(i) {
  return {
          TAG: /* F32 */2,
          _0: i
        };
}

function of_num$2(n, z) {
  if (z.TAG === /* F32 */2) {
    return z._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: z,
        _3: /* F32Type */2,
        Error: new Error()
      };
}

var F32Num = {
  to_num: to_num$2,
  of_num: of_num$2
};

function to_num$3(i) {
  return {
          TAG: /* F64 */3,
          _0: i
        };
}

function of_num$3(n, z) {
  if (z.TAG === /* F64 */3) {
    return z._0;
  }
  throw {
        RE_EXN_ID: $$TypeError,
        _1: n,
        _2: z,
        _3: /* F64Type */3,
        Error: new Error()
      };
}

var F64Num = {
  to_num: to_num$3,
  of_num: of_num$3
};

function to_vec(i) {
  return /* V128 */{
          _0: i
        };
}

function of_vec(n, z) {
  return z._0;
}

var V128Vec = {
  to_vec: to_vec,
  of_vec: of_vec
};

function type_of_num(param) {
  switch (param.TAG | 0) {
    case /* I32 */0 :
        return /* I32Type */0;
    case /* I64 */1 :
        return /* I64Type */1;
    case /* F32 */2 :
        return /* F32Type */2;
    case /* F64 */3 :
        return /* F64Type */3;
    
  }
}

function type_of_vec(param) {
  return /* V128Type */0;
}

var type_of_ref$p = {
  contents: (function (t) {
      if (t.RE_EXN_ID === NullRef) {
        return t._1;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "values.ml",
              99,
              55
            ],
            Error: new Error()
          };
    })
};

function type_of_ref(r) {
  return Curry._1(type_of_ref$p.contents, r);
}

function type_of_value(n) {
  switch (n.TAG | 0) {
    case /* Num */0 :
        return {
                TAG: /* NumType */0,
                _0: type_of_num(n._0)
              };
    case /* Vec */1 :
        return {
                TAG: /* VecType */1,
                _0: /* V128Type */0
              };
    case /* Ref */2 :
        return {
                TAG: /* RefType */2,
                _0: Curry._1(type_of_ref$p.contents, n._0)
              };
    
  }
}

var eq_num = Caml_obj.caml_equal;

var eq_vec = Caml_obj.caml_equal;

var eq_ref$p = {
  contents: (function (r1, r2) {
      if (r1.RE_EXN_ID === NullRef) {
        return r2.RE_EXN_ID === NullRef;
      } else {
        return false;
      }
    })
};

function eq_ref(r1, r2) {
  return Curry._2(eq_ref$p.contents, r1, r2);
}

function eq(v1, v2) {
  switch (v1.TAG | 0) {
    case /* Num */0 :
        switch (v2.TAG | 0) {
          case /* Num */0 :
              return Caml_obj.caml_equal(v1._0, v2._0);
          case /* Vec */1 :
          case /* Ref */2 :
              return false;
          
        }
    case /* Vec */1 :
        switch (v2.TAG | 0) {
          case /* Vec */1 :
              return Caml_obj.caml_equal(v1._0, v2._0);
          case /* Num */0 :
          case /* Ref */2 :
              return false;
          
        }
    case /* Ref */2 :
        switch (v2.TAG | 0) {
          case /* Num */0 :
          case /* Vec */1 :
              return false;
          case /* Ref */2 :
              return Curry._2(eq_ref$p.contents, v1._0, v2._0);
          
        }
    
  }
}

function default_num(param) {
  switch (param) {
    case /* I32Type */0 :
        return {
                TAG: /* I32 */0,
                _0: I32.zero
              };
    case /* I64Type */1 :
        return {
                TAG: /* I64 */1,
                _0: I64.zero
              };
    case /* F32Type */2 :
        return {
                TAG: /* F32 */2,
                _0: F32.zero
              };
    case /* F64Type */3 :
        return {
                TAG: /* F64 */3,
                _0: F64.zero
              };
    
  }
}

function default_vec(param) {
  return /* V128 */{
          _0: V128.zero
        };
}

function default_ref(t) {
  return {
          RE_EXN_ID: NullRef,
          _1: t
        };
}

function default_value(t$p) {
  switch (t$p.TAG | 0) {
    case /* NumType */0 :
        return {
                TAG: /* Num */0,
                _0: default_num(t$p._0)
              };
    case /* VecType */1 :
        return {
                TAG: /* Vec */1,
                _0: /* V128 */{
                  _0: V128.zero
                }
              };
    case /* RefType */2 :
        return {
                TAG: /* Ref */2,
                _0: {
                  RE_EXN_ID: NullRef,
                  _1: t$p._0
                }
              };
    
  }
}

function value_of_bool(b) {
  return {
          TAG: /* Num */0,
          _0: {
            TAG: /* I32 */0,
            _0: b ? 1 : 0
          }
        };
}

function string_of_num(i) {
  switch (i.TAG | 0) {
    case /* I32 */0 :
        return Curry._1(I32.to_string_s, i._0);
    case /* I64 */1 :
        return Curry._1(I64.to_string_s, i._0);
    case /* F32 */2 :
        return Curry._1(F32.to_string, i._0);
    case /* F64 */3 :
        return Curry._1(F64.to_string, i._0);
    
  }
}

function hex_string_of_num(i) {
  switch (i.TAG | 0) {
    case /* I32 */0 :
        return Curry._1(I32.to_hex_string, i._0);
    case /* I64 */1 :
        return Curry._1(I64.to_hex_string, i._0);
    case /* F32 */2 :
        return Curry._1(F32.to_hex_string, i._0);
    case /* F64 */3 :
        return Curry._1(F64.to_hex_string, i._0);
    
  }
}

function string_of_vec(v) {
  return V128.to_string(v._0);
}

function hex_string_of_vec(v) {
  return V128.to_hex_string(v._0);
}

var string_of_ref$p = {
  contents: (function (t) {
      if (t.RE_EXN_ID === NullRef) {
        return "null";
      } else {
        return "ref";
      }
    })
};

function string_of_ref(r) {
  return Curry._1(string_of_ref$p.contents, r);
}

function string_of_value(n) {
  switch (n.TAG | 0) {
    case /* Num */0 :
        return string_of_num(n._0);
    case /* Vec */1 :
        return V128.to_string(n._0._0);
    case /* Ref */2 :
        return Curry._1(string_of_ref$p.contents, n._0);
    
  }
}

function string_of_values(vs) {
  if (vs && !vs.tl) {
    return string_of_value(vs.hd);
  }
  return "[" + ($$String.concat(" ", List.map(string_of_value, vs)) + "]");
}

export {
  NullRef ,
  as_num ,
  as_vec ,
  as_ref ,
  $$TypeError ,
  I32Num ,
  I64Num ,
  F32Num ,
  F64Num ,
  V128Vec ,
  type_of_num ,
  type_of_vec ,
  type_of_ref$p ,
  type_of_ref ,
  type_of_value ,
  eq_num ,
  eq_vec ,
  eq_ref$p ,
  eq_ref ,
  eq ,
  default_num ,
  default_vec ,
  default_ref ,
  default_value ,
  value_of_bool ,
  string_of_num ,
  hex_string_of_num ,
  string_of_vec ,
  hex_string_of_vec ,
  string_of_ref$p ,
  string_of_ref ,
  string_of_value ,
  string_of_values ,
  
}
/* F32 Not a pure module */
