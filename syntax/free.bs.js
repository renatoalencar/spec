// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Lib = require("../util/lib.bs.js");
var $$Set = require("rescript/lib/js/set.js");
var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var Int32 = require("rescript/lib/js/int32.js");

var $$Set$1 = $$Set.Make({
      compare: Int32.compare
    });

var empty_types = $$Set$1.empty;

var empty_globals = $$Set$1.empty;

var empty_tables = $$Set$1.empty;

var empty_memories = $$Set$1.empty;

var empty_funcs = $$Set$1.empty;

var empty_elems = $$Set$1.empty;

var empty_datas = $$Set$1.empty;

var empty_locals = $$Set$1.empty;

var empty_labels = $$Set$1.empty;

var empty = {
  types: empty_types,
  globals: empty_globals,
  tables: empty_tables,
  memories: empty_memories,
  funcs: empty_funcs,
  elems: empty_elems,
  datas: empty_datas,
  locals: empty_locals,
  labels: empty_labels
};

function union(s1, s2) {
  return {
          types: Curry._2($$Set$1.union, s1.types, s2.types),
          globals: Curry._2($$Set$1.union, s1.globals, s2.globals),
          tables: Curry._2($$Set$1.union, s1.tables, s2.tables),
          memories: Curry._2($$Set$1.union, s1.memories, s2.memories),
          funcs: Curry._2($$Set$1.union, s1.funcs, s2.funcs),
          elems: Curry._2($$Set$1.union, s1.elems, s2.elems),
          datas: Curry._2($$Set$1.union, s1.datas, s2.datas),
          locals: Curry._2($$Set$1.union, s1.locals, s2.locals),
          labels: Curry._2($$Set$1.union, s1.labels, s2.labels)
        };
}

function types(s) {
  return {
          types: s,
          globals: $$Set$1.empty,
          tables: $$Set$1.empty,
          memories: $$Set$1.empty,
          funcs: $$Set$1.empty,
          elems: $$Set$1.empty,
          datas: $$Set$1.empty,
          locals: $$Set$1.empty,
          labels: $$Set$1.empty
        };
}

function globals(s) {
  return {
          types: $$Set$1.empty,
          globals: s,
          tables: $$Set$1.empty,
          memories: $$Set$1.empty,
          funcs: $$Set$1.empty,
          elems: $$Set$1.empty,
          datas: $$Set$1.empty,
          locals: $$Set$1.empty,
          labels: $$Set$1.empty
        };
}

function tables(s) {
  return {
          types: $$Set$1.empty,
          globals: $$Set$1.empty,
          tables: s,
          memories: $$Set$1.empty,
          funcs: $$Set$1.empty,
          elems: $$Set$1.empty,
          datas: $$Set$1.empty,
          locals: $$Set$1.empty,
          labels: $$Set$1.empty
        };
}

function memories(s) {
  return {
          types: $$Set$1.empty,
          globals: $$Set$1.empty,
          tables: $$Set$1.empty,
          memories: s,
          funcs: $$Set$1.empty,
          elems: $$Set$1.empty,
          datas: $$Set$1.empty,
          locals: $$Set$1.empty,
          labels: $$Set$1.empty
        };
}

function funcs(s) {
  return {
          types: $$Set$1.empty,
          globals: $$Set$1.empty,
          tables: $$Set$1.empty,
          memories: $$Set$1.empty,
          funcs: s,
          elems: $$Set$1.empty,
          datas: $$Set$1.empty,
          locals: $$Set$1.empty,
          labels: $$Set$1.empty
        };
}

function elems(s) {
  return {
          types: $$Set$1.empty,
          globals: $$Set$1.empty,
          tables: $$Set$1.empty,
          memories: $$Set$1.empty,
          funcs: $$Set$1.empty,
          elems: s,
          datas: $$Set$1.empty,
          locals: $$Set$1.empty,
          labels: $$Set$1.empty
        };
}

function datas(s) {
  return {
          types: $$Set$1.empty,
          globals: $$Set$1.empty,
          tables: $$Set$1.empty,
          memories: $$Set$1.empty,
          funcs: $$Set$1.empty,
          elems: $$Set$1.empty,
          datas: s,
          locals: $$Set$1.empty,
          labels: $$Set$1.empty
        };
}

function labels(s) {
  return {
          types: $$Set$1.empty,
          globals: $$Set$1.empty,
          tables: $$Set$1.empty,
          memories: $$Set$1.empty,
          funcs: $$Set$1.empty,
          elems: $$Set$1.empty,
          datas: $$Set$1.empty,
          locals: $$Set$1.empty,
          labels: s
        };
}

var zero = Curry._1($$Set$1.singleton, 0);

function shift(s) {
  return Curry._2($$Set$1.map, (function (param) {
                return -1 + param | 0;
              }), Curry._2($$Set$1.remove, 0, s));
}

function list(free, xs) {
  return List.fold_left(union, empty, List.map(free, xs));
}

function opt(free, xo) {
  return Lib.$$Option.get(Lib.$$Option.map(free, xo), empty);
}

function block_type(x) {
  if (x.TAG === /* VarBlockType */0) {
    return types(Curry._1($$Set$1.singleton, x._0.it));
  } else {
    return empty;
  }
}

function instr(e) {
  var x = e.it;
  var exit = 0;
  if (typeof x === "number") {
    switch (x) {
      case /* MemorySize */4 :
      case /* MemoryGrow */5 :
      case /* MemoryFill */6 :
      case /* MemoryCopy */7 :
          return memories(zero);
      case /* Unreachable */0 :
      case /* Nop */1 :
      case /* Drop */2 :
      case /* Return */3 :
      case /* RefIsNull */8 :
          return empty;
      
    }
  } else {
    switch (x.TAG | 0) {
      case /* Block */1 :
      case /* Loop */2 :
          exit = 1;
          break;
      case /* If */3 :
          return union(union(block_type(x._0), block(x._1)), block(x._2));
      case /* Br */4 :
      case /* BrIf */5 :
          return labels(Curry._1($$Set$1.singleton, x._0.it));
      case /* BrTable */6 :
          return list((function (x) {
                        return labels(Curry._1($$Set$1.singleton, x.it));
                      }), {
                      hd: x._1,
                      tl: x._0
                    });
      case /* CallIndirect */8 :
          return union(tables(Curry._1($$Set$1.singleton, x._0.it)), types(Curry._1($$Set$1.singleton, x._1.it)));
      case /* LocalGet */9 :
      case /* LocalSet */10 :
      case /* LocalTee */11 :
          exit = 2;
          break;
      case /* GlobalGet */12 :
      case /* GlobalSet */13 :
          return globals(Curry._1($$Set$1.singleton, x._0.it));
      case /* TableGet */14 :
      case /* TableSet */15 :
      case /* TableSize */16 :
      case /* TableGrow */17 :
      case /* TableFill */18 :
          exit = 3;
          break;
      case /* TableCopy */19 :
          return union(tables(Curry._1($$Set$1.singleton, x._0.it)), tables(Curry._1($$Set$1.singleton, x._1.it)));
      case /* TableInit */20 :
          return union(tables(Curry._1($$Set$1.singleton, x._0.it)), elems(Curry._1($$Set$1.singleton, x._1.it)));
      case /* ElemDrop */21 :
          return elems(Curry._1($$Set$1.singleton, x._0.it));
      case /* Load */22 :
      case /* Store */23 :
      case /* VecLoad */24 :
      case /* VecStore */25 :
      case /* VecLoadLane */26 :
      case /* VecStoreLane */27 :
          return memories(zero);
      case /* MemoryInit */28 :
          return union(memories(zero), datas(Curry._1($$Set$1.singleton, x._0.it)));
      case /* DataDrop */29 :
          return datas(Curry._1($$Set$1.singleton, x._0.it));
      case /* Call */7 :
      case /* RefFunc */31 :
          return funcs(Curry._1($$Set$1.singleton, x._0.it));
      case /* Select */0 :
      case /* RefNull */30 :
      case /* Const */32 :
      case /* Test */33 :
      case /* Compare */34 :
      case /* Unary */35 :
      case /* Binary */36 :
      case /* Convert */37 :
          return empty;
      default:
        return memories(zero);
    }
  }
  switch (exit) {
    case 1 :
        return union(block_type(x._0), block(x._1));
    case 2 :
        var s = Curry._1($$Set$1.singleton, x._0.it);
        return {
                types: $$Set$1.empty,
                globals: $$Set$1.empty,
                tables: $$Set$1.empty,
                memories: $$Set$1.empty,
                funcs: $$Set$1.empty,
                elems: $$Set$1.empty,
                datas: $$Set$1.empty,
                locals: s,
                labels: $$Set$1.empty
              };
    case 3 :
        return tables(Curry._1($$Set$1.singleton, x._0.it));
    
  }
}

function block(es) {
  var free = list(instr, es);
  return {
          types: free.types,
          globals: free.globals,
          tables: free.tables,
          memories: free.memories,
          funcs: free.funcs,
          elems: free.elems,
          datas: free.datas,
          locals: free.locals,
          labels: shift(free.labels)
        };
}

function $$const(c) {
  return block(c.it);
}

function $$global(g) {
  return block(g.it.ginit.it);
}

function func(f) {
  var init = block(f.it.body);
  return {
          types: init.types,
          globals: init.globals,
          tables: init.tables,
          memories: init.memories,
          funcs: init.funcs,
          elems: init.elems,
          datas: init.datas,
          locals: $$Set$1.empty,
          labels: init.labels
        };
}

function table(t) {
  return empty;
}

function memory(m) {
  return empty;
}

function segment_mode(f, m) {
  var match = m.it;
  if (typeof match === "number") {
    return empty;
  } else {
    return union(Curry._1(f, Curry._1($$Set$1.singleton, match.index.it)), block(match.offset.it));
  }
}

function elem(s) {
  return union(list($$const, s.it.einit), segment_mode(tables, s.it.emode));
}

function data(s) {
  return segment_mode(memories, s.it.dmode);
}

function type_(t) {
  return empty;
}

function $$export(e) {
  var d = e.it.edesc;
  var x = d.it;
  switch (x.TAG | 0) {
    case /* FuncExport */0 :
        return funcs(Curry._1($$Set$1.singleton, x._0.it));
    case /* TableExport */1 :
        return tables(Curry._1($$Set$1.singleton, x._0.it));
    case /* MemoryExport */2 :
        return memories(Curry._1($$Set$1.singleton, x._0.it));
    case /* GlobalExport */3 :
        return globals(Curry._1($$Set$1.singleton, x._0.it));
    
  }
}

function $$import(i) {
  var d = i.it.idesc;
  var x = d.it;
  if (x.TAG === /* FuncImport */0) {
    return types(Curry._1($$Set$1.singleton, x._0.it));
  } else {
    return empty;
  }
}

function start(s) {
  return funcs(Curry._1($$Set$1.singleton, s.it.sfunc.it));
}

function module_(m) {
  return union(union(union(union(union(union(union(union(union(list(type_, m.it.types), list($$global, m.it.globals)), list(table, m.it.tables)), list(memory, m.it.memories)), list(func, m.it.funcs)), opt(start, m.it.start)), list(elem, m.it.elems)), list(data, m.it.datas)), list($$import, m.it.imports)), list($$export, m.it.exports));
}

exports.$$Set = $$Set$1;
exports.empty = empty;
exports.union = union;
exports.instr = instr;
exports.block = block;
exports.$$const = $$const;
exports.type_ = type_;
exports.$$global = $$global;
exports.func = func;
exports.table = table;
exports.memory = memory;
exports.elem = elem;
exports.data = data;
exports.$$export = $$export;
exports.$$import = $$import;
exports.start = start;
exports.module_ = module_;
exports.list = list;
/* Set Not a pure module */
