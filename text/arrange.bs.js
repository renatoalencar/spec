// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var I8 = require("../exec/i8.bs.js");
var I16 = require("../exec/i16.bs.js");
var I32 = require("../exec/i32.bs.js");
var Lib = require("../util/lib.bs.js");
var Char = require("rescript/lib/js/char.js");
var List = require("rescript/lib/js/list.js");
var V128 = require("../exec/v128.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Parse = require("./parse.bs.js");
var Types = require("../syntax/types.bs.js");
var $$Buffer = require("rescript/lib/js/buffer.js");
var Decode = require("../binary/decode.bs.js");
var Encode = require("../binary/encode.bs.js");
var Printf = require("rescript/lib/js/printf.js");
var Script = require("../script/script.bs.js");
var Source = require("../util/source.bs.js");
var $$String = require("rescript/lib/js/string.js");
var Values = require("../syntax/values.bs.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function nat(n) {
  return Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, n));
}

function add_hex_char(buf, c) {
  return Curry._1(Printf.bprintf(buf, /* Format */{
                  _0: {
                    TAG: /* Char_literal */12,
                    _0: /* '\\' */92,
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_x */6,
                      _1: {
                        TAG: /* Lit_padding */0,
                        _0: /* Zeros */2,
                        _1: 2
                      },
                      _2: /* No_precision */0,
                      _3: /* End_of_format */0
                    }
                  },
                  _1: "\\%02x"
                }), c);
}

function add_char(buf, c) {
  if (c >= 34) {
    if (c === 92) {
      return $$Buffer.add_string(buf, "\\\\");
    }
    if (c < 35) {
      return $$Buffer.add_string(buf, "\\\"");
    }
    
  } else {
    if (c === 9) {
      return $$Buffer.add_string(buf, "\\t");
    }
    if (c === 10) {
      return $$Buffer.add_string(buf, "\\n");
    }
    
  }
  if (/* ' ' */32 <= c && c < /* '\127' */127) {
    return $$Buffer.add_char(buf, c);
  } else {
    return add_hex_char(buf, c);
  }
}

function add_unicode_char(buf, uc) {
  if (!(uc === 10 || uc === 9) && !(32 <= uc && uc < 127)) {
    return Curry._1(Printf.bprintf(buf, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "\\u{",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_x */6,
                        _1: {
                          TAG: /* Lit_padding */0,
                          _0: /* Zeros */2,
                          _1: 2
                        },
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '}' */125,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "\\u{%02x}"
                  }), uc);
  } else {
    return add_char(buf, Char.chr(uc));
  }
}

function string_with(iter, add_char, s) {
  var buf = $$Buffer.create(256);
  $$Buffer.add_char(buf, /* '"' */34);
  Curry._2(iter, Curry._1(add_char, buf), s);
  $$Buffer.add_char(buf, /* '"' */34);
  return $$Buffer.contents(buf);
}

function list_of_opt(x) {
  if (x !== undefined) {
    return {
            hd: Caml_option.valFromOption(x),
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function break_bytes(s) {
  var ss = Lib.$$String.breakup(s, 16);
  return List.map((function (param) {
                return {
                        TAG: /* Atom */0,
                        _0: string_with($$String.iter, add_hex_char, param)
                      };
              }), ss);
}

function break_string(s) {
  var match = Lib.List.split_last(Lib.$$String.split(s, /* '\n' */10));
  return List.map((function (param) {
                return {
                        TAG: /* Atom */0,
                        _0: string_with($$String.iter, add_char, param)
                      };
              }), Pervasives.$at(List.map((function (s) {
                        return s + "\n";
                      }), match[0]), {
                  hd: match[1],
                  tl: /* [] */0
                }));
}

var num_type = Types.string_of_num_type;

var vec_type = Types.string_of_vec_type;

function decls(kind, ts) {
  var f = function (param) {
    return {
            TAG: /* Atom */0,
            _0: Types.string_of_value_type(param)
          };
  };
  if (ts === /* [] */0) {
    return /* [] */0;
  } else {
    return {
            hd: {
              TAG: /* Node */1,
              _0: kind,
              _1: List.map(f, ts)
            },
            tl: /* [] */0
          };
  }
}

function func_type(param) {
  return {
          TAG: /* Node */1,
          _0: "func",
          _1: Pervasives.$at(decls("param", param._0), decls("result", param._1))
        };
}

function limits(nat, param) {
  return $$String.concat(" ", {
              hd: Curry._1(nat, param.min),
              tl: List.map(nat, list_of_opt(param.max))
            });
}

function global_type(param) {
  var t = param._0;
  if (param._1) {
    return {
            TAG: /* Node */1,
            _0: "mut",
            _1: {
              hd: {
                TAG: /* Atom */0,
                _0: Types.string_of_value_type(t)
              },
              tl: /* [] */0
            }
          };
  } else {
    return {
            TAG: /* Atom */0,
            _0: Types.string_of_value_type(t)
          };
  }
}

function pack_size(param) {
  switch (param) {
    case /* Pack8 */0 :
        return "8";
    case /* Pack16 */1 :
        return "16";
    case /* Pack32 */2 :
        return "32";
    case /* Pack64 */3 :
        return "64";
    
  }
}

function pack_shape(param) {
  switch (param) {
    case /* Pack8x8 */0 :
        return "8x8";
    case /* Pack16x4 */1 :
        return "16x4";
    case /* Pack32x2 */2 :
        return "32x2";
    
  }
}

function vec_extension(sz, param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return pack_size(sz) + "_zero";
    } else {
      return pack_size(sz) + "_splat";
    }
  } else {
    return pack_shape(param._0) + (
            param._1 ? "_u" : "_s"
          );
  }
}

function testop(xx, param) {
  return "eqz";
}

function relop(xx, param) {
  switch (param) {
    case /* Eq */0 :
        return "eq";
    case /* Ne */1 :
        return "ne";
    case /* LtS */2 :
        return "lt_s";
    case /* LtU */3 :
        return "lt_u";
    case /* GtS */4 :
        return "gt_s";
    case /* GtU */5 :
        return "gt_u";
    case /* LeS */6 :
        return "le_s";
    case /* LeU */7 :
        return "le_u";
    case /* GeS */8 :
        return "ge_s";
    case /* GeU */9 :
        return "ge_u";
    
  }
}

function unop(xx, sz) {
  if (typeof sz !== "number") {
    return "extend" + (pack_size(sz._0) + "_s");
  }
  switch (sz) {
    case /* Clz */0 :
        return "clz";
    case /* Ctz */1 :
        return "ctz";
    case /* Popcnt */2 :
        return "popcnt";
    
  }
}

function binop(xx, param) {
  switch (param) {
    case /* Add */0 :
        return "add";
    case /* Sub */1 :
        return "sub";
    case /* Mul */2 :
        return "mul";
    case /* DivS */3 :
        return "div_s";
    case /* DivU */4 :
        return "div_u";
    case /* RemS */5 :
        return "rem_s";
    case /* RemU */6 :
        return "rem_u";
    case /* And */7 :
        return "and";
    case /* Or */8 :
        return "or";
    case /* Xor */9 :
        return "xor";
    case /* Shl */10 :
        return "shl";
    case /* ShrS */11 :
        return "shr_s";
    case /* ShrU */12 :
        return "shr_u";
    case /* Rotl */13 :
        return "rotl";
    case /* Rotr */14 :
        return "rotr";
    
  }
}

function cvtop(xx, param) {
  switch (param) {
    case /* ExtendSI32 */0 :
        return "extend_i32_s";
    case /* ExtendUI32 */1 :
        return "extend_i32_u";
    case /* WrapI64 */2 :
        return "wrap_i64";
    case /* TruncSF32 */3 :
        return "trunc_f32_s";
    case /* TruncUF32 */4 :
        return "trunc_f32_u";
    case /* TruncSF64 */5 :
        return "trunc_f64_s";
    case /* TruncUF64 */6 :
        return "trunc_f64_u";
    case /* TruncSatSF32 */7 :
        return "trunc_sat_f32_s";
    case /* TruncSatUF32 */8 :
        return "trunc_sat_f32_u";
    case /* TruncSatSF64 */9 :
        return "trunc_sat_f64_s";
    case /* TruncSatUF64 */10 :
        return "trunc_sat_f64_u";
    case /* ReinterpretFloat */11 :
        return "reinterpret_f" + xx;
    
  }
}

function testop$1(xx, param) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "arrange.ml",
          162,
          43
        ],
        Error: new Error()
      };
}

function relop$1(xx, param) {
  switch (param) {
    case /* Eq */0 :
        return "eq";
    case /* Ne */1 :
        return "ne";
    case /* Lt */2 :
        return "lt";
    case /* Gt */3 :
        return "gt";
    case /* Le */4 :
        return "le";
    case /* Ge */5 :
        return "ge";
    
  }
}

function unop$1(xx, param) {
  switch (param) {
    case /* Neg */0 :
        return "neg";
    case /* Abs */1 :
        return "abs";
    case /* Ceil */2 :
        return "ceil";
    case /* Floor */3 :
        return "floor";
    case /* Trunc */4 :
        return "trunc";
    case /* Nearest */5 :
        return "nearest";
    case /* Sqrt */6 :
        return "sqrt";
    
  }
}

function binop$1(xx, param) {
  switch (param) {
    case /* Add */0 :
        return "add";
    case /* Sub */1 :
        return "sub";
    case /* Mul */2 :
        return "mul";
    case /* Div */3 :
        return "div";
    case /* Min */4 :
        return "min";
    case /* Max */5 :
        return "max";
    case /* CopySign */6 :
        return "copysign";
    
  }
}

function cvtop$1(xx, param) {
  switch (param) {
    case /* ConvertSI32 */0 :
        return "convert_i32_s";
    case /* ConvertUI32 */1 :
        return "convert_i32_u";
    case /* ConvertSI64 */2 :
        return "convert_i64_s";
    case /* ConvertUI64 */3 :
        return "convert_i64_u";
    case /* PromoteF32 */4 :
        return "promote_f32";
    case /* DemoteF64 */5 :
        return "demote_f64";
    case /* ReinterpretInt */6 :
        return "reinterpret_i" + xx;
    
  }
}

function half(param) {
  switch (param) {
    case "16x8" :
        return "8x16";
    case "32x4" :
        return "16x8";
    case "64x2" :
        return "32x4";
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "arrange.ml",
              208,
              11
            ],
            Error: new Error()
          };
  }
}

function $$double(param) {
  switch (param) {
    case "16x8" :
        return "32x4";
    case "32x4" :
        return "64x2";
    case "8x16" :
        return "16x8";
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "arrange.ml",
              214,
              11
            ],
            Error: new Error()
          };
  }
}

function voidop(xxxx, param) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "arrange.ml",
          216,
          43
        ],
        Error: new Error()
      };
}

function itestop(xxxx, op) {
  return "all_true";
}

function iunop(xxxx, op) {
  switch (op) {
    case /* Abs */0 :
        return "abs";
    case /* Neg */1 :
        return "neg";
    case /* Popcnt */2 :
        return "popcnt";
    
  }
}

function funop(xxxx, op) {
  switch (op) {
    case /* Abs */0 :
        return "abs";
    case /* Neg */1 :
        return "neg";
    case /* Sqrt */2 :
        return "sqrt";
    case /* Ceil */3 :
        return "ceil";
    case /* Floor */4 :
        return "floor";
    case /* Trunc */5 :
        return "trunc";
    case /* Nearest */6 :
        return "nearest";
    
  }
}

function ibinop(xxxx, op) {
  if (typeof op !== "number") {
    return "shuffle " + $$String.concat(" ", List.map(nat, op._0));
  }
  switch (op) {
    case /* Add */0 :
        return "add";
    case /* Sub */1 :
        return "sub";
    case /* Mul */2 :
        return "mul";
    case /* MinS */3 :
        return "min_s";
    case /* MinU */4 :
        return "min_u";
    case /* MaxS */5 :
        return "max_s";
    case /* MaxU */6 :
        return "max_u";
    case /* AvgrU */7 :
        return "avgr_u";
    case /* AddSatS */8 :
        return "add_sat_s";
    case /* AddSatU */9 :
        return "add_sat_u";
    case /* SubSatS */10 :
        return "sub_sat_s";
    case /* SubSatU */11 :
        return "sub_sat_u";
    case /* DotS */12 :
        return "dot_i" + (half(xxxx) + "_s");
    case /* Q15MulRSatS */13 :
        return "q15mulr_sat_s";
    case /* ExtMulLowS */14 :
        return "extmul_low_i" + (half(xxxx) + "_s");
    case /* ExtMulHighS */15 :
        return "extmul_high_i" + (half(xxxx) + "_s");
    case /* ExtMulLowU */16 :
        return "extmul_low_i" + (half(xxxx) + "_u");
    case /* ExtMulHighU */17 :
        return "extmul_high_i" + (half(xxxx) + "_u");
    case /* Swizzle */18 :
        return "swizzle";
    case /* NarrowS */19 :
        return "narrow_i" + ($$double(xxxx) + "_s");
    case /* NarrowU */20 :
        return "narrow_i" + ($$double(xxxx) + "_u");
    
  }
}

function fbinop(xxxx, op) {
  switch (op) {
    case /* Add */0 :
        return "add";
    case /* Sub */1 :
        return "sub";
    case /* Mul */2 :
        return "mul";
    case /* Div */3 :
        return "div";
    case /* Min */4 :
        return "min";
    case /* Max */5 :
        return "max";
    case /* Pmin */6 :
        return "pmin";
    case /* Pmax */7 :
        return "pmax";
    
  }
}

function irelop(xxxx, op) {
  switch (op) {
    case /* Eq */0 :
        return "eq";
    case /* Ne */1 :
        return "ne";
    case /* LtS */2 :
        return "lt_s";
    case /* LtU */3 :
        return "lt_u";
    case /* LeS */4 :
        return "le_s";
    case /* LeU */5 :
        return "le_u";
    case /* GtS */6 :
        return "gt_s";
    case /* GtU */7 :
        return "gt_u";
    case /* GeS */8 :
        return "ge_s";
    case /* GeU */9 :
        return "ge_u";
    
  }
}

function frelop(xxxx, op) {
  switch (op) {
    case /* Eq */0 :
        return "eq";
    case /* Ne */1 :
        return "ne";
    case /* Lt */2 :
        return "lt";
    case /* Le */3 :
        return "le";
    case /* Gt */4 :
        return "gt";
    case /* Ge */5 :
        return "ge";
    
  }
}

function icvtop(xxxx, op) {
  switch (op) {
    case /* ExtendLowS */0 :
        return "extend_low_i" + (half(xxxx) + "_s");
    case /* ExtendLowU */1 :
        return "extend_low_i" + (half(xxxx) + "_u");
    case /* ExtendHighS */2 :
        return "extend_high_i" + (half(xxxx) + "_s");
    case /* ExtendHighU */3 :
        return "extend_high_i" + (half(xxxx) + "_u");
    case /* ExtAddPairwiseS */4 :
        return "extadd_pairwise_i" + (half(xxxx) + "_s");
    case /* ExtAddPairwiseU */5 :
        return "extadd_pairwise_i" + (half(xxxx) + "_u");
    case /* TruncSatSF32x4 */6 :
        return "trunc_sat_f32x4_s";
    case /* TruncSatUF32x4 */7 :
        return "trunc_sat_f32x4_u";
    case /* TruncSatSZeroF64x2 */8 :
        return "trunc_sat_f64x2_s_zero";
    case /* TruncSatUZeroF64x2 */9 :
        return "trunc_sat_f64x2_u_zero";
    
  }
}

function fcvtop(xxxx, op) {
  switch (op) {
    case /* DemoteZeroF64x2 */0 :
        return "demote_f64x2_zero";
    case /* PromoteLowF32x4 */1 :
        return "promote_low_f32x4";
    case /* ConvertSI32x4 */2 :
        return "convert_" + ((
                  xxxx === "32x4" ? "" : "low_"
                ) + "i32x4_s");
    case /* ConvertUI32x4 */3 :
        return "convert_" + ((
                  xxxx === "32x4" ? "" : "low_"
                ) + "i32x4_u");
    
  }
}

function ishiftop(xxxx, op) {
  switch (op) {
    case /* Shl */0 :
        return "shl";
    case /* ShrS */1 :
        return "shr_s";
    case /* ShrU */2 :
        return "shr_u";
    
  }
}

function ibitmaskop(xxxx, op) {
  return "bitmask";
}

function vtestop(op) {
  return "any_true";
}

function vunop(op) {
  return "not";
}

function vbinop(op) {
  switch (op) {
    case /* And */0 :
        return "and";
    case /* Or */1 :
        return "or";
    case /* Xor */2 :
        return "xor";
    case /* AndNot */3 :
        return "andnot";
    
  }
}

function vternop(op) {
  return "bitselect";
}

function splatop(xxxx, op) {
  return "splat";
}

function pextractop(xxxx, op) {
  return "extract_lane" + ((
            op._1 ? "_u" : "_s"
          ) + (" " + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, op._0))));
}

function extractop(xxxx, op) {
  return "extract_lane " + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, op._0));
}

function replaceop(xxxx, op) {
  return "replace_lane " + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, op._0));
}

function lane_oper(param, op) {
  var fop = param[2];
  var iop = param[1];
  var pop = param[0];
  switch (op.TAG | 0) {
    case /* I8x16 */0 :
        return Curry._2(pop, "8x16", op._0);
    case /* I16x8 */1 :
        return Curry._2(pop, "16x8", op._0);
    case /* I32x4 */2 :
        return Curry._2(iop, "32x4", op._0);
    case /* I64x2 */3 :
        return Curry._2(iop, "64x2", op._0);
    case /* F32x4 */4 :
        return Curry._2(fop, "32x4", op._0);
    case /* F64x2 */5 :
        return Curry._2(fop, "64x2", op._0);
    
  }
}

function oper(param, op) {
  var fop = param[1];
  var iop = param[0];
  var tmp;
  switch (op.TAG | 0) {
    case /* I32 */0 :
        tmp = Curry._2(iop, "32", op._0);
        break;
    case /* I64 */1 :
        tmp = Curry._2(iop, "64", op._0);
        break;
    case /* F32 */2 :
        tmp = Curry._2(fop, "32", op._0);
        break;
    case /* F64 */3 :
        tmp = Curry._2(fop, "64", op._0);
        break;
    
  }
  return Types.string_of_num_type(Values.type_of_num(op)) + ("." + tmp);
}

function vec_oper(vop, op) {
  return "v128." + Curry._1(vop, op._0);
}

function vec_shape_oper(param, op) {
  var o = op._0;
  return V128.string_of_shape(o) + ("." + lane_oper([
                param[0],
                param[1],
                param[2]
              ], o));
}

var partial_arg = [
  unop,
  unop$1
];

function unop$2(param) {
  return oper(partial_arg, param);
}

var partial_arg$1 = [
  binop,
  binop$1
];

function binop$2(param) {
  return oper(partial_arg$1, param);
}

var partial_arg$2 = [
  testop,
  testop$1
];

function testop$2(param) {
  return oper(partial_arg$2, param);
}

var partial_arg$3 = [
  relop,
  relop$1
];

function relop$2(param) {
  return oper(partial_arg$3, param);
}

var partial_arg$4 = [
  cvtop,
  cvtop$1
];

function cvtop$2(param) {
  return oper(partial_arg$4, param);
}

var partial_arg$5 = [
  iunop,
  iunop,
  funop
];

function vec_unop(param) {
  return vec_shape_oper(partial_arg$5, param);
}

var partial_arg$6 = [
  ibinop,
  ibinop,
  fbinop
];

function vec_binop(param) {
  return vec_shape_oper(partial_arg$6, param);
}

var partial_arg$7 = [
  itestop,
  itestop,
  voidop
];

function vec_testop(param) {
  return vec_shape_oper(partial_arg$7, param);
}

var partial_arg$8 = [
  irelop,
  irelop,
  frelop
];

function vec_relop(param) {
  return vec_shape_oper(partial_arg$8, param);
}

var partial_arg$9 = [
  icvtop,
  icvtop,
  fcvtop
];

function vec_cvtop(param) {
  return vec_shape_oper(partial_arg$9, param);
}

var partial_arg$10 = [
  ishiftop,
  ishiftop,
  voidop
];

function vec_shiftop(param) {
  return vec_shape_oper(partial_arg$10, param);
}

var partial_arg$11 = [
  ibitmaskop,
  ibitmaskop,
  voidop
];

function vec_bitmaskop(param) {
  return vec_shape_oper(partial_arg$11, param);
}

var partial_arg$12 = [
  splatop,
  splatop,
  splatop
];

function vec_splatop(param) {
  return vec_shape_oper(partial_arg$12, param);
}

var partial_arg$13 = [
  pextractop,
  extractop,
  extractop
];

function vec_extractop(param) {
  return vec_shape_oper(partial_arg$13, param);
}

var partial_arg$14 = [
  replaceop,
  replaceop,
  replaceop
];

function vec_replaceop(param) {
  return vec_shape_oper(partial_arg$14, param);
}

function memop(name, typ, param, sz) {
  var offset = param.offset;
  var align = param.align;
  return Curry._1(typ, param.ty) + ("." + (name + ((
                offset === 0 ? "" : " offset=" + Curry._1(I32.to_string_u, offset)
              ) + (
                (1 << align) === sz ? "" : " align=" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, (1 << align)))
              ))));
}

function loadop(op) {
  var match = op.pack;
  if (match === undefined) {
    return memop("load", num_type, op, Types.num_size(op.ty));
  }
  var sz = match[0];
  return memop("load" + (pack_size(sz) + (
                match[1] ? "_u" : "_s"
              )), num_type, op, Types.packed_size(sz));
}

function storeop(op) {
  var sz = op.pack;
  if (sz !== undefined) {
    return memop("store" + pack_size(sz), num_type, op, Types.packed_size(sz));
  } else {
    return memop("store", num_type, op, Types.num_size(op.ty));
  }
}

function vec_loadop(op) {
  var match = op.pack;
  if (match === undefined) {
    return memop("load", vec_type, op, Types.vec_size(op.ty));
  }
  var sz = match[0];
  return memop("load" + vec_extension(sz, match[1]), vec_type, op, Types.packed_size(sz));
}

function vec_storeop(op) {
  return memop("store", vec_type, op, Types.vec_size(op.ty));
}

function vec_laneop(instr, param) {
  var op = param[0];
  return memop(instr + (pack_size(op.pack) + "_lane"), vec_type, op, Types.packed_size(op.pack)) + (" " + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, param[1])));
}

function $$var(x) {
  return Curry._1(I32.to_string_u, x.it);
}

function constop(v) {
  return Types.string_of_num_type(Values.type_of_num(v)) + ".const";
}

function vec_constop(v) {
  return Types.string_of_vec_type(Values.type_of_vec(v)) + ".const i32x4";
}

function block_type(x) {
  if (x.TAG === /* VarBlockType */0) {
    return {
            hd: {
              TAG: /* Node */1,
              _0: "type " + Curry._1(I32.to_string_u, x._0.it),
              _1: /* [] */0
            },
            tl: /* [] */0
          };
  } else {
    return decls("result", list_of_opt(x._0));
  }
}

function instr(e) {
  var x = e.it;
  var match;
  if (typeof x === "number") {
    switch (x) {
      case /* Unreachable */0 :
          match = [
            "unreachable",
            /* [] */0
          ];
          break;
      case /* Nop */1 :
          match = [
            "nop",
            /* [] */0
          ];
          break;
      case /* Drop */2 :
          match = [
            "drop",
            /* [] */0
          ];
          break;
      case /* Return */3 :
          match = [
            "return",
            /* [] */0
          ];
          break;
      case /* MemorySize */4 :
          match = [
            "memory.size",
            /* [] */0
          ];
          break;
      case /* MemoryGrow */5 :
          match = [
            "memory.grow",
            /* [] */0
          ];
          break;
      case /* MemoryFill */6 :
          match = [
            "memory.fill",
            /* [] */0
          ];
          break;
      case /* MemoryCopy */7 :
          match = [
            "memory.copy",
            /* [] */0
          ];
          break;
      case /* RefIsNull */8 :
          match = [
            "ref.is_null",
            /* [] */0
          ];
          break;
      
    }
  } else {
    switch (x.TAG | 0) {
      case /* Select */0 :
          var ts = x._0;
          match = ts !== undefined ? (
              ts ? [
                  "select",
                  decls("result", ts)
                ] : [
                  "select",
                  {
                    hd: {
                      TAG: /* Node */1,
                      _0: "result",
                      _1: /* [] */0
                    },
                    tl: /* [] */0
                  }
                ]
            ) : [
              "select",
              /* [] */0
            ];
          break;
      case /* Block */1 :
          match = [
            "block",
            Pervasives.$at(block_type(x._0), List.map(instr, x._1))
          ];
          break;
      case /* Loop */2 :
          match = [
            "loop",
            Pervasives.$at(block_type(x._0), List.map(instr, x._1))
          ];
          break;
      case /* If */3 :
          match = [
            "if",
            Pervasives.$at(block_type(x._0), {
                  hd: {
                    TAG: /* Node */1,
                    _0: "then",
                    _1: List.map(instr, x._1)
                  },
                  tl: {
                    hd: {
                      TAG: /* Node */1,
                      _0: "else",
                      _1: List.map(instr, x._2)
                    },
                    tl: /* [] */0
                  }
                })
          ];
          break;
      case /* Br */4 :
          match = [
            "br " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* BrIf */5 :
          match = [
            "br_if " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* BrTable */6 :
          match = [
            "br_table " + $$String.concat(" ", List.map($$var, Pervasives.$at(x._0, {
                          hd: x._1,
                          tl: /* [] */0
                        }))),
            /* [] */0
          ];
          break;
      case /* Call */7 :
          match = [
            "call " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* CallIndirect */8 :
          match = [
            "call_indirect " + Curry._1(I32.to_string_u, x._0.it),
            {
              hd: {
                TAG: /* Node */1,
                _0: "type " + Curry._1(I32.to_string_u, x._1.it),
                _1: /* [] */0
              },
              tl: /* [] */0
            }
          ];
          break;
      case /* LocalGet */9 :
          match = [
            "local.get " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* LocalSet */10 :
          match = [
            "local.set " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* LocalTee */11 :
          match = [
            "local.tee " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* GlobalGet */12 :
          match = [
            "global.get " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* GlobalSet */13 :
          match = [
            "global.set " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* TableGet */14 :
          match = [
            "table.get " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* TableSet */15 :
          match = [
            "table.set " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* TableSize */16 :
          match = [
            "table.size " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* TableGrow */17 :
          match = [
            "table.grow " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* TableFill */18 :
          match = [
            "table.fill " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* TableCopy */19 :
          match = [
            "table.copy " + (Curry._1(I32.to_string_u, x._0.it) + (" " + Curry._1(I32.to_string_u, x._1.it))),
            /* [] */0
          ];
          break;
      case /* TableInit */20 :
          match = [
            "table.init " + (Curry._1(I32.to_string_u, x._0.it) + (" " + Curry._1(I32.to_string_u, x._1.it))),
            /* [] */0
          ];
          break;
      case /* ElemDrop */21 :
          match = [
            "elem.drop " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* Load */22 :
          match = [
            loadop(x._0),
            /* [] */0
          ];
          break;
      case /* Store */23 :
          match = [
            storeop(x._0),
            /* [] */0
          ];
          break;
      case /* VecLoad */24 :
          match = [
            vec_loadop(x._0),
            /* [] */0
          ];
          break;
      case /* VecStore */25 :
          match = [
            vec_storeop(x._0),
            /* [] */0
          ];
          break;
      case /* VecLoadLane */26 :
          match = [
            vec_laneop("load", x._0),
            /* [] */0
          ];
          break;
      case /* VecStoreLane */27 :
          match = [
            vec_laneop("store", x._0),
            /* [] */0
          ];
          break;
      case /* MemoryInit */28 :
          match = [
            "memory.init " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* DataDrop */29 :
          match = [
            "data.drop " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* RefNull */30 :
          match = [
            "ref.null",
            {
              hd: {
                TAG: /* Atom */0,
                _0: Types.string_of_refed_type(x._0)
              },
              tl: /* [] */0
            }
          ];
          break;
      case /* RefFunc */31 :
          match = [
            "ref.func " + Curry._1(I32.to_string_u, x._0.it),
            /* [] */0
          ];
          break;
      case /* Const */32 :
          var n = x._0;
          match = [
            constop(n.it) + (" " + Values.string_of_num(n.it)),
            /* [] */0
          ];
          break;
      case /* Test */33 :
          match = [
            Curry._1(testop$2, x._0),
            /* [] */0
          ];
          break;
      case /* Compare */34 :
          match = [
            Curry._1(relop$2, x._0),
            /* [] */0
          ];
          break;
      case /* Unary */35 :
          match = [
            Curry._1(unop$2, x._0),
            /* [] */0
          ];
          break;
      case /* Binary */36 :
          match = [
            Curry._1(binop$2, x._0),
            /* [] */0
          ];
          break;
      case /* Convert */37 :
          match = [
            Curry._1(cvtop$2, x._0),
            /* [] */0
          ];
          break;
      case /* VecConst */38 :
          var v = x._0;
          match = [
            vec_constop(v.it) + (" " + Values.string_of_vec(v.it)),
            /* [] */0
          ];
          break;
      case /* VecTest */39 :
          match = [
            Curry._1(vec_testop, x._0),
            /* [] */0
          ];
          break;
      case /* VecCompare */40 :
          match = [
            Curry._1(vec_relop, x._0),
            /* [] */0
          ];
          break;
      case /* VecUnary */41 :
          match = [
            Curry._1(vec_unop, x._0),
            /* [] */0
          ];
          break;
      case /* VecBinary */42 :
          match = [
            Curry._1(vec_binop, x._0),
            /* [] */0
          ];
          break;
      case /* VecConvert */43 :
          match = [
            Curry._1(vec_cvtop, x._0),
            /* [] */0
          ];
          break;
      case /* VecShift */44 :
          match = [
            Curry._1(vec_shiftop, x._0),
            /* [] */0
          ];
          break;
      case /* VecBitmask */45 :
          match = [
            Curry._1(vec_bitmaskop, x._0),
            /* [] */0
          ];
          break;
      case /* VecTestBits */46 :
          match = [
            vec_oper(vtestop, x._0),
            /* [] */0
          ];
          break;
      case /* VecUnaryBits */47 :
          match = [
            vec_oper(vunop, x._0),
            /* [] */0
          ];
          break;
      case /* VecBinaryBits */48 :
          match = [
            vec_oper(vbinop, x._0),
            /* [] */0
          ];
          break;
      case /* VecTernaryBits */49 :
          match = [
            vec_oper(vternop, x._0),
            /* [] */0
          ];
          break;
      case /* VecSplat */50 :
          match = [
            Curry._1(vec_splatop, x._0),
            /* [] */0
          ];
          break;
      case /* VecExtract */51 :
          match = [
            Curry._1(vec_extractop, x._0),
            /* [] */0
          ];
          break;
      case /* VecReplace */52 :
          match = [
            Curry._1(vec_replaceop, x._0),
            /* [] */0
          ];
          break;
      
    }
  }
  return {
          TAG: /* Node */1,
          _0: match[0],
          _1: match[1]
        };
}

function $$const(head, c) {
  var es = c.it;
  if (es && !es.tl) {
    return instr(es.hd);
  } else {
    return {
            TAG: /* Node */1,
            _0: head,
            _1: List.map(instr, c.it)
          };
  }
}

function func_with_name(name, f) {
  var match = f.it;
  return {
          TAG: /* Node */1,
          _0: "func" + name,
          _1: Pervasives.$at({
                hd: {
                  TAG: /* Node */1,
                  _0: "type " + Curry._1(I32.to_string_u, match.ftype.it),
                  _1: /* [] */0
                },
                tl: /* [] */0
              }, Pervasives.$at(decls("local", match.locals), List.map(instr, match.body)))
        };
}

function func(f) {
  return func_with_name("", f);
}

function table(off, i, tab) {
  var match = tab.it;
  var match$1 = match.ttype;
  return {
          TAG: /* Node */1,
          _0: "table $" + (Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, off + i | 0)) + (" " + limits(I32.to_string_u, match$1._0))),
          _1: {
            hd: {
              TAG: /* Atom */0,
              _0: Types.string_of_ref_type(match$1._1)
            },
            tl: /* [] */0
          }
        };
}

function memory(off, i, mem) {
  var match = mem.it;
  return {
          TAG: /* Node */1,
          _0: "memory $" + (Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, off + i | 0)) + (" " + limits(I32.to_string_u, match.mtype._0))),
          _1: /* [] */0
        };
}

function elem_kind(param) {
  if (!param) {
    return "func";
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "arrange.ml",
          548,
          9
        ],
        Error: new Error()
      };
}

function is_elem_index(e) {
  var match = e.it;
  if (!match) {
    return false;
  }
  var tmp = match.hd.it;
  if (typeof tmp === "number" || !(tmp.TAG === /* RefFunc */31 && !match.tl)) {
    return false;
  } else {
    return true;
  }
}

function elem_index(e) {
  var match = e.it;
  if (match) {
    var x = match.hd.it;
    if (typeof x !== "number" && x.TAG === /* RefFunc */31 && !match.tl) {
      return {
              TAG: /* Atom */0,
              _0: Curry._1(I32.to_string_u, x._0.it)
            };
    }
    
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "arrange.ml",
          558,
          9
        ],
        Error: new Error()
      };
}

function segment_mode(category, mode) {
  var match = mode.it;
  if (typeof match === "number") {
    if (match !== 0) {
      return {
              hd: {
                TAG: /* Atom */0,
                _0: "declare"
              },
              tl: /* [] */0
            };
    } else {
      return /* [] */0;
    }
  }
  var index = match.index;
  return Pervasives.$at(index.it === 0 ? /* [] */0 : ({
                  hd: {
                    TAG: /* Node */1,
                    _0: category,
                    _1: {
                      hd: {
                        TAG: /* Atom */0,
                        _0: Curry._1(I32.to_string_u, index.it)
                      },
                      tl: /* [] */0
                    }
                  },
                  tl: /* [] */0
                }), {
              hd: $$const("offset", match.offset),
              tl: /* [] */0
            });
}

function elem(i, seg) {
  var match = seg.it;
  var einit = match.einit;
  var etype = match.etype;
  return {
          TAG: /* Node */1,
          _0: "elem $" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, i)),
          _1: Pervasives.$at(segment_mode("table", match.emode), (
                etype ? false : true
              ) && List.for_all(is_elem_index, einit) ? ({
                    hd: {
                      TAG: /* Atom */0,
                      _0: elem_kind(etype)
                    },
                    tl: List.map(elem_index, einit)
                  }) : ({
                    hd: {
                      TAG: /* Atom */0,
                      _0: Types.string_of_ref_type(etype)
                    },
                    tl: List.map((function (param) {
                            return $$const("item", param);
                          }), einit)
                  }))
        };
}

function data(i, seg) {
  var match = seg.it;
  return {
          TAG: /* Node */1,
          _0: "data $" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, i)),
          _1: Pervasives.$at(segment_mode("memory", match.dmode), break_bytes(match.dinit))
        };
}

function typedef(i, ty) {
  return {
          TAG: /* Node */1,
          _0: "type $" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, i)),
          _1: {
            hd: func_type(ty.it),
            tl: /* [] */0
          }
        };
}

function import_desc(fx, tx, mx, gx, d) {
  var x = d.it;
  switch (x.TAG | 0) {
    case /* FuncImport */0 :
        fx.contents = fx.contents + 1 | 0;
        return {
                TAG: /* Node */1,
                _0: "func $" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, fx.contents - 1 | 0)),
                _1: {
                  hd: {
                    TAG: /* Node */1,
                    _0: "type",
                    _1: {
                      hd: {
                        TAG: /* Atom */0,
                        _0: Curry._1(I32.to_string_u, x._0.it)
                      },
                      tl: /* [] */0
                    }
                  },
                  tl: /* [] */0
                }
              };
    case /* TableImport */1 :
        tx.contents = tx.contents + 1 | 0;
        return table(0, tx.contents - 1 | 0, Source.$at$at({
                        ttype: x._0
                      }, d.at));
    case /* MemoryImport */2 :
        mx.contents = mx.contents + 1 | 0;
        return memory(0, mx.contents - 1 | 0, Source.$at$at({
                        mtype: x._0
                      }, d.at));
    case /* GlobalImport */3 :
        gx.contents = gx.contents + 1 | 0;
        return {
                TAG: /* Node */1,
                _0: "global $" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, gx.contents - 1 | 0)),
                _1: {
                  hd: global_type(x._0),
                  tl: /* [] */0
                }
              };
    
  }
}

function export_desc(d) {
  var x = d.it;
  switch (x.TAG | 0) {
    case /* FuncExport */0 :
        return {
                TAG: /* Node */1,
                _0: "func",
                _1: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: Curry._1(I32.to_string_u, x._0.it)
                  },
                  tl: /* [] */0
                }
              };
    case /* TableExport */1 :
        return {
                TAG: /* Node */1,
                _0: "table",
                _1: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: Curry._1(I32.to_string_u, x._0.it)
                  },
                  tl: /* [] */0
                }
              };
    case /* MemoryExport */2 :
        return {
                TAG: /* Node */1,
                _0: "memory",
                _1: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: Curry._1(I32.to_string_u, x._0.it)
                  },
                  tl: /* [] */0
                }
              };
    case /* GlobalExport */3 :
        return {
                TAG: /* Node */1,
                _0: "global",
                _1: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: Curry._1(I32.to_string_u, x._0.it)
                  },
                  tl: /* [] */0
                }
              };
    
  }
}

function $$export(ex) {
  var match = ex.it;
  return {
          TAG: /* Node */1,
          _0: "export",
          _1: {
            hd: {
              TAG: /* Atom */0,
              _0: string_with(List.iter, add_unicode_char, match.name)
            },
            tl: {
              hd: export_desc(match.edesc),
              tl: /* [] */0
            }
          }
        };
}

function start(s) {
  return {
          TAG: /* Node */1,
          _0: "start " + Curry._1(I32.to_string_u, s.it.sfunc.it),
          _1: /* [] */0
        };
}

function var_opt(x) {
  if (x !== undefined) {
    return " " + x.it;
  } else {
    return "";
  }
}

function module_with_var_opt(x_opt, m) {
  var fx = {
    contents: 0
  };
  var tx = {
    contents: 0
  };
  var mx = {
    contents: 0
  };
  var gx = {
    contents: 0
  };
  var imports = List.map((function (param) {
          var match = param.it;
          return {
                  TAG: /* Node */1,
                  _0: "import",
                  _1: {
                    hd: {
                      TAG: /* Atom */0,
                      _0: string_with(List.iter, add_unicode_char, match.module_name)
                    },
                    tl: {
                      hd: {
                        TAG: /* Atom */0,
                        _0: string_with(List.iter, add_unicode_char, match.item_name)
                      },
                      tl: {
                        hd: import_desc(fx, tx, mx, gx, match.idesc),
                        tl: /* [] */0
                      }
                    }
                  }
                };
        }), m.it.imports);
  var partial_arg = tx.contents;
  var partial_arg$1 = mx.contents;
  var partial_arg$2 = gx.contents;
  var partial_arg$3 = fx.contents;
  return {
          TAG: /* Node */1,
          _0: "module" + var_opt(x_opt),
          _1: Pervasives.$at(List.mapi(typedef, m.it.types), Pervasives.$at(imports, Pervasives.$at(List.mapi((function (param, param$1) {
                              return table(partial_arg, param, param$1);
                            }), m.it.tables), Pervasives.$at(List.mapi((function (param, param$1) {
                                  return memory(partial_arg$1, param, param$1);
                                }), m.it.memories), Pervasives.$at(List.mapi((function (param, param$1) {
                                      var match = param$1.it;
                                      return {
                                              TAG: /* Node */1,
                                              _0: "global $" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, partial_arg$2 + param | 0)),
                                              _1: {
                                                hd: global_type(match.gtype),
                                                tl: List.map(instr, match.ginit.it)
                                              }
                                            };
                                    }), m.it.globals), Pervasives.$at(List.mapi((function (param, param$1) {
                                          return func_with_name(" $" + Curry._1(I32.to_string_u, Curry._1(I32.of_int_u, partial_arg$3 + param | 0)), param$1);
                                        }), m.it.funcs), Pervasives.$at(List.map($$export, m.it.exports), Pervasives.$at(List.map(start, list_of_opt(m.it.start)), Pervasives.$at(List.mapi(elem, m.it.elems), List.mapi(data, m.it.datas))))))))))
        };
}

function binary_module_with_var_opt(x_opt, bs) {
  return {
          TAG: /* Node */1,
          _0: "module" + (var_opt(x_opt) + " binary"),
          _1: break_bytes(bs)
        };
}

function quoted_module_with_var_opt(x_opt, s) {
  return {
          TAG: /* Node */1,
          _0: "module" + (var_opt(x_opt) + " quote"),
          _1: break_string(s)
        };
}

function module_(param) {
  return module_with_var_opt(undefined, param);
}

function num(mode) {
  if (mode === "Binary") {
    return Values.hex_string_of_num;
  } else {
    return Values.string_of_num;
  }
}

function vec(mode) {
  if (mode === "Binary") {
    return Values.hex_string_of_vec;
  } else {
    return Values.string_of_vec;
  }
}

function ref_(t) {
  if (t.RE_EXN_ID === Values.NullRef) {
    return {
            TAG: /* Node */1,
            _0: "ref.null " + Types.string_of_refed_type(t._1),
            _1: /* [] */0
          };
  }
  if (t.RE_EXN_ID === Script.ExternRef) {
    return {
            TAG: /* Node */1,
            _0: "ref.extern " + Curry._1(I32.to_string_u, t._1),
            _1: /* [] */0
          };
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "arrange.ml",
          666,
          9
        ],
        Error: new Error()
      };
}

function literal(mode, lit) {
  var n = lit.it;
  switch (n.TAG | 0) {
    case /* Num */0 :
        var n$1 = n._0;
        return {
                TAG: /* Node */1,
                _0: constop(n$1) + (" " + num(mode)(n$1)),
                _1: /* [] */0
              };
    case /* Vec */1 :
        var v = n._0;
        return {
                TAG: /* Node */1,
                _0: vec_constop(v) + (" " + vec(mode)(v)),
                _1: /* [] */0
              };
    case /* Ref */2 :
        return ref_(n._0);
    
  }
}

function definition(mode, x_opt, def) {
  try {
    if (mode === "Binary") {
      var unquote = function (_def) {
        while(true) {
          var def = _def;
          var m = def.it;
          switch (m.TAG | 0) {
            case /* Textual */0 :
                return Encode.encode(m._0);
            case /* Encoded */1 :
                return Encode.encode(Decode.decode("", m._1));
            case /* Quoted */2 :
                _def = Parse.string_to_module(m._1);
                continue ;
            
          }
        };
      };
      return binary_module_with_var_opt(x_opt, unquote(def));
    }
    if (mode === "Original") {
      var m = def.it;
      switch (m.TAG | 0) {
        case /* Textual */0 :
            return module_with_var_opt(x_opt, m._0);
        case /* Encoded */1 :
            return binary_module_with_var_opt(x_opt, m._1);
        case /* Quoted */2 :
            return quoted_module_with_var_opt(x_opt, m._1);
        
      }
    } else {
      var unquote$1 = function (_def) {
        while(true) {
          var def = _def;
          var m = def.it;
          switch (m.TAG | 0) {
            case /* Textual */0 :
                return m._0;
            case /* Encoded */1 :
                return Decode.decode("", m._1);
            case /* Quoted */2 :
                _def = Parse.string_to_module(m._1);
                continue ;
            
          }
        };
      };
      return module_with_var_opt(x_opt, unquote$1(def));
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Parse.Syntax) {
      return quoted_module_with_var_opt(x_opt, "<invalid module>");
    }
    throw exn;
  }
}

function access(x_opt, n) {
  return $$String.concat(" ", {
              hd: var_opt(x_opt),
              tl: {
                hd: string_with(List.iter, add_unicode_char, n),
                tl: /* [] */0
              }
            });
}

function action(mode, act) {
  var match = act.it;
  if (match.TAG === /* Invoke */0) {
    return {
            TAG: /* Node */1,
            _0: "invoke" + access(match._0, match._1),
            _1: List.map((function (param) {
                    return literal(mode, param);
                  }), match._2)
          };
  } else {
    return {
            TAG: /* Node */1,
            _0: "get" + access(match._0, match._1),
            _1: /* [] */0
          };
  }
}

function nanop(n) {
  var match = n.it;
  switch (match.TAG | 0) {
    case /* I32 */0 :
    case /* I64 */1 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "arrange.ml",
                716,
                9
              ],
              Error: new Error()
            };
    case /* F32 */2 :
    case /* F64 */3 :
        if (match._0) {
          return "nan:arithmetic";
        } else {
          return "nan:canonical";
        }
    
  }
}

function lane_pat(mode, pat, shape) {
  var choose = function (fb, ft) {
    if (mode === "Binary") {
      return fb;
    } else {
      return ft;
    }
  };
  if (pat.TAG !== /* NumPat */0) {
    return nanop(pat._0);
  }
  var n = pat._0;
  var i = n.it;
  if (i.TAG !== /* I32 */0) {
    return num(mode)(n.it);
  }
  var i$1 = i._0;
  switch (shape.TAG | 0) {
    case /* I8x16 */0 :
        return Curry._1(choose(I8.to_hex_string, I8.to_string_s), i$1);
    case /* I16x8 */1 :
        return Curry._1(choose(I16.to_hex_string, I16.to_string_s), i$1);
    default:
      return num(mode)(n.it);
  }
}

function script(mode, scr) {
  return Lib.List.concat_map((function (param) {
                var act = param.it;
                switch (act.TAG | 0) {
                  case /* Module */0 :
                      return {
                              hd: definition(mode, act._0, act._1),
                              tl: /* [] */0
                            };
                  case /* Register */1 :
                      return {
                              hd: {
                                TAG: /* Node */1,
                                _0: "register " + (string_with(List.iter, add_unicode_char, act._0) + var_opt(act._1)),
                                _1: /* [] */0
                              },
                              tl: /* [] */0
                            };
                  case /* Action */2 :
                      return {
                              hd: action(mode, act._0),
                              tl: /* [] */0
                            };
                  case /* Assertion */3 :
                      var ass = act._0;
                      var match = ass.it;
                      switch (match.TAG | 0) {
                        case /* AssertMalformed */0 :
                            var def = match._0;
                            var match$1 = def.it;
                            if (mode === "Binary") {
                              switch (match$1.TAG | 0) {
                                case /* Textual */0 :
                                case /* Encoded */1 :
                                    break;
                                case /* Quoted */2 :
                                    return /* [] */0;
                                
                              }
                            }
                            return {
                                    hd: {
                                      TAG: /* Node */1,
                                      _0: "assert_malformed",
                                      _1: {
                                        hd: definition("Original", undefined, def),
                                        tl: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: string_with($$String.iter, add_char, match._1)
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  };
                        case /* AssertInvalid */1 :
                            return {
                                    hd: {
                                      TAG: /* Node */1,
                                      _0: "assert_invalid",
                                      _1: {
                                        hd: definition(mode, undefined, match._0),
                                        tl: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: string_with($$String.iter, add_char, match._1)
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  };
                        case /* AssertUnlinkable */2 :
                            return {
                                    hd: {
                                      TAG: /* Node */1,
                                      _0: "assert_unlinkable",
                                      _1: {
                                        hd: definition(mode, undefined, match._0),
                                        tl: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: string_with($$String.iter, add_char, match._1)
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  };
                        case /* AssertUninstantiable */3 :
                            return {
                                    hd: {
                                      TAG: /* Node */1,
                                      _0: "assert_trap",
                                      _1: {
                                        hd: definition(mode, undefined, match._0),
                                        tl: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: string_with($$String.iter, add_char, match._1)
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  };
                        case /* AssertReturn */4 :
                            return {
                                    hd: {
                                      TAG: /* Node */1,
                                      _0: "assert_return",
                                      _1: {
                                        hd: action(mode, match._0),
                                        tl: List.map((function (param) {
                                                var np = param.it;
                                                switch (np.TAG | 0) {
                                                  case /* NumResult */0 :
                                                      var n = np._0;
                                                      if (n.TAG === /* NumPat */0) {
                                                        var n$1 = n._0;
                                                        return literal(mode, Source.$at$at({
                                                                        TAG: /* Num */0,
                                                                        _0: n$1.it
                                                                      }, n$1.at));
                                                      }
                                                      var nan = n._0;
                                                      return {
                                                              TAG: /* Node */1,
                                                              _0: constop(nan.it) + (" " + nanop(nan)),
                                                              _1: /* [] */0
                                                            };
                                                  case /* VecResult */1 :
                                                      var param$1 = np._0;
                                                      var match = param$1._0._0;
                                                      var shape = match[0];
                                                      var lanes = List.map((function (p) {
                                                              return {
                                                                      TAG: /* Atom */0,
                                                                      _0: lane_pat(mode, p, shape)
                                                                    };
                                                            }), match[1]);
                                                      return {
                                                              TAG: /* Node */1,
                                                              _0: "v128.const " + V128.string_of_shape(shape),
                                                              _1: lanes
                                                            };
                                                  case /* RefResult */2 :
                                                      var r = np._0;
                                                      if (r.TAG === /* RefPat */0) {
                                                        return ref_(r._0.it);
                                                      } else {
                                                        return {
                                                                TAG: /* Node */1,
                                                                _0: "ref." + Types.string_of_refed_type(r._0),
                                                                _1: /* [] */0
                                                              };
                                                      }
                                                  
                                                }
                                              }), match._1)
                                      }
                                    },
                                    tl: /* [] */0
                                  };
                        case /* AssertTrap */5 :
                            return {
                                    hd: {
                                      TAG: /* Node */1,
                                      _0: "assert_trap",
                                      _1: {
                                        hd: action(mode, match._0),
                                        tl: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: string_with($$String.iter, add_char, match._1)
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  };
                        case /* AssertExhaustion */6 :
                            return {
                                    hd: {
                                      TAG: /* Node */1,
                                      _0: "assert_exhaustion",
                                      _1: {
                                        hd: action(mode, match._0),
                                        tl: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: string_with($$String.iter, add_char, match._1)
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  };
                        
                      }
                  case /* Meta */4 :
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "arrange.ml",
                              774,
                              14
                            ],
                            Error: new Error()
                          };
                  
                }
              }), scr);
}

exports.instr = instr;
exports.func = func;
exports.module_ = module_;
exports.script = script;
/* I8 Not a pure module */
