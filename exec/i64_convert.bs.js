// Generated by ReScript, PLEASE EDIT WITH CARE

import * as F32 from "./f32.bs.js";
import * as F64 from "./f64.bs.js";
import * as Ixx from "./ixx.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Int64 from "rescript/lib/es6/int64.js";
import * as Caml_int64 from "rescript/lib/es6/caml_int64.js";

var extend_i32_s = Caml_int64.of_int32;

function extend_i32_u(x) {
  return Caml_int64.and_(Caml_int64.of_int32(x), [
              0,
              4294967295
            ]);
}

function trunc_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) || xf < Caml_int64.to_float(Int64.min_int)) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.of_float(xf);
}

function trunc_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9.22337203685477581e+18), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) || xf < Caml_int64.to_float(Int64.min_int)) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.of_float(xf);
}

function trunc_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9.22337203685477581e+18), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf < Caml_int64.to_float(Int64.min_int)) {
    return Int64.min_int;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Int64.max_int;
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf <= -1.0) {
    return Caml_int64.zero;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0) {
    return Caml_int64.neg_one;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9223372036854775808.0), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf < Caml_int64.to_float(Int64.min_int)) {
    return Int64.min_int;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Int64.max_int;
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf <= -1.0) {
    return Caml_int64.zero;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0) {
    return Caml_int64.neg_one;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9223372036854775808.0), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

var reinterpret_f64 = F64.to_bits;

export {
  extend_i32_s ,
  extend_i32_u ,
  trunc_f32_s ,
  trunc_f32_u ,
  trunc_f64_s ,
  trunc_f64_u ,
  trunc_sat_f32_s ,
  trunc_sat_f32_u ,
  trunc_sat_f64_s ,
  trunc_sat_f64_u ,
  reinterpret_f64 ,
  
}
/* F32 Not a pure module */
