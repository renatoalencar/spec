// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var F32 = require("./f32.bs.js");
var F64 = require("./f64.bs.js");
var Ixx = require("./ixx.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Int64 = require("rescript/lib/js/int64.js");
var Caml_int64 = require("rescript/lib/js/caml_int64.js");

var extend_i32_s = Caml_int64.of_int32;

function extend_i32_u(x) {
  return Caml_int64.and_(Caml_int64.of_int32(x), [
              0,
              4294967295
            ]);
}

function trunc_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) || xf < Caml_int64.to_float(Int64.min_int)) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.of_float(xf);
}

function trunc_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9.22337203685477581e+18), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) || xf < Caml_int64.to_float(Int64.min_int)) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.of_float(xf);
}

function trunc_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9.22337203685477581e+18), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf < Caml_int64.to_float(Int64.min_int)) {
    return Int64.min_int;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Int64.max_int;
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf <= -1.0) {
    return Caml_int64.zero;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0) {
    return Caml_int64.neg_one;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9223372036854775808.0), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf < Caml_int64.to_float(Int64.min_int)) {
    return Int64.min_int;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Int64.max_int;
  } else {
    return Caml_int64.of_float(xf);
  }
}

function trunc_sat_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    return Caml_int64.zero;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf <= -1.0) {
    return Caml_int64.zero;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int) * 2.0) {
    return Caml_int64.neg_one;
  } else if (xf >= -Caml_int64.to_float(Int64.min_int)) {
    return Caml_int64.xor(Caml_int64.of_float(xf - 9223372036854775808.0), Int64.min_int);
  } else {
    return Caml_int64.of_float(xf);
  }
}

var reinterpret_f64 = F64.to_bits;

exports.extend_i32_s = extend_i32_s;
exports.extend_i32_u = extend_i32_u;
exports.trunc_f32_s = trunc_f32_s;
exports.trunc_f32_u = trunc_f32_u;
exports.trunc_f64_s = trunc_f64_s;
exports.trunc_f64_u = trunc_f64_u;
exports.trunc_sat_f32_s = trunc_sat_f32_s;
exports.trunc_sat_f32_u = trunc_sat_f32_u;
exports.trunc_sat_f64_s = trunc_sat_f64_s;
exports.trunc_sat_f64_u = trunc_sat_f64_u;
exports.reinterpret_f64 = reinterpret_f64;
/* F32 Not a pure module */
