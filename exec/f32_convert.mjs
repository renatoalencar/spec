// Generated by ReScript, PLEASE EDIT WITH CARE

import * as F32 from "./f32.mjs";
import * as F64 from "./f64.mjs";
import * as I64 from "./i64.mjs";
import * as Caml from "rescript/lib/es6/caml.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Int32 from "rescript/lib/es6/int32.js";
import * as Int64 from "rescript/lib/es6/int64.js";
import * as Caml_int64 from "rescript/lib/es6/caml_int64.js";
import * as I32_convert from "./i32_convert.mjs";

function demote_f64(x) {
  var xf = Curry._1(F64.to_float, x);
  if (xf === xf) {
    return Curry._1(F32.of_float, xf);
  }
  var nan64bits = Curry._1(F64.to_bits, x);
  var sign_field = Caml_int64.lsl_(Caml_int64.lsr_(nan64bits, 63), 31);
  var significand_field = Caml_int64.lsr_(Caml_int64.lsl_(nan64bits, 12), 41);
  var fields = Caml_int64.or_(sign_field, significand_field);
  return Curry._1(F32.of_bits, 2143289344 | I32_convert.wrap_i64(fields));
}

function convert_i32_s(x) {
  return Curry._1(F32.of_float, x);
}

function convert_i32_u(x) {
  return Curry._1(F32.of_float, x >= Int32.zero ? x : ((x >>> 1) | x & 1) * 2.0);
}

function convert_i64_s(x) {
  var tmp;
  if (Caml.i64_lt(Int64.abs(x), [
          1048576,
          0
        ])) {
    tmp = Caml_int64.to_float(x);
  } else {
    var r = Caml.i64_eq(Caml_int64.and_(x, [
              0,
              4095
            ]), Caml_int64.zero) ? Caml_int64.zero : Caml_int64.one;
    tmp = Caml_int64.to_float(Caml_int64.or_(Caml_int64.asr_(x, 12), r)) * 4096;
  }
  return Curry._1(F32.of_float, tmp);
}

function convert_i64_u(x) {
  var tmp;
  if (Curry._2(I64.lt_u, x, [
          1048576,
          0
        ])) {
    tmp = Caml_int64.to_float(x);
  } else {
    var r = Caml.i64_eq(Caml_int64.and_(x, [
              0,
              4095
            ]), Caml_int64.zero) ? Caml_int64.zero : Caml_int64.one;
    tmp = Caml_int64.to_float(Caml_int64.or_(Caml_int64.lsr_(x, 12), r)) * 4096;
  }
  return Curry._1(F32.of_float, tmp);
}

var reinterpret_i32 = F32.of_bits;

export {
  demote_f64 ,
  convert_i32_s ,
  convert_i32_u ,
  convert_i64_s ,
  convert_i64_u ,
  reinterpret_i32 ,
  
}
/* F32 Not a pure module */
