// Generated by ReScript, PLEASE EDIT WITH CARE

import * as I8 from "./i8.bs.js";
import * as F32 from "./f32.bs.js";
import * as F64 from "./f64.bs.js";
import * as I16 from "./i16.bs.js";
import * as I32 from "./i32.bs.js";
import * as I64 from "./i64.bs.js";
import * as Lib from "../util/lib.bs.js";
import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Int32 from "rescript/lib/es6/int32.js";
import * as Int64 from "rescript/lib/es6/int64.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_bytes from "rescript/lib/es6/caml_bytes.js";
import * as Caml_int64 from "rescript/lib/es6/caml_int64.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as F32_convert from "./f32_convert.bs.js";
import * as F64_convert from "./f64_convert.bs.js";
import * as I32_convert from "./i32_convert.bs.js";

var bytewidth = 16;

var zero = $$String.make(bytewidth, /* '\000' */0);

function of_bits(x) {
  return x;
}

function to_bits(x) {
  return x;
}

function num_lanes(shape) {
  switch (shape.TAG | 0) {
    case /* I8x16 */0 :
        return 16;
    case /* I16x8 */1 :
        return 8;
    case /* I32x4 */2 :
    case /* F32x4 */4 :
        return 4;
    case /* I64x2 */3 :
    case /* F64x2 */5 :
        return 2;
    
  }
}

function type_of_lane(param) {
  switch (param.TAG | 0) {
    case /* I64x2 */3 :
        return /* I64Type */1;
    case /* F32x4 */4 :
        return /* F32Type */2;
    case /* F64x2 */5 :
        return /* F64Type */3;
    default:
      return /* I32Type */0;
  }
}

function to_lanes(s) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          246,
          6
        ],
        Error: new Error()
      };
}

function of_lanes(fs) {
  Caml_bytes.caml_create_bytes(bytewidth);
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          249,
          6
        ],
        Error: new Error()
      };
}

var Cvt_shape = {
  TAG: /* I8x16 */0,
  _0: undefined
};

var num_lanes$1 = num_lanes(Cvt_shape);

var of_lanes$1 = of_lanes;

var to_lanes$1 = to_lanes;

function unop(f, x) {
  return Curry._1(of_lanes$1, List.map(f, Curry._1(to_lanes$1, x)));
}

function binop(f, x, y) {
  return Curry._1(of_lanes$1, List.map2(f, Curry._1(to_lanes$1, x), Curry._1(to_lanes$1, y)));
}

function reduceop(f, a, s) {
  return List.fold_left((function (a, b) {
                return Curry._2(f, a, Caml_obj.caml_notequal(b, I8.zero));
              }), a, Curry._1(to_lanes$1, s));
}

function cmp(f, x, y) {
  if (Curry._2(f, x, y)) {
    return Curry._1(I8.of_int_s, -1);
  } else {
    return I8.zero;
  }
}

function splat(x) {
  return Curry._1(of_lanes$1, List.init(num_lanes$1, (function (i) {
                    return x;
                  })));
}

function extract_lane_s(i, s) {
  return List.nth(Curry._1(to_lanes$1, s), i);
}

function extract_lane_u(i, s) {
  return Curry._1(I8.as_unsigned, List.nth(Curry._1(to_lanes$1, s), i));
}

function replace_lane(i, v, x) {
  var f = function (j, y) {
    if (j === i) {
      return x;
    } else {
      return y;
    }
  };
  return Curry._1(of_lanes$1, List.mapi(f, Curry._1(to_lanes$1, v)));
}

function eq(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.eq, param, param$1);
              }), param, param$1);
}

function ne(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.ne, param, param$1);
              }), param, param$1);
}

function lt_s(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.lt_s, param, param$1);
              }), param, param$1);
}

function lt_u(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.lt_u, param, param$1);
              }), param, param$1);
}

function le_s(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.le_s, param, param$1);
              }), param, param$1);
}

function le_u(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.le_u, param, param$1);
              }), param, param$1);
}

function gt_s(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.gt_s, param, param$1);
              }), param, param$1);
}

function gt_u(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.gt_u, param, param$1);
              }), param, param$1);
}

function ge_s(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.ge_s, param, param$1);
              }), param, param$1);
}

function ge_u(param, param$1) {
  return binop((function (param, param$1) {
                return cmp(I8.ge_u, param, param$1);
              }), param, param$1);
}

function abs(param) {
  return unop(I8.abs, param);
}

function neg(param) {
  return unop(I8.neg, param);
}

function popcnt(param) {
  return unop(I8.popcnt, param);
}

function add(param, param$1) {
  return binop(I8.add, param, param$1);
}

function sub(param, param$1) {
  return binop(I8.sub, param, param$1);
}

function mul(param, param$1) {
  return binop(I8.mul, param, param$1);
}

function choose(f, x, y) {
  if (Curry._2(f, x, y)) {
    return x;
  } else {
    return y;
  }
}

function min_s(param, param$1) {
  return binop((function (param, param$1) {
                return choose(I8.le_s, param, param$1);
              }), param, param$1);
}

function min_u(param, param$1) {
  return binop((function (param, param$1) {
                return choose(I8.le_u, param, param$1);
              }), param, param$1);
}

function max_s(param, param$1) {
  return binop((function (param, param$1) {
                return choose(I8.ge_s, param, param$1);
              }), param, param$1);
}

function max_u(param, param$1) {
  return binop((function (param, param$1) {
                return choose(I8.ge_u, param, param$1);
              }), param, param$1);
}

function avgr_u(param, param$1) {
  return binop(I8.avgr_u, param, param$1);
}

function any_true(param) {
  return reduceop((function (prim0, prim1) {
                if (prim0) {
                  return true;
                } else {
                  return prim1;
                }
              }), false, param);
}

function all_true(param) {
  return reduceop((function (prim0, prim1) {
                if (prim0) {
                  return prim1;
                } else {
                  return false;
                }
              }), true, param);
}

function bitmask(x) {
  var xs = Curry._1(to_lanes$1, x);
  var negs = List.map((function (x) {
          if (Curry._2(I8.lt_s, x, I8.zero)) {
            return Int32.one;
          } else {
            return Int32.zero;
          }
        }), xs);
  return List.fold_right((function (a, b) {
                return a | (b << 1);
              }), negs, Int32.zero);
}

function shl(v, s) {
  var shift = Curry._1(I8.of_int_u, s);
  return unop((function (a) {
                return Curry._2(I8.shl, a, shift);
              }), v);
}

function shr_s(v, s) {
  var shift = Curry._1(I8.of_int_u, s);
  return unop((function (a) {
                return Curry._2(I8.shr_s, a, shift);
              }), v);
}

function shr_u(v, s) {
  var shift = Curry._1(I8.of_int_u, s);
  return unop((function (a) {
                return Curry._2(I8.shr_u, a, shift);
              }), v);
}

function add_sat_s(param, param$1) {
  return binop(I8.add_sat_s, param, param$1);
}

function add_sat_u(param, param$1) {
  return binop(I8.add_sat_u, param, param$1);
}

function sub_sat_s(param, param$1) {
  return binop(I8.sub_sat_s, param, param$1);
}

function sub_sat_u(param, param$1) {
  return binop(I8.sub_sat_u, param, param$1);
}

function q15mulr_sat_s(param, param$1) {
  return binop(I8.q15mulr_sat_s, param, param$1);
}

var I8x16 = {
  num_lanes: num_lanes$1,
  to_lanes: to_lanes$1,
  of_lanes: of_lanes$1,
  splat: splat,
  extract_lane_s: extract_lane_s,
  extract_lane_u: extract_lane_u,
  replace_lane: replace_lane,
  eq: eq,
  ne: ne,
  lt_s: lt_s,
  lt_u: lt_u,
  le_s: le_s,
  le_u: le_u,
  gt_s: gt_s,
  gt_u: gt_u,
  ge_s: ge_s,
  ge_u: ge_u,
  abs: abs,
  neg: neg,
  popcnt: popcnt,
  add: add,
  sub: sub,
  min_s: min_s,
  min_u: min_u,
  max_s: max_s,
  max_u: max_u,
  mul: mul,
  avgr_u: avgr_u,
  any_true: any_true,
  all_true: all_true,
  bitmask: bitmask,
  shl: shl,
  shr_s: shr_s,
  shr_u: shr_u,
  add_sat_s: add_sat_s,
  add_sat_u: add_sat_u,
  sub_sat_s: sub_sat_s,
  sub_sat_u: sub_sat_u,
  q15mulr_sat_s: q15mulr_sat_s
};

function to_lanes$2(s) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          257,
          6
        ],
        Error: new Error()
      };
}

function of_lanes$2(fs) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          259,
          6
        ],
        Error: new Error()
      };
}

var Cvt_shape$1 = {
  TAG: /* I16x8 */1,
  _0: undefined
};

var num_lanes$2 = num_lanes(Cvt_shape$1);

var of_lanes$3 = of_lanes$2;

var to_lanes$3 = to_lanes$2;

function unop$1(f, x) {
  return Curry._1(of_lanes$3, List.map(f, Curry._1(to_lanes$3, x)));
}

function binop$1(f, x, y) {
  return Curry._1(of_lanes$3, List.map2(f, Curry._1(to_lanes$3, x), Curry._1(to_lanes$3, y)));
}

function reduceop$1(f, a, s) {
  return List.fold_left((function (a, b) {
                return Curry._2(f, a, Caml_obj.caml_notequal(b, I16.zero));
              }), a, Curry._1(to_lanes$3, s));
}

function cmp$1(f, x, y) {
  if (Curry._2(f, x, y)) {
    return Curry._1(I16.of_int_s, -1);
  } else {
    return I16.zero;
  }
}

function splat$1(x) {
  return Curry._1(of_lanes$3, List.init(num_lanes$2, (function (i) {
                    return x;
                  })));
}

function extract_lane_s$1(i, s) {
  return List.nth(Curry._1(to_lanes$3, s), i);
}

function extract_lane_u$1(i, s) {
  return Curry._1(I16.as_unsigned, List.nth(Curry._1(to_lanes$3, s), i));
}

function replace_lane$1(i, v, x) {
  var f = function (j, y) {
    if (j === i) {
      return x;
    } else {
      return y;
    }
  };
  return Curry._1(of_lanes$3, List.mapi(f, Curry._1(to_lanes$3, v)));
}

function eq$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.eq, param, param$1);
              }), param, param$1);
}

function ne$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.ne, param, param$1);
              }), param, param$1);
}

function lt_s$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.lt_s, param, param$1);
              }), param, param$1);
}

function lt_u$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.lt_u, param, param$1);
              }), param, param$1);
}

function le_s$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.le_s, param, param$1);
              }), param, param$1);
}

function le_u$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.le_u, param, param$1);
              }), param, param$1);
}

function gt_s$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.gt_s, param, param$1);
              }), param, param$1);
}

function gt_u$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.gt_u, param, param$1);
              }), param, param$1);
}

function ge_s$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.ge_s, param, param$1);
              }), param, param$1);
}

function ge_u$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return cmp$1(I16.ge_u, param, param$1);
              }), param, param$1);
}

function abs$1(param) {
  return unop$1(I16.abs, param);
}

function neg$1(param) {
  return unop$1(I16.neg, param);
}

function popcnt$1(param) {
  return unop$1(I16.popcnt, param);
}

function add$1(param, param$1) {
  return binop$1(I16.add, param, param$1);
}

function sub$1(param, param$1) {
  return binop$1(I16.sub, param, param$1);
}

function mul$1(param, param$1) {
  return binop$1(I16.mul, param, param$1);
}

function choose$1(f, x, y) {
  if (Curry._2(f, x, y)) {
    return x;
  } else {
    return y;
  }
}

function min_s$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return choose$1(I16.le_s, param, param$1);
              }), param, param$1);
}

function min_u$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return choose$1(I16.le_u, param, param$1);
              }), param, param$1);
}

function max_s$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return choose$1(I16.ge_s, param, param$1);
              }), param, param$1);
}

function max_u$1(param, param$1) {
  return binop$1((function (param, param$1) {
                return choose$1(I16.ge_u, param, param$1);
              }), param, param$1);
}

function avgr_u$1(param, param$1) {
  return binop$1(I16.avgr_u, param, param$1);
}

function any_true$1(param) {
  return reduceop$1((function (prim0, prim1) {
                if (prim0) {
                  return true;
                } else {
                  return prim1;
                }
              }), false, param);
}

function all_true$1(param) {
  return reduceop$1((function (prim0, prim1) {
                if (prim0) {
                  return prim1;
                } else {
                  return false;
                }
              }), true, param);
}

function bitmask$1(x) {
  var xs = Curry._1(to_lanes$3, x);
  var negs = List.map((function (x) {
          if (Curry._2(I16.lt_s, x, I16.zero)) {
            return Int32.one;
          } else {
            return Int32.zero;
          }
        }), xs);
  return List.fold_right((function (a, b) {
                return a | (b << 1);
              }), negs, Int32.zero);
}

function shl$1(v, s) {
  var shift = Curry._1(I16.of_int_u, s);
  return unop$1((function (a) {
                return Curry._2(I16.shl, a, shift);
              }), v);
}

function shr_s$1(v, s) {
  var shift = Curry._1(I16.of_int_u, s);
  return unop$1((function (a) {
                return Curry._2(I16.shr_s, a, shift);
              }), v);
}

function shr_u$1(v, s) {
  var shift = Curry._1(I16.of_int_u, s);
  return unop$1((function (a) {
                return Curry._2(I16.shr_u, a, shift);
              }), v);
}

function add_sat_s$1(param, param$1) {
  return binop$1(I16.add_sat_s, param, param$1);
}

function add_sat_u$1(param, param$1) {
  return binop$1(I16.add_sat_u, param, param$1);
}

function sub_sat_s$1(param, param$1) {
  return binop$1(I16.sub_sat_s, param, param$1);
}

function sub_sat_u$1(param, param$1) {
  return binop$1(I16.sub_sat_u, param, param$1);
}

function q15mulr_sat_s$1(param, param$1) {
  return binop$1(I16.q15mulr_sat_s, param, param$1);
}

var I16x8 = {
  num_lanes: num_lanes$2,
  to_lanes: to_lanes$3,
  of_lanes: of_lanes$3,
  splat: splat$1,
  extract_lane_s: extract_lane_s$1,
  extract_lane_u: extract_lane_u$1,
  replace_lane: replace_lane$1,
  eq: eq$1,
  ne: ne$1,
  lt_s: lt_s$1,
  lt_u: lt_u$1,
  le_s: le_s$1,
  le_u: le_u$1,
  gt_s: gt_s$1,
  gt_u: gt_u$1,
  ge_s: ge_s$1,
  ge_u: ge_u$1,
  abs: abs$1,
  neg: neg$1,
  popcnt: popcnt$1,
  add: add$1,
  sub: sub$1,
  min_s: min_s$1,
  min_u: min_u$1,
  max_s: max_s$1,
  max_u: max_u$1,
  mul: mul$1,
  avgr_u: avgr_u$1,
  any_true: any_true$1,
  all_true: all_true$1,
  bitmask: bitmask$1,
  shl: shl$1,
  shr_s: shr_s$1,
  shr_u: shr_u$1,
  add_sat_s: add_sat_s$1,
  add_sat_u: add_sat_u$1,
  sub_sat_s: sub_sat_s$1,
  sub_sat_u: sub_sat_u$1,
  q15mulr_sat_s: q15mulr_sat_s$1
};

function to_lanes$4(s) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          266,
          6
        ],
        Error: new Error()
      };
}

function of_lanes$4(fs) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          268,
          6
        ],
        Error: new Error()
      };
}

var Cvt_shape$2 = {
  TAG: /* I32x4 */2,
  _0: undefined
};

var num_lanes$3 = num_lanes(Cvt_shape$2);

var of_lanes$5 = of_lanes$4;

var to_lanes$5 = to_lanes$4;

function unop$2(f, x) {
  return Curry._1(of_lanes$5, List.map(f, Curry._1(to_lanes$5, x)));
}

function binop$2(f, x, y) {
  return Curry._1(of_lanes$5, List.map2(f, Curry._1(to_lanes$5, x), Curry._1(to_lanes$5, y)));
}

function reduceop$2(f, a, s) {
  return List.fold_left((function (a, b) {
                return Curry._2(f, a, Caml_obj.caml_notequal(b, I32.zero));
              }), a, Curry._1(to_lanes$5, s));
}

function cmp$2(f, x, y) {
  if (Curry._2(f, x, y)) {
    return Curry._1(I32.of_int_s, -1);
  } else {
    return I32.zero;
  }
}

function splat$2(x) {
  return Curry._1(of_lanes$5, List.init(num_lanes$3, (function (i) {
                    return x;
                  })));
}

function extract_lane_s$2(i, s) {
  return List.nth(Curry._1(to_lanes$5, s), i);
}

function extract_lane_u$2(i, s) {
  return Curry._1(I32.as_unsigned, List.nth(Curry._1(to_lanes$5, s), i));
}

function replace_lane$2(i, v, x) {
  var f = function (j, y) {
    if (j === i) {
      return x;
    } else {
      return y;
    }
  };
  return Curry._1(of_lanes$5, List.mapi(f, Curry._1(to_lanes$5, v)));
}

function eq$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.eq, param, param$1);
              }), param, param$1);
}

function ne$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.ne, param, param$1);
              }), param, param$1);
}

function lt_s$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.lt_s, param, param$1);
              }), param, param$1);
}

function lt_u$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.lt_u, param, param$1);
              }), param, param$1);
}

function le_s$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.le_s, param, param$1);
              }), param, param$1);
}

function le_u$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.le_u, param, param$1);
              }), param, param$1);
}

function gt_s$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.gt_s, param, param$1);
              }), param, param$1);
}

function gt_u$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.gt_u, param, param$1);
              }), param, param$1);
}

function ge_s$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.ge_s, param, param$1);
              }), param, param$1);
}

function ge_u$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return cmp$2(I32.ge_u, param, param$1);
              }), param, param$1);
}

function abs$2(param) {
  return unop$2(I32.abs, param);
}

function neg$2(param) {
  return unop$2(I32.neg, param);
}

function popcnt$2(param) {
  return unop$2(I32.popcnt, param);
}

function add$2(param, param$1) {
  return binop$2(I32.add, param, param$1);
}

function sub$2(param, param$1) {
  return binop$2(I32.sub, param, param$1);
}

function mul$2(param, param$1) {
  return binop$2(I32.mul, param, param$1);
}

function choose$2(f, x, y) {
  if (Curry._2(f, x, y)) {
    return x;
  } else {
    return y;
  }
}

function min_s$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return choose$2(I32.le_s, param, param$1);
              }), param, param$1);
}

function min_u$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return choose$2(I32.le_u, param, param$1);
              }), param, param$1);
}

function max_s$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return choose$2(I32.ge_s, param, param$1);
              }), param, param$1);
}

function max_u$2(param, param$1) {
  return binop$2((function (param, param$1) {
                return choose$2(I32.ge_u, param, param$1);
              }), param, param$1);
}

function avgr_u$2(param, param$1) {
  return binop$2(I32.avgr_u, param, param$1);
}

function any_true$2(param) {
  return reduceop$2((function (prim0, prim1) {
                if (prim0) {
                  return true;
                } else {
                  return prim1;
                }
              }), false, param);
}

function all_true$2(param) {
  return reduceop$2((function (prim0, prim1) {
                if (prim0) {
                  return prim1;
                } else {
                  return false;
                }
              }), true, param);
}

function bitmask$2(x) {
  var xs = Curry._1(to_lanes$5, x);
  var negs = List.map((function (x) {
          if (Curry._2(I32.lt_s, x, I32.zero)) {
            return Int32.one;
          } else {
            return Int32.zero;
          }
        }), xs);
  return List.fold_right((function (a, b) {
                return a | (b << 1);
              }), negs, Int32.zero);
}

function shl$2(v, s) {
  var shift = Curry._1(I32.of_int_u, s);
  return unop$2((function (a) {
                return Curry._2(I32.shl, a, shift);
              }), v);
}

function shr_s$2(v, s) {
  var shift = Curry._1(I32.of_int_u, s);
  return unop$2((function (a) {
                return Curry._2(I32.shr_s, a, shift);
              }), v);
}

function shr_u$2(v, s) {
  var shift = Curry._1(I32.of_int_u, s);
  return unop$2((function (a) {
                return Curry._2(I32.shr_u, a, shift);
              }), v);
}

function add_sat_s$2(param, param$1) {
  return binop$2(I32.add_sat_s, param, param$1);
}

function add_sat_u$2(param, param$1) {
  return binop$2(I32.add_sat_u, param, param$1);
}

function sub_sat_s$2(param, param$1) {
  return binop$2(I32.sub_sat_s, param, param$1);
}

function sub_sat_u$2(param, param$1) {
  return binop$2(I32.sub_sat_u, param, param$1);
}

function q15mulr_sat_s$2(param, param$1) {
  return binop$2(I32.q15mulr_sat_s, param, param$1);
}

var I32x4 = {
  num_lanes: num_lanes$3,
  to_lanes: to_lanes$5,
  of_lanes: of_lanes$5,
  splat: splat$2,
  extract_lane_s: extract_lane_s$2,
  extract_lane_u: extract_lane_u$2,
  replace_lane: replace_lane$2,
  eq: eq$2,
  ne: ne$2,
  lt_s: lt_s$2,
  lt_u: lt_u$2,
  le_s: le_s$2,
  le_u: le_u$2,
  gt_s: gt_s$2,
  gt_u: gt_u$2,
  ge_s: ge_s$2,
  ge_u: ge_u$2,
  abs: abs$2,
  neg: neg$2,
  popcnt: popcnt$2,
  add: add$2,
  sub: sub$2,
  min_s: min_s$2,
  min_u: min_u$2,
  max_s: max_s$2,
  max_u: max_u$2,
  mul: mul$2,
  avgr_u: avgr_u$2,
  any_true: any_true$2,
  all_true: all_true$2,
  bitmask: bitmask$2,
  shl: shl$2,
  shr_s: shr_s$2,
  shr_u: shr_u$2,
  add_sat_s: add_sat_s$2,
  add_sat_u: add_sat_u$2,
  sub_sat_s: sub_sat_s$2,
  sub_sat_u: sub_sat_u$2,
  q15mulr_sat_s: q15mulr_sat_s$2
};

function to_lanes$6(s) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          275,
          6
        ],
        Error: new Error()
      };
}

function of_lanes$6(fs) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          277,
          6
        ],
        Error: new Error()
      };
}

var Cvt_shape$3 = {
  TAG: /* I64x2 */3,
  _0: undefined
};

var num_lanes$4 = num_lanes(Cvt_shape$3);

var of_lanes$7 = of_lanes$6;

var to_lanes$7 = to_lanes$6;

function unop$3(f, x) {
  return Curry._1(of_lanes$7, List.map(f, Curry._1(to_lanes$7, x)));
}

function binop$3(f, x, y) {
  return Curry._1(of_lanes$7, List.map2(f, Curry._1(to_lanes$7, x), Curry._1(to_lanes$7, y)));
}

function reduceop$3(f, a, s) {
  return List.fold_left((function (a, b) {
                return Curry._2(f, a, Caml_obj.caml_notequal(b, I64.zero));
              }), a, Curry._1(to_lanes$7, s));
}

function cmp$3(f, x, y) {
  if (Curry._2(f, x, y)) {
    return Curry._1(I64.of_int_s, -1);
  } else {
    return I64.zero;
  }
}

function splat$3(x) {
  return Curry._1(of_lanes$7, List.init(num_lanes$4, (function (i) {
                    return x;
                  })));
}

function extract_lane_s$3(i, s) {
  return List.nth(Curry._1(to_lanes$7, s), i);
}

function extract_lane_u$3(i, s) {
  return Curry._1(I64.as_unsigned, List.nth(Curry._1(to_lanes$7, s), i));
}

function replace_lane$3(i, v, x) {
  var f = function (j, y) {
    if (j === i) {
      return x;
    } else {
      return y;
    }
  };
  return Curry._1(of_lanes$7, List.mapi(f, Curry._1(to_lanes$7, v)));
}

function eq$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.eq, param, param$1);
              }), param, param$1);
}

function ne$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.ne, param, param$1);
              }), param, param$1);
}

function lt_s$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.lt_s, param, param$1);
              }), param, param$1);
}

function lt_u$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.lt_u, param, param$1);
              }), param, param$1);
}

function le_s$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.le_s, param, param$1);
              }), param, param$1);
}

function le_u$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.le_u, param, param$1);
              }), param, param$1);
}

function gt_s$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.gt_s, param, param$1);
              }), param, param$1);
}

function gt_u$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.gt_u, param, param$1);
              }), param, param$1);
}

function ge_s$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.ge_s, param, param$1);
              }), param, param$1);
}

function ge_u$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return cmp$3(I64.ge_u, param, param$1);
              }), param, param$1);
}

function abs$3(param) {
  return unop$3(I64.abs, param);
}

function neg$3(param) {
  return unop$3(I64.neg, param);
}

function popcnt$3(param) {
  return unop$3(I64.popcnt, param);
}

function add$3(param, param$1) {
  return binop$3(I64.add, param, param$1);
}

function sub$3(param, param$1) {
  return binop$3(I64.sub, param, param$1);
}

function mul$3(param, param$1) {
  return binop$3(I64.mul, param, param$1);
}

function choose$3(f, x, y) {
  if (Curry._2(f, x, y)) {
    return x;
  } else {
    return y;
  }
}

function min_s$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return choose$3(I64.le_s, param, param$1);
              }), param, param$1);
}

function min_u$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return choose$3(I64.le_u, param, param$1);
              }), param, param$1);
}

function max_s$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return choose$3(I64.ge_s, param, param$1);
              }), param, param$1);
}

function max_u$3(param, param$1) {
  return binop$3((function (param, param$1) {
                return choose$3(I64.ge_u, param, param$1);
              }), param, param$1);
}

function avgr_u$3(param, param$1) {
  return binop$3(I64.avgr_u, param, param$1);
}

function any_true$3(param) {
  return reduceop$3((function (prim0, prim1) {
                if (prim0) {
                  return true;
                } else {
                  return prim1;
                }
              }), false, param);
}

function all_true$3(param) {
  return reduceop$3((function (prim0, prim1) {
                if (prim0) {
                  return prim1;
                } else {
                  return false;
                }
              }), true, param);
}

function bitmask$3(x) {
  var xs = Curry._1(to_lanes$7, x);
  var negs = List.map((function (x) {
          if (Curry._2(I64.lt_s, x, I64.zero)) {
            return Int32.one;
          } else {
            return Int32.zero;
          }
        }), xs);
  return List.fold_right((function (a, b) {
                return a | (b << 1);
              }), negs, Int32.zero);
}

function shl$3(v, s) {
  var shift = Curry._1(I64.of_int_u, s);
  return unop$3((function (a) {
                return Curry._2(I64.shl, a, shift);
              }), v);
}

function shr_s$3(v, s) {
  var shift = Curry._1(I64.of_int_u, s);
  return unop$3((function (a) {
                return Curry._2(I64.shr_s, a, shift);
              }), v);
}

function shr_u$3(v, s) {
  var shift = Curry._1(I64.of_int_u, s);
  return unop$3((function (a) {
                return Curry._2(I64.shr_u, a, shift);
              }), v);
}

function add_sat_s$3(param, param$1) {
  return binop$3(I64.add_sat_s, param, param$1);
}

function add_sat_u$3(param, param$1) {
  return binop$3(I64.add_sat_u, param, param$1);
}

function sub_sat_s$3(param, param$1) {
  return binop$3(I64.sub_sat_s, param, param$1);
}

function sub_sat_u$3(param, param$1) {
  return binop$3(I64.sub_sat_u, param, param$1);
}

function q15mulr_sat_s$3(param, param$1) {
  return binop$3(I64.q15mulr_sat_s, param, param$1);
}

var I64x2 = {
  num_lanes: num_lanes$4,
  to_lanes: to_lanes$7,
  of_lanes: of_lanes$7,
  splat: splat$3,
  extract_lane_s: extract_lane_s$3,
  extract_lane_u: extract_lane_u$3,
  replace_lane: replace_lane$3,
  eq: eq$3,
  ne: ne$3,
  lt_s: lt_s$3,
  lt_u: lt_u$3,
  le_s: le_s$3,
  le_u: le_u$3,
  gt_s: gt_s$3,
  gt_u: gt_u$3,
  ge_s: ge_s$3,
  ge_u: ge_u$3,
  abs: abs$3,
  neg: neg$3,
  popcnt: popcnt$3,
  add: add$3,
  sub: sub$3,
  min_s: min_s$3,
  min_u: min_u$3,
  max_s: max_s$3,
  max_u: max_u$3,
  mul: mul$3,
  avgr_u: avgr_u$3,
  any_true: any_true$3,
  all_true: all_true$3,
  bitmask: bitmask$3,
  shl: shl$3,
  shr_s: shr_s$3,
  shr_u: shr_u$3,
  add_sat_s: add_sat_s$3,
  add_sat_u: add_sat_u$3,
  sub_sat_s: sub_sat_s$3,
  sub_sat_u: sub_sat_u$3,
  q15mulr_sat_s: q15mulr_sat_s$3
};

function to_lanes$8(s) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          284,
          6
        ],
        Error: new Error()
      };
}

function of_lanes$8(fs) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          286,
          6
        ],
        Error: new Error()
      };
}

var Cvt_shape$4 = {
  TAG: /* F32x4 */4,
  _0: undefined
};

var num_lanes$5 = num_lanes(Cvt_shape$4);

var of_lanes$9 = of_lanes$8;

var to_lanes$9 = to_lanes$8;

function unop$4(f, x) {
  return Curry._1(of_lanes$9, List.map(f, Curry._1(to_lanes$9, x)));
}

function binop$4(f, x, y) {
  return Curry._1(of_lanes$9, List.map2(f, Curry._1(to_lanes$9, x), Curry._1(to_lanes$9, y)));
}

var all_ones = Curry._1(F32.of_float, Caml_int64.float_of_bits(Int64.minus_one));

function cmp$4(f, x, y) {
  if (Curry._2(f, x, y)) {
    return all_ones;
  } else {
    return F32.zero;
  }
}

function splat$4(x) {
  return Curry._1(of_lanes$9, List.init(num_lanes$5, (function (i) {
                    return x;
                  })));
}

function extract_lane(i, s) {
  return List.nth(Curry._1(to_lanes$9, s), i);
}

function replace_lane$4(i, v, x) {
  var f = function (j, y) {
    if (j === i) {
      return x;
    } else {
      return y;
    }
  };
  return Curry._1(of_lanes$9, List.mapi(f, Curry._1(to_lanes$9, v)));
}

function eq$4(param, param$1) {
  return binop$4((function (param, param$1) {
                return cmp$4(F32.eq, param, param$1);
              }), param, param$1);
}

function ne$4(param, param$1) {
  return binop$4((function (param, param$1) {
                return cmp$4(F32.ne, param, param$1);
              }), param, param$1);
}

function lt(param, param$1) {
  return binop$4((function (param, param$1) {
                return cmp$4(F32.lt, param, param$1);
              }), param, param$1);
}

function le(param, param$1) {
  return binop$4((function (param, param$1) {
                return cmp$4(F32.le, param, param$1);
              }), param, param$1);
}

function gt(param, param$1) {
  return binop$4((function (param, param$1) {
                return cmp$4(F32.gt, param, param$1);
              }), param, param$1);
}

function ge(param, param$1) {
  return binop$4((function (param, param$1) {
                return cmp$4(F32.ge, param, param$1);
              }), param, param$1);
}

function abs$4(param) {
  return unop$4(F32.abs, param);
}

function neg$4(param) {
  return unop$4(F32.neg, param);
}

function sqrt(param) {
  return unop$4(F32.sqrt, param);
}

function ceil(param) {
  return unop$4(F32.ceil, param);
}

function floor(param) {
  return unop$4(F32.floor, param);
}

function trunc(param) {
  return unop$4(F32.trunc, param);
}

function nearest(param) {
  return unop$4(F32.nearest, param);
}

function add$4(param, param$1) {
  return binop$4(F32.add, param, param$1);
}

function sub$4(param, param$1) {
  return binop$4(F32.sub, param, param$1);
}

function mul$4(param, param$1) {
  return binop$4(F32.mul, param, param$1);
}

function div(param, param$1) {
  return binop$4(F32.div, param, param$1);
}

function min(param, param$1) {
  return binop$4(F32.min, param, param$1);
}

function max(param, param$1) {
  return binop$4(F32.max, param, param$1);
}

function pmin(param, param$1) {
  return binop$4((function (x, y) {
                if (Curry._2(F32.lt, y, x)) {
                  return y;
                } else {
                  return x;
                }
              }), param, param$1);
}

function pmax(param, param$1) {
  return binop$4((function (x, y) {
                if (Curry._2(F32.lt, x, y)) {
                  return y;
                } else {
                  return x;
                }
              }), param, param$1);
}

var F32x4 = {
  num_lanes: num_lanes$5,
  to_lanes: to_lanes$9,
  of_lanes: of_lanes$9,
  splat: splat$4,
  extract_lane: extract_lane,
  replace_lane: replace_lane$4,
  eq: eq$4,
  ne: ne$4,
  lt: lt,
  le: le,
  gt: gt,
  ge: ge,
  abs: abs$4,
  neg: neg$4,
  sqrt: sqrt,
  ceil: ceil,
  floor: floor,
  trunc: trunc,
  nearest: nearest,
  add: add$4,
  sub: sub$4,
  mul: mul$4,
  div: div,
  min: min,
  max: max,
  pmin: pmin,
  pmax: pmax
};

function to_lanes$10(s) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          293,
          6
        ],
        Error: new Error()
      };
}

function of_lanes$10(fs) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          295,
          6
        ],
        Error: new Error()
      };
}

var Cvt_shape$5 = {
  TAG: /* F64x2 */5,
  _0: undefined
};

var num_lanes$6 = num_lanes(Cvt_shape$5);

var of_lanes$11 = of_lanes$10;

var to_lanes$11 = to_lanes$10;

function unop$5(f, x) {
  return Curry._1(of_lanes$11, List.map(f, Curry._1(to_lanes$11, x)));
}

function binop$5(f, x, y) {
  return Curry._1(of_lanes$11, List.map2(f, Curry._1(to_lanes$11, x), Curry._1(to_lanes$11, y)));
}

var all_ones$1 = Curry._1(F64.of_float, Caml_int64.float_of_bits(Int64.minus_one));

function cmp$5(f, x, y) {
  if (Curry._2(f, x, y)) {
    return all_ones$1;
  } else {
    return F64.zero;
  }
}

function splat$5(x) {
  return Curry._1(of_lanes$11, List.init(num_lanes$6, (function (i) {
                    return x;
                  })));
}

function extract_lane$1(i, s) {
  return List.nth(Curry._1(to_lanes$11, s), i);
}

function replace_lane$5(i, v, x) {
  var f = function (j, y) {
    if (j === i) {
      return x;
    } else {
      return y;
    }
  };
  return Curry._1(of_lanes$11, List.mapi(f, Curry._1(to_lanes$11, v)));
}

function eq$5(param, param$1) {
  return binop$5((function (param, param$1) {
                return cmp$5(F64.eq, param, param$1);
              }), param, param$1);
}

function ne$5(param, param$1) {
  return binop$5((function (param, param$1) {
                return cmp$5(F64.ne, param, param$1);
              }), param, param$1);
}

function lt$1(param, param$1) {
  return binop$5((function (param, param$1) {
                return cmp$5(F64.lt, param, param$1);
              }), param, param$1);
}

function le$1(param, param$1) {
  return binop$5((function (param, param$1) {
                return cmp$5(F64.le, param, param$1);
              }), param, param$1);
}

function gt$1(param, param$1) {
  return binop$5((function (param, param$1) {
                return cmp$5(F64.gt, param, param$1);
              }), param, param$1);
}

function ge$1(param, param$1) {
  return binop$5((function (param, param$1) {
                return cmp$5(F64.ge, param, param$1);
              }), param, param$1);
}

function abs$5(param) {
  return unop$5(F64.abs, param);
}

function neg$5(param) {
  return unop$5(F64.neg, param);
}

function sqrt$1(param) {
  return unop$5(F64.sqrt, param);
}

function ceil$1(param) {
  return unop$5(F64.ceil, param);
}

function floor$1(param) {
  return unop$5(F64.floor, param);
}

function trunc$1(param) {
  return unop$5(F64.trunc, param);
}

function nearest$1(param) {
  return unop$5(F64.nearest, param);
}

function add$5(param, param$1) {
  return binop$5(F64.add, param, param$1);
}

function sub$5(param, param$1) {
  return binop$5(F64.sub, param, param$1);
}

function mul$5(param, param$1) {
  return binop$5(F64.mul, param, param$1);
}

function div$1(param, param$1) {
  return binop$5(F64.div, param, param$1);
}

function min$1(param, param$1) {
  return binop$5(F64.min, param, param$1);
}

function max$1(param, param$1) {
  return binop$5(F64.max, param, param$1);
}

function pmin$1(param, param$1) {
  return binop$5((function (x, y) {
                if (Curry._2(F64.lt, y, x)) {
                  return y;
                } else {
                  return x;
                }
              }), param, param$1);
}

function pmax$1(param, param$1) {
  return binop$5((function (x, y) {
                if (Curry._2(F64.lt, x, y)) {
                  return y;
                } else {
                  return x;
                }
              }), param, param$1);
}

var F64x2 = {
  num_lanes: num_lanes$6,
  to_lanes: to_lanes$11,
  of_lanes: of_lanes$11,
  splat: splat$5,
  extract_lane: extract_lane$1,
  replace_lane: replace_lane$5,
  eq: eq$5,
  ne: ne$5,
  lt: lt$1,
  le: le$1,
  gt: gt$1,
  ge: ge$1,
  abs: abs$5,
  neg: neg$5,
  sqrt: sqrt$1,
  ceil: ceil$1,
  floor: floor$1,
  trunc: trunc$1,
  nearest: nearest$1,
  add: add$5,
  sub: sub$5,
  mul: mul$5,
  div: div$1,
  min: min$1,
  max: max$1,
  pmin: pmin$1,
  pmax: pmax$1
};

function binop$6(f, x, y) {
  return Curry._1(of_lanes$7, List.map2(f, Curry._1(to_lanes$7, x), Curry._1(to_lanes$7, y)));
}

function lognot(param) {
  var f = I64.lognot;
  return Curry._1(of_lanes$7, List.map(f, Curry._1(to_lanes$7, param)));
}

function and_(param, param$1) {
  return binop$6(I64.and_, param, param$1);
}

function or_(param, param$1) {
  return binop$6(I64.or_, param, param$1);
}

function xor(param, param$1) {
  return binop$6(I64.xor, param, param$1);
}

function andnot(param, param$1) {
  return binop$6((function (x, y) {
                return Curry._2(I64.and_, x, Curry._1(I64.lognot, y));
              }), param, param$1);
}

function bitselect(v1, v2, c) {
  var v2_andnot_c = andnot(v2, c);
  var v1_and_c = binop$6(I64.and_, v1, c);
  return binop$6(I64.or_, v1_and_c, v2_andnot_c);
}

function swizzle(v1, v2) {
  Curry._1(to_lanes$1, v1);
  var is = Curry._1(to_lanes$1, v2);
  var select = function (i) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "v128.ml",
            325,
            6
          ],
          Error: new Error()
        };
  };
  return Curry._1(of_lanes$1, List.map(select, is));
}

function shuffle(v1, v2, is) {
  var ns = Pervasives.$at(Curry._1(to_lanes$1, v1), Curry._1(to_lanes$1, v2));
  return Curry._1(of_lanes$1, List.map((function (param) {
                    return List.nth(ns, param);
                  }), is));
}

var V8x16 = {
  swizzle: swizzle,
  shuffle: shuffle
};

function narrow(to_lanes, of_lanes, sat_op, x, y) {
  var xy = Pervasives.$at(Curry._1(to_lanes, x), Curry._1(to_lanes, y));
  return Curry._1(of_lanes, List.map(sat_op, xy));
}

function narrow_s(param, param$1) {
  return narrow(to_lanes$3, of_lanes$1, I8.saturate_s, param, param$1);
}

function narrow_u(param, param$1) {
  return narrow(to_lanes$3, of_lanes$1, I8.saturate_u, param, param$1);
}

var I8x16_convert = {
  narrow_s: narrow_s,
  narrow_u: narrow_u
};

function narrow_s$1(param, param$1) {
  return narrow(to_lanes$5, of_lanes$3, I16.saturate_s, param, param$1);
}

function narrow_u$1(param, param$1) {
  return narrow(to_lanes$5, of_lanes$3, I16.saturate_u, param, param$1);
}

function ext_s(param) {
  return -1 & param;
}

function ext_u(param) {
  return 255 & param;
}

function extend(take_or_drop, ext, x) {
  return Curry._1(of_lanes$3, List.map(ext, Curry._2(take_or_drop, 8, Curry._1(to_lanes$1, x))));
}

function extend_low_s(param) {
  return extend(Lib.List.take, ext_s, param);
}

function extend_high_s(param) {
  return extend(Lib.List.drop, ext_s, param);
}

function extend_low_u(param) {
  return extend(Lib.List.take, ext_u, param);
}

function extend_high_u(param) {
  return extend(Lib.List.drop, ext_u, param);
}

function extmul_low_s(x, y) {
  return Curry._2(mul$1, extend_low_s(x), extend_low_s(y));
}

function extmul_high_s(x, y) {
  return Curry._2(mul$1, extend_high_s(x), extend_high_s(y));
}

function extmul_low_u(x, y) {
  return Curry._2(mul$1, extend_low_u(x), extend_low_u(y));
}

function extmul_high_u(x, y) {
  return Curry._2(mul$1, extend_high_u(x), extend_high_u(y));
}

function extadd(ext, x, y) {
  return Curry._1(ext, x) + Curry._1(ext, y) | 0;
}

function extadd_pairwise_s(x) {
  return Curry._1(of_lanes$3, Lib.List.pairwise((function (param, param$1) {
                    return extadd(ext_s, param, param$1);
                  }), Curry._1(to_lanes$1, x)));
}

function extadd_pairwise_u(x) {
  return Curry._1(of_lanes$3, Lib.List.pairwise((function (param, param$1) {
                    return extadd(ext_u, param, param$1);
                  }), Curry._1(to_lanes$1, x)));
}

function convert(f, v) {
  return Curry._1(of_lanes$5, List.map(f, Curry._1(to_lanes$9, v)));
}

function trunc_sat_f32x4_s(param) {
  return convert(I32_convert.trunc_sat_f32_s, param);
}

function trunc_sat_f32x4_u(param) {
  return convert(I32_convert.trunc_sat_f32_u, param);
}

function convert_zero(f, v) {
  return Curry._1(of_lanes$5, Pervasives.$at(List.map(f, Curry._1(to_lanes$11, v)), {
                  hd: I32.zero,
                  tl: {
                    hd: I32.zero,
                    tl: /* [] */0
                  }
                }));
}

function trunc_sat_f64x2_s_zero(param) {
  return convert_zero(I32_convert.trunc_sat_f64_s, param);
}

function trunc_sat_f64x2_u_zero(param) {
  return convert_zero(I32_convert.trunc_sat_f64_u, param);
}

function ext_s$1(param) {
  return -1 & param;
}

function ext_u$1(param) {
  return 65535 & param;
}

function extend$1(take_or_drop, ext, x) {
  return Curry._1(of_lanes$5, List.map(ext, Curry._2(take_or_drop, 4, Curry._1(to_lanes$3, x))));
}

function extend_low_s$1(param) {
  return extend$1(Lib.List.take, ext_s$1, param);
}

function extend_high_s$1(param) {
  return extend$1(Lib.List.drop, ext_s$1, param);
}

function extend_low_u$1(param) {
  return extend$1(Lib.List.take, ext_u$1, param);
}

function extend_high_u$1(param) {
  return extend$1(Lib.List.drop, ext_u$1, param);
}

function dot_s(x, y) {
  var xs = Curry._1(to_lanes$3, x);
  var ys = Curry._1(to_lanes$3, y);
  var dot = function (xs, ys) {
    if (xs) {
      var match = xs.tl;
      if (match && ys) {
        var match$1 = ys.tl;
        if (match$1) {
          return {
                  hd: Math.imul(xs.hd, ys.hd) + Math.imul(match.hd, match$1.hd) | 0,
                  tl: dot(match.tl, match$1.tl)
                };
        }
        
      }
      
    } else if (!ys) {
      return /* [] */0;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "v128.ml",
            402,
            16
          ],
          Error: new Error()
        };
  };
  return Curry._1(of_lanes$5, dot(xs, ys));
}

function extmul_low_s$1(x, y) {
  return Curry._2(mul$2, extend_low_s$1(x), extend_low_s$1(y));
}

function extmul_high_s$1(x, y) {
  return Curry._2(mul$2, extend_high_s$1(x), extend_high_s$1(y));
}

function extmul_low_u$1(x, y) {
  return Curry._2(mul$2, extend_low_u$1(x), extend_low_u$1(y));
}

function extmul_high_u$1(x, y) {
  return Curry._2(mul$2, extend_high_u$1(x), extend_high_u$1(y));
}

function extadd$1(ext, x, y) {
  return Curry._1(ext, x) + Curry._1(ext, y) | 0;
}

function extadd_pairwise_s$1(x) {
  return Curry._1(of_lanes$5, Lib.List.pairwise((function (param, param$1) {
                    return extadd$1(ext_s$1, param, param$1);
                  }), Curry._1(to_lanes$3, x)));
}

function extadd_pairwise_u$1(x) {
  return Curry._1(of_lanes$5, Lib.List.pairwise((function (param, param$1) {
                    return extadd$1(ext_u$1, param, param$1);
                  }), Curry._1(to_lanes$3, x)));
}

function ext_s$2(param) {
  return Caml_int64.and_(Caml_int64.neg_one, param);
}

function ext_u$2(param) {
  return Caml_int64.and_([
              0,
              4294967295
            ], param);
}

function extend$2(take_or_drop, ext, x) {
  return Curry._1(of_lanes$7, List.map((function (i32) {
                    return Curry._1(ext, Caml_int64.of_int32(i32));
                  }), Curry._2(take_or_drop, 2, Curry._1(to_lanes$5, x))));
}

function extend_low_s$2(param) {
  return extend$2(Lib.List.take, ext_s$2, param);
}

function extend_high_s$2(param) {
  return extend$2(Lib.List.drop, ext_s$2, param);
}

function extend_low_u$2(param) {
  return extend$2(Lib.List.take, ext_u$2, param);
}

function extend_high_u$2(param) {
  return extend$2(Lib.List.drop, ext_u$2, param);
}

function extmul_low_s$2(x, y) {
  return Curry._2(mul$3, extend_low_s$2(x), extend_low_s$2(y));
}

function extmul_high_s$2(x, y) {
  return Curry._2(mul$3, extend_high_s$2(x), extend_high_s$2(y));
}

function extmul_low_u$2(x, y) {
  return Curry._2(mul$3, extend_low_u$2(x), extend_low_u$2(y));
}

function extmul_high_u$2(x, y) {
  return Curry._2(mul$3, extend_high_u$2(x), extend_high_u$2(y));
}

function convert$1(f, v) {
  return Curry._1(of_lanes$9, List.map(f, Curry._1(to_lanes$5, v)));
}

function convert_i32x4_s(param) {
  return convert$1(F32_convert.convert_i32_s, param);
}

function convert_i32x4_u(param) {
  return convert$1(F32_convert.convert_i32_u, param);
}

function demote_f64x2_zero(v) {
  return Curry._1(of_lanes$9, Pervasives.$at(List.map(F32_convert.demote_f64, Curry._1(to_lanes$11, v)), {
                  hd: F32.zero,
                  tl: {
                    hd: F32.zero,
                    tl: /* [] */0
                  }
                }));
}

function convert$2(f, v) {
  return Curry._1(of_lanes$11, List.map(f, Lib.List.take(2, Curry._1(to_lanes$5, v))));
}

function convert_i32x4_s$1(param) {
  return convert$2(F64_convert.convert_i32_s, param);
}

function convert_i32x4_u$1(param) {
  return convert$2(F64_convert.convert_i32_u, param);
}

function promote_low_f32x4(v) {
  return Curry._1(of_lanes$11, List.map(F64_convert.promote_f32, Lib.List.take(2, Curry._1(to_lanes$9, v))));
}

function to_string(s) {
  return $$String.concat(" ", List.map(I32.to_string_s, Curry._1(to_lanes$5, s)));
}

function to_hex_string(s) {
  return $$String.concat(" ", List.map(I32.to_hex_string, Curry._1(to_lanes$5, s)));
}

function of_strings(shape, ss) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "v128.ml",
          469,
          2
        ],
        Error: new Error()
      };
}

function string_of_shape(param) {
  switch (param.TAG | 0) {
    case /* I8x16 */0 :
        return "i8x16";
    case /* I16x8 */1 :
        return "i16x8";
    case /* I32x4 */2 :
        return "i32x4";
    case /* I64x2 */3 :
        return "i64x2";
    case /* F32x4 */4 :
        return "f32x4";
    case /* F64x2 */5 :
        return "f64x2";
    
  }
}

var bitwidth = 128;

var V1x128 = {
  lognot: lognot,
  and_: and_,
  or_: or_,
  xor: xor,
  andnot: andnot,
  bitselect: bitselect
};

var I16x8_convert = {
  narrow_s: narrow_s$1,
  narrow_u: narrow_u$1,
  extend_low_s: extend_low_s,
  extend_high_s: extend_high_s,
  extend_low_u: extend_low_u,
  extend_high_u: extend_high_u,
  extmul_low_s: extmul_low_s,
  extmul_high_s: extmul_high_s,
  extmul_low_u: extmul_low_u,
  extmul_high_u: extmul_high_u,
  extadd_pairwise_s: extadd_pairwise_s,
  extadd_pairwise_u: extadd_pairwise_u
};

var I32x4_convert = {
  trunc_sat_f32x4_s: trunc_sat_f32x4_s,
  trunc_sat_f32x4_u: trunc_sat_f32x4_u,
  trunc_sat_f64x2_s_zero: trunc_sat_f64x2_s_zero,
  trunc_sat_f64x2_u_zero: trunc_sat_f64x2_u_zero,
  extend_low_s: extend_low_s$1,
  extend_high_s: extend_high_s$1,
  extend_low_u: extend_low_u$1,
  extend_high_u: extend_high_u$1,
  dot_s: dot_s,
  extmul_low_s: extmul_low_s$1,
  extmul_high_s: extmul_high_s$1,
  extmul_low_u: extmul_low_u$1,
  extmul_high_u: extmul_high_u$1,
  extadd_pairwise_s: extadd_pairwise_s$1,
  extadd_pairwise_u: extadd_pairwise_u$1
};

var I64x2_convert = {
  extend_low_s: extend_low_s$2,
  extend_high_s: extend_high_s$2,
  extend_low_u: extend_low_u$2,
  extend_high_u: extend_high_u$2,
  extmul_low_s: extmul_low_s$2,
  extmul_high_s: extmul_high_s$2,
  extmul_low_u: extmul_low_u$2,
  extmul_high_u: extmul_high_u$2
};

var F32x4_convert = {
  convert_i32x4_s: convert_i32x4_s,
  convert_i32x4_u: convert_i32x4_u,
  demote_f64x2_zero: demote_f64x2_zero
};

var F64x2_convert = {
  promote_low_f32x4: promote_low_f32x4,
  convert_i32x4_s: convert_i32x4_s$1,
  convert_i32x4_u: convert_i32x4_u$1
};

export {
  bitwidth ,
  num_lanes ,
  type_of_lane ,
  string_of_shape ,
  zero ,
  of_bits ,
  to_bits ,
  to_string ,
  to_hex_string ,
  of_strings ,
  I8x16 ,
  I16x8 ,
  I32x4 ,
  I64x2 ,
  F32x4 ,
  F64x2 ,
  V1x128 ,
  V8x16 ,
  I8x16_convert ,
  I16x8_convert ,
  I32x4_convert ,
  I64x2_convert ,
  F32x4_convert ,
  F64x2_convert ,
  
}
/* zero Not a pure module */
