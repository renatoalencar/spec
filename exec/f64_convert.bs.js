// Generated by ReScript, PLEASE EDIT WITH CARE

import * as F32 from "./f32.bs.js";
import * as F64 from "./f64.bs.js";
import * as Caml from "rescript/lib/es6/caml.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Int64 from "rescript/lib/es6/int64.js";
import * as Caml_int64 from "rescript/lib/es6/caml_int64.js";
import * as I64_convert from "./i64_convert.bs.js";

function promote_f32(x) {
  var xf = Curry._1(F32.to_float, x);
  if (xf === xf) {
    return Curry._1(F64.of_float, xf);
  }
  var nan32bits = I64_convert.extend_i32_u(Curry._1(F32.to_bits, x));
  var sign_field = Caml_int64.lsl_(Caml_int64.lsr_(nan32bits, 31), 63);
  var significand_field = Caml_int64.lsr_(Caml_int64.lsl_(nan32bits, 41), 12);
  var fields = Caml_int64.or_(sign_field, significand_field);
  return Curry._1(F64.of_bits, Caml_int64.or_([
                  2146959360,
                  0
                ], fields));
}

function convert_i32_s(x) {
  return Curry._1(F64.of_float, x);
}

function convert_i32_u(x) {
  return Curry._1(F64.of_float, Caml_int64.to_float(Caml_int64.and_(Caml_int64.of_int32(x), [
                      0,
                      4294967295
                    ])));
}

function convert_i64_s(x) {
  return Curry._1(F64.of_float, Caml_int64.to_float(x));
}

function convert_i64_u(x) {
  return Curry._1(F64.of_float, Caml.i64_ge(x, Int64.zero) ? Caml_int64.to_float(x) : Caml_int64.to_float(Caml_int64.or_(Caml_int64.lsr_(x, 1), Caml_int64.and_(x, Caml_int64.one))) * 2.0);
}

var reinterpret_i64 = F64.of_bits;

export {
  promote_f32 ,
  convert_i32_s ,
  convert_i32_u ,
  convert_i64_s ,
  convert_i64_u ,
  reinterpret_i64 ,
  
}
/* F32 Not a pure module */
