// Generated by ReScript, PLEASE EDIT WITH CARE

import * as V128 from "./v128.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Values from "../syntax/values.bs.js";

function eval_testop(param) {
  var op = param._0;
  var f;
  switch (op.TAG | 0) {
    case /* I8x16 */0 :
        f = V128.I8x16.all_true;
        break;
    case /* I16x8 */1 :
        f = V128.I16x8.all_true;
        break;
    case /* I32x4 */2 :
        f = V128.I32x4.all_true;
        break;
    case /* I64x2 */3 :
        f = V128.I64x2.all_true;
        break;
    case /* F32x4 */4 :
    case /* F64x2 */5 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "eval_vec.ml",
                16,
                13
              ],
              Error: new Error()
            };
    
  }
  return function (v) {
    return Curry._1(f, Values.V128Vec.of_vec(1, v));
  };
}

function eval_unop(param) {
  var op = param._0;
  var f;
  var exit = 0;
  switch (op.TAG | 0) {
    case /* I8x16 */0 :
        switch (op._0) {
          case /* Abs */0 :
              f = V128.I8x16.abs;
              break;
          case /* Neg */1 :
              f = V128.I8x16.neg;
              break;
          case /* Popcnt */2 :
              f = V128.I8x16.popcnt;
              break;
          
        }
        break;
    case /* I16x8 */1 :
        switch (op._0) {
          case /* Abs */0 :
              f = V128.I16x8.abs;
              break;
          case /* Neg */1 :
              f = V128.I16x8.neg;
              break;
          case /* Popcnt */2 :
              exit = 1;
              break;
          
        }
        break;
    case /* I32x4 */2 :
        switch (op._0) {
          case /* Abs */0 :
              f = V128.I32x4.abs;
              break;
          case /* Neg */1 :
              f = V128.I32x4.neg;
              break;
          case /* Popcnt */2 :
              exit = 1;
              break;
          
        }
        break;
    case /* I64x2 */3 :
        switch (op._0) {
          case /* Abs */0 :
              f = V128.I64x2.abs;
              break;
          case /* Neg */1 :
              f = V128.I64x2.neg;
              break;
          case /* Popcnt */2 :
              exit = 1;
              break;
          
        }
        break;
    case /* F32x4 */4 :
        switch (op._0) {
          case /* Abs */0 :
              f = V128.F32x4.abs;
              break;
          case /* Neg */1 :
              f = V128.F32x4.neg;
              break;
          case /* Sqrt */2 :
              f = V128.F32x4.sqrt;
              break;
          case /* Ceil */3 :
              f = V128.F32x4.ceil;
              break;
          case /* Floor */4 :
              f = V128.F32x4.floor;
              break;
          case /* Trunc */5 :
              f = V128.F32x4.trunc;
              break;
          case /* Nearest */6 :
              f = V128.F32x4.nearest;
              break;
          
        }
        break;
    case /* F64x2 */5 :
        switch (op._0) {
          case /* Abs */0 :
              f = V128.F64x2.abs;
              break;
          case /* Neg */1 :
              f = V128.F64x2.neg;
              break;
          case /* Sqrt */2 :
              f = V128.F64x2.sqrt;
              break;
          case /* Ceil */3 :
              f = V128.F64x2.ceil;
              break;
          case /* Floor */4 :
              f = V128.F64x2.floor;
              break;
          case /* Trunc */5 :
              f = V128.F64x2.trunc;
              break;
          case /* Nearest */6 :
              f = V128.F64x2.nearest;
              break;
          
        }
        break;
    
  }
  if (exit === 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "eval_vec.ml",
            44,
            13
          ],
          Error: new Error()
        };
  }
  return function (v) {
    return Values.V128Vec.to_vec(Curry._1(f, Values.V128Vec.of_vec(1, v)));
  };
}

function eval_binop(param) {
  var op = param._0;
  var f;
  var exit = 0;
  switch (op.TAG | 0) {
    case /* I8x16 */0 :
        var is = op._0;
        if (typeof is === "number") {
          switch (is) {
            case /* Add */0 :
                f = V128.I8x16.add;
                break;
            case /* Sub */1 :
                f = V128.I8x16.sub;
                break;
            case /* MinS */3 :
                f = V128.I8x16.min_s;
                break;
            case /* MinU */4 :
                f = V128.I8x16.min_u;
                break;
            case /* MaxS */5 :
                f = V128.I8x16.max_s;
                break;
            case /* MaxU */6 :
                f = V128.I8x16.max_u;
                break;
            case /* AvgrU */7 :
                f = V128.I8x16.avgr_u;
                break;
            case /* AddSatS */8 :
                f = V128.I8x16.add_sat_s;
                break;
            case /* AddSatU */9 :
                f = V128.I8x16.add_sat_u;
                break;
            case /* SubSatS */10 :
                f = V128.I8x16.sub_sat_s;
                break;
            case /* SubSatU */11 :
                f = V128.I8x16.sub_sat_u;
                break;
            case /* Mul */2 :
            case /* DotS */12 :
            case /* Q15MulRSatS */13 :
            case /* ExtMulLowS */14 :
            case /* ExtMulHighS */15 :
            case /* ExtMulLowU */16 :
            case /* ExtMulHighU */17 :
                exit = 1;
                break;
            case /* Swizzle */18 :
                f = V128.V8x16.swizzle;
                break;
            case /* NarrowS */19 :
                f = V128.I8x16_convert.narrow_s;
                break;
            case /* NarrowU */20 :
                f = V128.I8x16_convert.narrow_u;
                break;
            
          }
        } else {
          var is$1 = is._0;
          f = (function (a, b) {
              return V128.V8x16.shuffle(a, b, is$1);
            });
        }
        break;
    case /* I16x8 */1 :
        var match = op._0;
        if (typeof match === "number") {
          switch (match) {
            case /* Add */0 :
                f = V128.I16x8.add;
                break;
            case /* Sub */1 :
                f = V128.I16x8.sub;
                break;
            case /* Mul */2 :
                f = V128.I16x8.mul;
                break;
            case /* MinS */3 :
                f = V128.I16x8.min_s;
                break;
            case /* MinU */4 :
                f = V128.I16x8.min_u;
                break;
            case /* MaxS */5 :
                f = V128.I16x8.max_s;
                break;
            case /* MaxU */6 :
                f = V128.I16x8.max_u;
                break;
            case /* AvgrU */7 :
                f = V128.I16x8.avgr_u;
                break;
            case /* AddSatS */8 :
                f = V128.I16x8.add_sat_s;
                break;
            case /* AddSatU */9 :
                f = V128.I16x8.add_sat_u;
                break;
            case /* SubSatS */10 :
                f = V128.I16x8.sub_sat_s;
                break;
            case /* SubSatU */11 :
                f = V128.I16x8.sub_sat_u;
                break;
            case /* Q15MulRSatS */13 :
                f = V128.I16x8.q15mulr_sat_s;
                break;
            case /* ExtMulLowS */14 :
                f = V128.I16x8_convert.extmul_low_s;
                break;
            case /* ExtMulHighS */15 :
                f = V128.I16x8_convert.extmul_high_s;
                break;
            case /* ExtMulLowU */16 :
                f = V128.I16x8_convert.extmul_low_u;
                break;
            case /* ExtMulHighU */17 :
                f = V128.I16x8_convert.extmul_high_u;
                break;
            case /* DotS */12 :
            case /* Swizzle */18 :
                exit = 1;
                break;
            case /* NarrowS */19 :
                f = V128.I16x8_convert.narrow_s;
                break;
            case /* NarrowU */20 :
                f = V128.I16x8_convert.narrow_u;
                break;
            
          }
        } else {
          exit = 1;
        }
        break;
    case /* I32x4 */2 :
        var match$1 = op._0;
        if (typeof match$1 === "number") {
          switch (match$1) {
            case /* Add */0 :
                f = V128.I32x4.add;
                break;
            case /* Sub */1 :
                f = V128.I32x4.sub;
                break;
            case /* Mul */2 :
                f = V128.I32x4.mul;
                break;
            case /* MinS */3 :
                f = V128.I32x4.min_s;
                break;
            case /* MinU */4 :
                f = V128.I32x4.min_u;
                break;
            case /* MaxS */5 :
                f = V128.I32x4.max_s;
                break;
            case /* MaxU */6 :
                f = V128.I32x4.max_u;
                break;
            case /* DotS */12 :
                f = V128.I32x4_convert.dot_s;
                break;
            case /* ExtMulLowS */14 :
                f = V128.I32x4_convert.extmul_low_s;
                break;
            case /* ExtMulHighS */15 :
                f = V128.I32x4_convert.extmul_high_s;
                break;
            case /* ExtMulLowU */16 :
                f = V128.I32x4_convert.extmul_low_u;
                break;
            case /* ExtMulHighU */17 :
                f = V128.I32x4_convert.extmul_high_u;
                break;
            case /* AvgrU */7 :
            case /* AddSatS */8 :
            case /* AddSatU */9 :
            case /* SubSatS */10 :
            case /* SubSatU */11 :
            case /* Q15MulRSatS */13 :
            case /* Swizzle */18 :
            case /* NarrowS */19 :
            case /* NarrowU */20 :
                exit = 1;
                break;
            
          }
        } else {
          exit = 1;
        }
        break;
    case /* I64x2 */3 :
        var match$2 = op._0;
        if (typeof match$2 === "number") {
          switch (match$2) {
            case /* Add */0 :
                f = V128.I64x2.add;
                break;
            case /* Sub */1 :
                f = V128.I64x2.sub;
                break;
            case /* Mul */2 :
                f = V128.I64x2.mul;
                break;
            case /* ExtMulLowS */14 :
                f = V128.I64x2_convert.extmul_low_s;
                break;
            case /* ExtMulHighS */15 :
                f = V128.I64x2_convert.extmul_high_s;
                break;
            case /* ExtMulLowU */16 :
                f = V128.I64x2_convert.extmul_low_u;
                break;
            case /* ExtMulHighU */17 :
                f = V128.I64x2_convert.extmul_high_u;
                break;
            case /* MinS */3 :
            case /* MinU */4 :
            case /* MaxS */5 :
            case /* MaxU */6 :
            case /* AvgrU */7 :
            case /* AddSatS */8 :
            case /* AddSatU */9 :
            case /* SubSatS */10 :
            case /* SubSatU */11 :
            case /* DotS */12 :
            case /* Q15MulRSatS */13 :
            case /* Swizzle */18 :
            case /* NarrowS */19 :
            case /* NarrowU */20 :
                exit = 1;
                break;
            
          }
        } else {
          exit = 1;
        }
        break;
    case /* F32x4 */4 :
        switch (op._0) {
          case /* Add */0 :
              f = V128.F32x4.add;
              break;
          case /* Sub */1 :
              f = V128.F32x4.sub;
              break;
          case /* Mul */2 :
              f = V128.F32x4.mul;
              break;
          case /* Div */3 :
              f = V128.F32x4.div;
              break;
          case /* Min */4 :
              f = V128.F32x4.min;
              break;
          case /* Max */5 :
              f = V128.F32x4.max;
              break;
          case /* Pmin */6 :
              f = V128.F32x4.pmin;
              break;
          case /* Pmax */7 :
              f = V128.F32x4.pmax;
              break;
          
        }
        break;
    case /* F64x2 */5 :
        switch (op._0) {
          case /* Add */0 :
              f = V128.F64x2.add;
              break;
          case /* Sub */1 :
              f = V128.F64x2.sub;
              break;
          case /* Mul */2 :
              f = V128.F64x2.mul;
              break;
          case /* Div */3 :
              f = V128.F64x2.div;
              break;
          case /* Min */4 :
              f = V128.F64x2.min;
              break;
          case /* Max */5 :
              f = V128.F64x2.max;
              break;
          case /* Pmin */6 :
              f = V128.F64x2.pmin;
              break;
          case /* Pmax */7 :
              f = V128.F64x2.pmax;
              break;
          
        }
        break;
    
  }
  if (exit === 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "eval_vec.ml",
            118,
            13
          ],
          Error: new Error()
        };
  }
  return function (v1, v2) {
    return Values.V128Vec.to_vec(Curry._2(f, Values.V128Vec.of_vec(1, v1), Values.V128Vec.of_vec(2, v2)));
  };
}

function eval_relop(param) {
  var op = param._0;
  var f;
  var exit = 0;
  switch (op.TAG | 0) {
    case /* I8x16 */0 :
        switch (op._0) {
          case /* Eq */0 :
              f = V128.I8x16.eq;
              break;
          case /* Ne */1 :
              f = V128.I8x16.ne;
              break;
          case /* LtS */2 :
              f = V128.I8x16.lt_s;
              break;
          case /* LtU */3 :
              f = V128.I8x16.lt_u;
              break;
          case /* LeS */4 :
              f = V128.I8x16.le_s;
              break;
          case /* LeU */5 :
              f = V128.I8x16.le_u;
              break;
          case /* GtS */6 :
              f = V128.I8x16.gt_s;
              break;
          case /* GtU */7 :
              f = V128.I8x16.gt_u;
              break;
          case /* GeS */8 :
              f = V128.I8x16.ge_s;
              break;
          case /* GeU */9 :
              f = V128.I8x16.ge_u;
              break;
          
        }
        break;
    case /* I16x8 */1 :
        switch (op._0) {
          case /* Eq */0 :
              f = V128.I16x8.eq;
              break;
          case /* Ne */1 :
              f = V128.I16x8.ne;
              break;
          case /* LtS */2 :
              f = V128.I16x8.lt_s;
              break;
          case /* LtU */3 :
              f = V128.I16x8.lt_u;
              break;
          case /* LeS */4 :
              f = V128.I16x8.le_s;
              break;
          case /* LeU */5 :
              f = V128.I16x8.le_u;
              break;
          case /* GtS */6 :
              f = V128.I16x8.gt_s;
              break;
          case /* GtU */7 :
              f = V128.I16x8.gt_u;
              break;
          case /* GeS */8 :
              f = V128.I16x8.ge_s;
              break;
          case /* GeU */9 :
              f = V128.I16x8.ge_u;
              break;
          
        }
        break;
    case /* I32x4 */2 :
        switch (op._0) {
          case /* Eq */0 :
              f = V128.I32x4.eq;
              break;
          case /* Ne */1 :
              f = V128.I32x4.ne;
              break;
          case /* LtS */2 :
              f = V128.I32x4.lt_s;
              break;
          case /* LtU */3 :
              f = V128.I32x4.lt_u;
              break;
          case /* LeS */4 :
              f = V128.I32x4.le_s;
              break;
          case /* LeU */5 :
              f = V128.I32x4.le_u;
              break;
          case /* GtS */6 :
              f = V128.I32x4.gt_s;
              break;
          case /* GtU */7 :
              f = V128.I32x4.gt_u;
              break;
          case /* GeS */8 :
              f = V128.I32x4.ge_s;
              break;
          case /* GeU */9 :
              f = V128.I32x4.ge_u;
              break;
          
        }
        break;
    case /* I64x2 */3 :
        switch (op._0) {
          case /* Eq */0 :
              f = V128.I64x2.eq;
              break;
          case /* Ne */1 :
              f = V128.I64x2.ne;
              break;
          case /* LtS */2 :
              f = V128.I64x2.lt_s;
              break;
          case /* LeS */4 :
              f = V128.I64x2.le_s;
              break;
          case /* GtS */6 :
              f = V128.I64x2.gt_s;
              break;
          case /* GeS */8 :
              f = V128.I64x2.ge_s;
              break;
          case /* LtU */3 :
          case /* LeU */5 :
          case /* GtU */7 :
          case /* GeU */9 :
              exit = 1;
              break;
          
        }
        break;
    case /* F32x4 */4 :
        switch (op._0) {
          case /* Eq */0 :
              f = V128.F32x4.eq;
              break;
          case /* Ne */1 :
              f = V128.F32x4.ne;
              break;
          case /* Lt */2 :
              f = V128.F32x4.lt;
              break;
          case /* Le */3 :
              f = V128.F32x4.le;
              break;
          case /* Gt */4 :
              f = V128.F32x4.gt;
              break;
          case /* Ge */5 :
              f = V128.F32x4.ge;
              break;
          
        }
        break;
    case /* F64x2 */5 :
        switch (op._0) {
          case /* Eq */0 :
              f = V128.F64x2.eq;
              break;
          case /* Ne */1 :
              f = V128.F64x2.ne;
              break;
          case /* Lt */2 :
              f = V128.F64x2.lt;
              break;
          case /* Le */3 :
              f = V128.F64x2.le;
              break;
          case /* Gt */4 :
              f = V128.F64x2.gt;
              break;
          case /* Ge */5 :
              f = V128.F64x2.ge;
              break;
          
        }
        break;
    
  }
  if (exit === 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "eval_vec.ml",
            171,
            13
          ],
          Error: new Error()
        };
  }
  return function (v1, v2) {
    return Values.V128Vec.to_vec(Curry._2(f, Values.V128Vec.of_vec(1, v1), Values.V128Vec.of_vec(2, v2)));
  };
}

function eval_cvtop(param) {
  var op = param._0;
  var f;
  var exit = 0;
  switch (op.TAG | 0) {
    case /* I8x16 */0 :
        exit = 1;
        break;
    case /* I16x8 */1 :
        switch (op._0) {
          case /* ExtendLowS */0 :
              f = V128.I16x8_convert.extend_low_s;
              break;
          case /* ExtendLowU */1 :
              f = V128.I16x8_convert.extend_low_u;
              break;
          case /* ExtendHighS */2 :
              f = V128.I16x8_convert.extend_high_s;
              break;
          case /* ExtendHighU */3 :
              f = V128.I16x8_convert.extend_high_u;
              break;
          case /* ExtAddPairwiseS */4 :
              f = V128.I16x8_convert.extadd_pairwise_s;
              break;
          case /* ExtAddPairwiseU */5 :
              f = V128.I16x8_convert.extadd_pairwise_u;
              break;
          case /* TruncSatSF32x4 */6 :
          case /* TruncSatUF32x4 */7 :
          case /* TruncSatSZeroF64x2 */8 :
          case /* TruncSatUZeroF64x2 */9 :
              exit = 1;
              break;
          
        }
        break;
    case /* I32x4 */2 :
        switch (op._0) {
          case /* ExtendLowS */0 :
              f = V128.I32x4_convert.extend_low_s;
              break;
          case /* ExtendLowU */1 :
              f = V128.I32x4_convert.extend_low_u;
              break;
          case /* ExtendHighS */2 :
              f = V128.I32x4_convert.extend_high_s;
              break;
          case /* ExtendHighU */3 :
              f = V128.I32x4_convert.extend_high_u;
              break;
          case /* ExtAddPairwiseS */4 :
              f = V128.I32x4_convert.extadd_pairwise_s;
              break;
          case /* ExtAddPairwiseU */5 :
              f = V128.I32x4_convert.extadd_pairwise_u;
              break;
          case /* TruncSatSF32x4 */6 :
              f = V128.I32x4_convert.trunc_sat_f32x4_s;
              break;
          case /* TruncSatUF32x4 */7 :
              f = V128.I32x4_convert.trunc_sat_f32x4_u;
              break;
          case /* TruncSatSZeroF64x2 */8 :
              f = V128.I32x4_convert.trunc_sat_f64x2_s_zero;
              break;
          case /* TruncSatUZeroF64x2 */9 :
              f = V128.I32x4_convert.trunc_sat_f64x2_u_zero;
              break;
          
        }
        break;
    case /* I64x2 */3 :
        switch (op._0) {
          case /* ExtendLowS */0 :
              f = V128.I64x2_convert.extend_low_s;
              break;
          case /* ExtendLowU */1 :
              f = V128.I64x2_convert.extend_low_u;
              break;
          case /* ExtendHighS */2 :
              f = V128.I64x2_convert.extend_high_s;
              break;
          case /* ExtendHighU */3 :
              f = V128.I64x2_convert.extend_high_u;
              break;
          case /* ExtAddPairwiseS */4 :
          case /* ExtAddPairwiseU */5 :
          case /* TruncSatSF32x4 */6 :
          case /* TruncSatUF32x4 */7 :
          case /* TruncSatSZeroF64x2 */8 :
          case /* TruncSatUZeroF64x2 */9 :
              exit = 1;
              break;
          
        }
        break;
    case /* F32x4 */4 :
        switch (op._0) {
          case /* DemoteZeroF64x2 */0 :
              f = V128.F32x4_convert.demote_f64x2_zero;
              break;
          case /* PromoteLowF32x4 */1 :
              exit = 1;
              break;
          case /* ConvertSI32x4 */2 :
              f = V128.F32x4_convert.convert_i32x4_s;
              break;
          case /* ConvertUI32x4 */3 :
              f = V128.F32x4_convert.convert_i32x4_u;
              break;
          
        }
        break;
    case /* F64x2 */5 :
        switch (op._0) {
          case /* DemoteZeroF64x2 */0 :
              exit = 1;
              break;
          case /* PromoteLowF32x4 */1 :
              f = V128.F64x2_convert.promote_low_f32x4;
              break;
          case /* ConvertSI32x4 */2 :
              f = V128.F64x2_convert.convert_i32x4_s;
              break;
          case /* ConvertUI32x4 */3 :
              f = V128.F64x2_convert.convert_i32x4_u;
              break;
          
        }
        break;
    
  }
  if (exit === 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "eval_vec.ml",
            202,
            13
          ],
          Error: new Error()
        };
  }
  return function (v) {
    return Values.V128Vec.to_vec(Curry._1(f, Values.V128Vec.of_vec(1, v)));
  };
}

function eval_shiftop(param) {
  var op = param._0;
  var f;
  switch (op.TAG | 0) {
    case /* I8x16 */0 :
        switch (op._0) {
          case /* Shl */0 :
              f = V128.I8x16.shl;
              break;
          case /* ShrS */1 :
              f = V128.I8x16.shr_s;
              break;
          case /* ShrU */2 :
              f = V128.I8x16.shr_u;
              break;
          
        }
        break;
    case /* I16x8 */1 :
        switch (op._0) {
          case /* Shl */0 :
              f = V128.I16x8.shl;
              break;
          case /* ShrS */1 :
              f = V128.I16x8.shr_s;
              break;
          case /* ShrU */2 :
              f = V128.I16x8.shr_u;
              break;
          
        }
        break;
    case /* I32x4 */2 :
        switch (op._0) {
          case /* Shl */0 :
              f = V128.I32x4.shl;
              break;
          case /* ShrS */1 :
              f = V128.I32x4.shr_s;
              break;
          case /* ShrU */2 :
              f = V128.I32x4.shr_u;
              break;
          
        }
        break;
    case /* I64x2 */3 :
        switch (op._0) {
          case /* Shl */0 :
              f = V128.I64x2.shl;
              break;
          case /* ShrS */1 :
              f = V128.I64x2.shr_s;
              break;
          case /* ShrU */2 :
              f = V128.I64x2.shr_u;
              break;
          
        }
        break;
    case /* F32x4 */4 :
    case /* F64x2 */5 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "eval_vec.ml",
                219,
                13
              ],
              Error: new Error()
            };
    
  }
  return function (v, n) {
    return Values.V128Vec.to_vec(Curry._2(f, Values.V128Vec.of_vec(1, v), Values.I32Num.of_num(2, n)));
  };
}

function eval_bitmaskop(param) {
  var partial_arg = param._0;
  return function (param) {
    var f;
    switch (partial_arg.TAG | 0) {
      case /* I8x16 */0 :
          f = V128.I8x16.bitmask;
          break;
      case /* I16x8 */1 :
          f = V128.I16x8.bitmask;
          break;
      case /* I32x4 */2 :
          f = V128.I32x4.bitmask;
          break;
      case /* I64x2 */3 :
          f = V128.I64x2.bitmask;
          break;
      case /* F32x4 */4 :
      case /* F64x2 */5 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "eval_vec.ml",
                  228,
                  13
                ],
                Error: new Error()
              };
      
    }
    return {
            TAG: /* I32 */0,
            _0: Curry._1(f, Values.V128Vec.of_vec(1, param))
          };
  };
}

function eval_vtestop(param) {
  var f = V128.I8x16.any_true;
  return function (v) {
    return Curry._1(f, Values.V128Vec.of_vec(1, v));
  };
}

function eval_vunop(param) {
  var f = V128.V1x128.lognot;
  return function (v) {
    return Values.V128Vec.to_vec(Curry._1(f, Values.V128Vec.of_vec(1, v)));
  };
}

function eval_vbinop(param) {
  var op = param._0;
  var f;
  switch (op) {
    case /* And */0 :
        f = V128.V1x128.and_;
        break;
    case /* Or */1 :
        f = V128.V1x128.or_;
        break;
    case /* Xor */2 :
        f = V128.V1x128.xor;
        break;
    case /* AndNot */3 :
        f = V128.V1x128.andnot;
        break;
    
  }
  return function (v1, v2) {
    return Values.V128Vec.to_vec(Curry._2(f, Values.V128Vec.of_vec(1, v1), Values.V128Vec.of_vec(2, v2)));
  };
}

function eval_vternop(param) {
  var f = V128.V1x128.bitselect;
  return function (v1, v2, v3) {
    return Values.V128Vec.to_vec(Curry._3(f, Values.V128Vec.of_vec(1, v1), Values.V128Vec.of_vec(2, v2), Values.V128Vec.of_vec(3, v3)));
  };
}

function eval_splatop(param) {
  var partial_arg = param._0;
  return function (param) {
    var tmp;
    switch (partial_arg.TAG | 0) {
      case /* I8x16 */0 :
          tmp = Curry._1(V128.I8x16.splat, Values.I32Num.of_num(1, param));
          break;
      case /* I16x8 */1 :
          tmp = Curry._1(V128.I16x8.splat, Values.I32Num.of_num(1, param));
          break;
      case /* I32x4 */2 :
          tmp = Curry._1(V128.I32x4.splat, Values.I32Num.of_num(1, param));
          break;
      case /* I64x2 */3 :
          tmp = Curry._1(V128.I64x2.splat, Values.I64Num.of_num(1, param));
          break;
      case /* F32x4 */4 :
          tmp = Curry._1(V128.F32x4.splat, Values.F32Num.of_num(1, param));
          break;
      case /* F64x2 */5 :
          tmp = Curry._1(V128.F64x2.splat, Values.F64Num.of_num(1, param));
          break;
      
    }
    return Values.V128Vec.to_vec(tmp);
  };
}

function eval_extractop(param) {
  var partial_arg = param._0;
  return function (param) {
    var v128 = Values.V128Vec.of_vec(1, param);
    switch (partial_arg.TAG | 0) {
      case /* I8x16 */0 :
          var match = partial_arg._0;
          var i = match._0;
          if (match._1) {
            return {
                    TAG: /* I32 */0,
                    _0: Curry._2(V128.I8x16.extract_lane_u, i, v128)
                  };
          } else {
            return {
                    TAG: /* I32 */0,
                    _0: Curry._2(V128.I8x16.extract_lane_s, i, v128)
                  };
          }
      case /* I16x8 */1 :
          var match$1 = partial_arg._0;
          var i$1 = match$1._0;
          if (match$1._1) {
            return {
                    TAG: /* I32 */0,
                    _0: Curry._2(V128.I16x8.extract_lane_u, i$1, v128)
                  };
          } else {
            return {
                    TAG: /* I32 */0,
                    _0: Curry._2(V128.I16x8.extract_lane_s, i$1, v128)
                  };
          }
      case /* I32x4 */2 :
          return {
                  TAG: /* I32 */0,
                  _0: Curry._2(V128.I32x4.extract_lane_u, partial_arg._0._0, v128)
                };
      case /* I64x2 */3 :
          return {
                  TAG: /* I64 */1,
                  _0: Curry._2(V128.I64x2.extract_lane_u, partial_arg._0._0, v128)
                };
      case /* F32x4 */4 :
          return {
                  TAG: /* F32 */2,
                  _0: Curry._2(V128.F32x4.extract_lane, partial_arg._0._0, v128)
                };
      case /* F64x2 */5 :
          return {
                  TAG: /* F64 */3,
                  _0: Curry._2(V128.F64x2.extract_lane, partial_arg._0._0, v128)
                };
      
    }
  };
}

function eval_replaceop(param) {
  var partial_arg = param._0;
  return function (param, param$1) {
    var v128 = Values.V128Vec.of_vec(1, param);
    var tmp;
    switch (partial_arg.TAG | 0) {
      case /* I8x16 */0 :
          tmp = Curry._3(V128.I8x16.replace_lane, partial_arg._0._0, v128, Values.I32Num.of_num(1, param$1));
          break;
      case /* I16x8 */1 :
          tmp = Curry._3(V128.I16x8.replace_lane, partial_arg._0._0, v128, Values.I32Num.of_num(1, param$1));
          break;
      case /* I32x4 */2 :
          tmp = Curry._3(V128.I32x4.replace_lane, partial_arg._0._0, v128, Values.I32Num.of_num(1, param$1));
          break;
      case /* I64x2 */3 :
          tmp = Curry._3(V128.I64x2.replace_lane, partial_arg._0._0, v128, Values.I64Num.of_num(1, param$1));
          break;
      case /* F32x4 */4 :
          tmp = Curry._3(V128.F32x4.replace_lane, partial_arg._0._0, v128, Values.F32Num.of_num(1, param$1));
          break;
      case /* F64x2 */5 :
          tmp = Curry._3(V128.F64x2.replace_lane, partial_arg._0._0, v128, Values.F64Num.of_num(1, param$1));
          break;
      
    }
    return Values.V128Vec.to_vec(tmp);
  };
}

export {
  eval_testop ,
  eval_unop ,
  eval_binop ,
  eval_relop ,
  eval_cvtop ,
  eval_shiftop ,
  eval_bitmaskop ,
  eval_vtestop ,
  eval_vunop ,
  eval_vbinop ,
  eval_vternop ,
  eval_splatop ,
  eval_extractop ,
  eval_replaceop ,
  
}
/* V128 Not a pure module */
