// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var F32 = require("./f32.bs.js");
var F64 = require("./f64.bs.js");
var Ixx = require("./ixx.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Int32 = require("rescript/lib/js/int32.js");
var Caml_int64 = require("rescript/lib/js/caml_int64.js");

var wrap_i64 = Caml_int64.to_int32;

function trunc_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Int32.min_int || xf < Int32.min_int) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return xf | 0;
}

function trunc_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Int32.min_int * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.to_int32(Caml_int64.of_float(xf));
}

function trunc_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Int32.min_int || xf <= Int32.min_int - 1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return xf | 0;
}

function trunc_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Int32.min_int * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.to_int32(Caml_int64.of_float(xf));
}

function trunc_sat_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf < Int32.min_int) {
    return Int32.min_int;
  } else if (xf >= -Int32.min_int) {
    return Int32.max_int;
  } else {
    return xf | 0;
  }
}

function trunc_sat_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf <= -1.0) {
    return 0;
  } else if (xf >= -Int32.min_int * 2.0) {
    return -1;
  } else {
    return Caml_int64.to_int32(Caml_int64.of_float(xf));
  }
}

function trunc_sat_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf < Int32.min_int) {
    return Int32.min_int;
  } else if (xf >= -Int32.min_int) {
    return Int32.max_int;
  } else {
    return xf | 0;
  }
}

function trunc_sat_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf <= -1.0) {
    return 0;
  } else if (xf >= -Int32.min_int * 2.0) {
    return -1;
  } else {
    return Caml_int64.to_int32(Caml_int64.of_float(xf));
  }
}

var reinterpret_f32 = F32.to_bits;

exports.wrap_i64 = wrap_i64;
exports.trunc_f32_s = trunc_f32_s;
exports.trunc_f32_u = trunc_f32_u;
exports.trunc_f64_s = trunc_f64_s;
exports.trunc_f64_u = trunc_f64_u;
exports.trunc_sat_f32_s = trunc_sat_f32_s;
exports.trunc_sat_f32_u = trunc_sat_f32_u;
exports.trunc_sat_f64_s = trunc_sat_f64_s;
exports.trunc_sat_f64_u = trunc_sat_f64_u;
exports.reinterpret_f32 = reinterpret_f32;
/* F32 Not a pure module */
