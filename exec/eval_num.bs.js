// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var F32 = require("./f32.bs.js");
var F64 = require("./f64.bs.js");
var I32 = require("./i32.bs.js");
var I64 = require("./i64.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Types = require("../syntax/types.bs.js");
var Values = require("../syntax/values.bs.js");
var F32_convert = require("./f32_convert.bs.js");
var F64_convert = require("./f64_convert.bs.js");
var I32_convert = require("./i32_convert.bs.js");
var I64_convert = require("./i64_convert.bs.js");

function unop(op) {
  var f;
  if (typeof op === "number") {
    switch (op) {
      case /* Clz */0 :
          f = I32.clz;
          break;
      case /* Ctz */1 :
          f = I32.ctz;
          break;
      case /* Popcnt */2 :
          f = I32.popcnt;
          break;
      
    }
  } else {
    f = Curry._1(I32.extend_s, (Types.packed_size(op._0) << 3));
  }
  return function (v) {
    return Curry._1(Values.I32Num.to_num, Curry._1(f, Curry._2(Values.I32Num.of_num, 1, v)));
  };
}

function binop(op) {
  var f;
  switch (op) {
    case /* Add */0 :
        f = I32.add;
        break;
    case /* Sub */1 :
        f = I32.sub;
        break;
    case /* Mul */2 :
        f = I32.mul;
        break;
    case /* DivS */3 :
        f = I32.div_s;
        break;
    case /* DivU */4 :
        f = I32.div_u;
        break;
    case /* RemS */5 :
        f = I32.rem_s;
        break;
    case /* RemU */6 :
        f = I32.rem_u;
        break;
    case /* And */7 :
        f = I32.and_;
        break;
    case /* Or */8 :
        f = I32.or_;
        break;
    case /* Xor */9 :
        f = I32.xor;
        break;
    case /* Shl */10 :
        f = I32.shl;
        break;
    case /* ShrS */11 :
        f = I32.shr_s;
        break;
    case /* ShrU */12 :
        f = I32.shr_u;
        break;
    case /* Rotl */13 :
        f = I32.rotl;
        break;
    case /* Rotr */14 :
        f = I32.rotr;
        break;
    
  }
  return function (v1, v2) {
    return Curry._1(Values.I32Num.to_num, Curry._2(f, Curry._2(Values.I32Num.of_num, 1, v1), Curry._2(Values.I32Num.of_num, 2, v2)));
  };
}

function testop(op) {
  return function (v) {
    return Curry._1(I32.eqz, Curry._2(Values.I32Num.of_num, 1, v));
  };
}

function relop(op) {
  var f;
  switch (op) {
    case /* Eq */0 :
        f = I32.eq;
        break;
    case /* Ne */1 :
        f = I32.ne;
        break;
    case /* LtS */2 :
        f = I32.lt_s;
        break;
    case /* LtU */3 :
        f = I32.lt_u;
        break;
    case /* GtS */4 :
        f = I32.gt_s;
        break;
    case /* GtU */5 :
        f = I32.gt_u;
        break;
    case /* LeS */6 :
        f = I32.le_s;
        break;
    case /* LeU */7 :
        f = I32.le_u;
        break;
    case /* GeS */8 :
        f = I32.ge_s;
        break;
    case /* GeU */9 :
        f = I32.ge_u;
        break;
    
  }
  return function (v1, v2) {
    return Curry._2(f, Curry._2(Values.I32Num.of_num, 1, v1), Curry._2(Values.I32Num.of_num, 2, v2));
  };
}

function unop$1(op) {
  var f;
  if (typeof op === "number") {
    switch (op) {
      case /* Clz */0 :
          f = I64.clz;
          break;
      case /* Ctz */1 :
          f = I64.ctz;
          break;
      case /* Popcnt */2 :
          f = I64.popcnt;
          break;
      
    }
  } else {
    f = Curry._1(I64.extend_s, (Types.packed_size(op._0) << 3));
  }
  return function (v) {
    return Curry._1(Values.I64Num.to_num, Curry._1(f, Curry._2(Values.I64Num.of_num, 1, v)));
  };
}

function binop$1(op) {
  var f;
  switch (op) {
    case /* Add */0 :
        f = I64.add;
        break;
    case /* Sub */1 :
        f = I64.sub;
        break;
    case /* Mul */2 :
        f = I64.mul;
        break;
    case /* DivS */3 :
        f = I64.div_s;
        break;
    case /* DivU */4 :
        f = I64.div_u;
        break;
    case /* RemS */5 :
        f = I64.rem_s;
        break;
    case /* RemU */6 :
        f = I64.rem_u;
        break;
    case /* And */7 :
        f = I64.and_;
        break;
    case /* Or */8 :
        f = I64.or_;
        break;
    case /* Xor */9 :
        f = I64.xor;
        break;
    case /* Shl */10 :
        f = I64.shl;
        break;
    case /* ShrS */11 :
        f = I64.shr_s;
        break;
    case /* ShrU */12 :
        f = I64.shr_u;
        break;
    case /* Rotl */13 :
        f = I64.rotl;
        break;
    case /* Rotr */14 :
        f = I64.rotr;
        break;
    
  }
  return function (v1, v2) {
    return Curry._1(Values.I64Num.to_num, Curry._2(f, Curry._2(Values.I64Num.of_num, 1, v1), Curry._2(Values.I64Num.of_num, 2, v2)));
  };
}

function testop$1(op) {
  return function (v) {
    return Curry._1(I64.eqz, Curry._2(Values.I64Num.of_num, 1, v));
  };
}

function relop$1(op) {
  var f;
  switch (op) {
    case /* Eq */0 :
        f = I64.eq;
        break;
    case /* Ne */1 :
        f = I64.ne;
        break;
    case /* LtS */2 :
        f = I64.lt_s;
        break;
    case /* LtU */3 :
        f = I64.lt_u;
        break;
    case /* GtS */4 :
        f = I64.gt_s;
        break;
    case /* GtU */5 :
        f = I64.gt_u;
        break;
    case /* LeS */6 :
        f = I64.le_s;
        break;
    case /* LeU */7 :
        f = I64.le_u;
        break;
    case /* GeS */8 :
        f = I64.ge_s;
        break;
    case /* GeU */9 :
        f = I64.ge_u;
        break;
    
  }
  return function (v1, v2) {
    return Curry._2(f, Curry._2(Values.I64Num.of_num, 1, v1), Curry._2(Values.I64Num.of_num, 2, v2));
  };
}

function unop$2(op) {
  var f;
  switch (op) {
    case /* Neg */0 :
        f = F32.neg;
        break;
    case /* Abs */1 :
        f = F32.abs;
        break;
    case /* Ceil */2 :
        f = F32.ceil;
        break;
    case /* Floor */3 :
        f = F32.floor;
        break;
    case /* Trunc */4 :
        f = F32.trunc;
        break;
    case /* Nearest */5 :
        f = F32.nearest;
        break;
    case /* Sqrt */6 :
        f = F32.sqrt;
        break;
    
  }
  return function (v) {
    return Curry._1(Values.F32Num.to_num, Curry._1(f, Curry._2(Values.F32Num.of_num, 1, v)));
  };
}

function binop$2(op) {
  var f;
  switch (op) {
    case /* Add */0 :
        f = F32.add;
        break;
    case /* Sub */1 :
        f = F32.sub;
        break;
    case /* Mul */2 :
        f = F32.mul;
        break;
    case /* Div */3 :
        f = F32.div;
        break;
    case /* Min */4 :
        f = F32.min;
        break;
    case /* Max */5 :
        f = F32.max;
        break;
    case /* CopySign */6 :
        f = F32.copysign;
        break;
    
  }
  return function (v1, v2) {
    return Curry._1(Values.F32Num.to_num, Curry._2(f, Curry._2(Values.F32Num.of_num, 1, v1), Curry._2(Values.F32Num.of_num, 2, v2)));
  };
}

function testop$2(op) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "eval_num.ml",
          92,
          18
        ],
        Error: new Error()
      };
}

function relop$2(op) {
  var f;
  switch (op) {
    case /* Eq */0 :
        f = F32.eq;
        break;
    case /* Ne */1 :
        f = F32.ne;
        break;
    case /* Lt */2 :
        f = F32.lt;
        break;
    case /* Gt */3 :
        f = F32.gt;
        break;
    case /* Le */4 :
        f = F32.le;
        break;
    case /* Ge */5 :
        f = F32.ge;
        break;
    
  }
  return function (v1, v2) {
    return Curry._2(f, Curry._2(Values.F32Num.of_num, 1, v1), Curry._2(Values.F32Num.of_num, 2, v2));
  };
}

function unop$3(op) {
  var f;
  switch (op) {
    case /* Neg */0 :
        f = F64.neg;
        break;
    case /* Abs */1 :
        f = F64.abs;
        break;
    case /* Ceil */2 :
        f = F64.ceil;
        break;
    case /* Floor */3 :
        f = F64.floor;
        break;
    case /* Trunc */4 :
        f = F64.trunc;
        break;
    case /* Nearest */5 :
        f = F64.nearest;
        break;
    case /* Sqrt */6 :
        f = F64.sqrt;
        break;
    
  }
  return function (v) {
    return Curry._1(Values.F64Num.to_num, Curry._1(f, Curry._2(Values.F64Num.of_num, 1, v)));
  };
}

function binop$3(op) {
  var f;
  switch (op) {
    case /* Add */0 :
        f = F64.add;
        break;
    case /* Sub */1 :
        f = F64.sub;
        break;
    case /* Mul */2 :
        f = F64.mul;
        break;
    case /* Div */3 :
        f = F64.div;
        break;
    case /* Min */4 :
        f = F64.min;
        break;
    case /* Max */5 :
        f = F64.max;
        break;
    case /* CopySign */6 :
        f = F64.copysign;
        break;
    
  }
  return function (v1, v2) {
    return Curry._1(Values.F64Num.to_num, Curry._2(f, Curry._2(Values.F64Num.of_num, 1, v1), Curry._2(Values.F64Num.of_num, 2, v2)));
  };
}

function testop$3(op) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "eval_num.ml",
          92,
          18
        ],
        Error: new Error()
      };
}

function relop$3(op) {
  var f;
  switch (op) {
    case /* Eq */0 :
        f = F64.eq;
        break;
    case /* Ne */1 :
        f = F64.ne;
        break;
    case /* Lt */2 :
        f = F64.lt;
        break;
    case /* Gt */3 :
        f = F64.gt;
        break;
    case /* Le */4 :
        f = F64.le;
        break;
    case /* Ge */5 :
        f = F64.ge;
        break;
    
  }
  return function (v1, v2) {
    return Curry._2(f, Curry._2(Values.F64Num.of_num, 1, v1), Curry._2(Values.F64Num.of_num, 2, v2));
  };
}

function cvtop(op, v) {
  var tmp;
  switch (op) {
    case /* ExtendSI32 */0 :
    case /* ExtendUI32 */1 :
        throw {
              RE_EXN_ID: Values.$$TypeError,
              _1: 1,
              _2: v,
              _3: /* I32Type */0,
              Error: new Error()
            };
    case /* WrapI64 */2 :
        tmp = I32_convert.wrap_i64(Values.I64Num.of_num(1, v));
        break;
    case /* TruncSF32 */3 :
        tmp = I32_convert.trunc_f32_s(Values.F32Num.of_num(1, v));
        break;
    case /* TruncUF32 */4 :
        tmp = I32_convert.trunc_f32_u(Values.F32Num.of_num(1, v));
        break;
    case /* TruncSF64 */5 :
        tmp = I32_convert.trunc_f64_s(Values.F64Num.of_num(1, v));
        break;
    case /* TruncUF64 */6 :
        tmp = I32_convert.trunc_f64_u(Values.F64Num.of_num(1, v));
        break;
    case /* TruncSatSF32 */7 :
        tmp = I32_convert.trunc_sat_f32_s(Values.F32Num.of_num(1, v));
        break;
    case /* TruncSatUF32 */8 :
        tmp = I32_convert.trunc_sat_f32_u(Values.F32Num.of_num(1, v));
        break;
    case /* TruncSatSF64 */9 :
        tmp = I32_convert.trunc_sat_f64_s(Values.F64Num.of_num(1, v));
        break;
    case /* TruncSatUF64 */10 :
        tmp = I32_convert.trunc_sat_f64_u(Values.F64Num.of_num(1, v));
        break;
    case /* ReinterpretFloat */11 :
        tmp = Curry._1(I32_convert.reinterpret_f32, Values.F32Num.of_num(1, v));
        break;
    
  }
  return Values.I32Num.to_num(tmp);
}

function cvtop$1(op, v) {
  var tmp;
  switch (op) {
    case /* ExtendSI32 */0 :
        tmp = I64_convert.extend_i32_s(Values.I32Num.of_num(1, v));
        break;
    case /* ExtendUI32 */1 :
        tmp = I64_convert.extend_i32_u(Values.I32Num.of_num(1, v));
        break;
    case /* WrapI64 */2 :
        throw {
              RE_EXN_ID: Values.$$TypeError,
              _1: 1,
              _2: v,
              _3: /* I64Type */1,
              Error: new Error()
            };
    case /* TruncSF32 */3 :
        tmp = I64_convert.trunc_f32_s(Values.F32Num.of_num(1, v));
        break;
    case /* TruncUF32 */4 :
        tmp = I64_convert.trunc_f32_u(Values.F32Num.of_num(1, v));
        break;
    case /* TruncSF64 */5 :
        tmp = I64_convert.trunc_f64_s(Values.F64Num.of_num(1, v));
        break;
    case /* TruncUF64 */6 :
        tmp = I64_convert.trunc_f64_u(Values.F64Num.of_num(1, v));
        break;
    case /* TruncSatSF32 */7 :
        tmp = I64_convert.trunc_sat_f32_s(Values.F32Num.of_num(1, v));
        break;
    case /* TruncSatUF32 */8 :
        tmp = I64_convert.trunc_sat_f32_u(Values.F32Num.of_num(1, v));
        break;
    case /* TruncSatSF64 */9 :
        tmp = I64_convert.trunc_sat_f64_s(Values.F64Num.of_num(1, v));
        break;
    case /* TruncSatUF64 */10 :
        tmp = I64_convert.trunc_sat_f64_u(Values.F64Num.of_num(1, v));
        break;
    case /* ReinterpretFloat */11 :
        tmp = Curry._1(I64_convert.reinterpret_f64, Values.F64Num.of_num(1, v));
        break;
    
  }
  return Values.I64Num.to_num(tmp);
}

function cvtop$2(op, v) {
  var tmp;
  switch (op) {
    case /* ConvertSI32 */0 :
        tmp = F32_convert.convert_i32_s(Values.I32Num.of_num(1, v));
        break;
    case /* ConvertUI32 */1 :
        tmp = F32_convert.convert_i32_u(Values.I32Num.of_num(1, v));
        break;
    case /* ConvertSI64 */2 :
        tmp = F32_convert.convert_i64_s(Values.I64Num.of_num(1, v));
        break;
    case /* ConvertUI64 */3 :
        tmp = F32_convert.convert_i64_u(Values.I64Num.of_num(1, v));
        break;
    case /* PromoteF32 */4 :
        throw {
              RE_EXN_ID: Values.$$TypeError,
              _1: 1,
              _2: v,
              _3: /* F32Type */2,
              Error: new Error()
            };
    case /* DemoteF64 */5 :
        tmp = F32_convert.demote_f64(Values.F64Num.of_num(1, v));
        break;
    case /* ReinterpretInt */6 :
        tmp = Curry._1(F32_convert.reinterpret_i32, Values.I32Num.of_num(1, v));
        break;
    
  }
  return Values.F32Num.to_num(tmp);
}

function cvtop$3(op, v) {
  var tmp;
  switch (op) {
    case /* ConvertSI32 */0 :
        tmp = F64_convert.convert_i32_s(Values.I32Num.of_num(1, v));
        break;
    case /* ConvertUI32 */1 :
        tmp = F64_convert.convert_i32_u(Values.I32Num.of_num(1, v));
        break;
    case /* ConvertSI64 */2 :
        tmp = F64_convert.convert_i64_s(Values.I64Num.of_num(1, v));
        break;
    case /* ConvertUI64 */3 :
        tmp = F64_convert.convert_i64_u(Values.I64Num.of_num(1, v));
        break;
    case /* PromoteF32 */4 :
        tmp = F64_convert.promote_f32(Values.F32Num.of_num(1, v));
        break;
    case /* DemoteF64 */5 :
        throw {
              RE_EXN_ID: Values.$$TypeError,
              _1: 1,
              _2: v,
              _3: /* F64Type */3,
              Error: new Error()
            };
    case /* ReinterpretInt */6 :
        tmp = Curry._1(F64_convert.reinterpret_i64, Values.I64Num.of_num(1, v));
        break;
    
  }
  return Values.F64Num.to_num(tmp);
}

function op(i32, i64, f32, f64, x) {
  switch (x.TAG | 0) {
    case /* I32 */0 :
        return Curry._1(i32, x._0);
    case /* I64 */1 :
        return Curry._1(i64, x._0);
    case /* F32 */2 :
        return Curry._1(f32, x._0);
    case /* F64 */3 :
        return Curry._1(f64, x._0);
    
  }
}

function eval_unop(param) {
  return op(unop, unop$1, unop$2, unop$3, param);
}

function eval_binop(param) {
  return op(binop, binop$1, binop$2, binop$3, param);
}

function eval_testop(param) {
  return op(testop, testop$1, testop$2, testop$3, param);
}

function eval_relop(param) {
  return op(relop, relop$1, relop$2, relop$3, param);
}

function eval_cvtop(param) {
  return op(cvtop, cvtop$1, cvtop$2, cvtop$3, param);
}

exports.eval_unop = eval_unop;
exports.eval_binop = eval_binop;
exports.eval_testop = eval_testop;
exports.eval_relop = eval_relop;
exports.eval_cvtop = eval_cvtop;
/* F32 Not a pure module */
