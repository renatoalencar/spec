// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Ast from "../syntax/ast.bs.js";
import * as I32 from "./i32.bs.js";
import * as I64 from "./i64.bs.js";
import * as Ixx from "./ixx.bs.js";
import * as Lib from "../util/lib.bs.js";
import * as Func from "../runtime/func.bs.js";
import * as List from "rescript/lib/es6/list.js";
import * as Utf8 from "../binary/utf8.bs.js";
import * as V128 from "./v128.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as $$Error from "../util/error.bs.js";
import * as Int32 from "rescript/lib/es6/int32.js";
import * as Table from "../runtime/table.bs.js";
import * as Types from "../syntax/types.bs.js";
import * as Global from "../runtime/global.bs.js";
import * as Memory from "../runtime/memory.bs.js";
import * as Source from "../util/source.bs.js";
import * as Values from "../syntax/values.bs.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Eval_num from "./eval_num.bs.js";
import * as Eval_vec from "./eval_vec.bs.js";
import * as Instance from "../runtime/instance.bs.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";
import * as I64_convert from "./i64_convert.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var Link = $$Error.Make({});

var Trap = $$Error.Make({});

var Crash = $$Error.Make({});

var Exhaustion = $$Error.Make({});

var Crash$1 = Crash.$$Error;

function table_error(at, exn) {
  if (exn.RE_EXN_ID === Table.Bounds) {
    return "out of bounds table access";
  }
  if (exn.RE_EXN_ID === Table.SizeOverflow) {
    return "table size overflow";
  }
  if (exn.RE_EXN_ID === Table.SizeLimit) {
    return "table size limit reached";
  }
  if (exn.RE_EXN_ID === Table.Type) {
    return Curry._2(Crash.error, at, "type mismatch at table access");
  }
  throw exn;
}

function memory_error(at, exn) {
  if (exn.RE_EXN_ID === Memory.Bounds) {
    return "out of bounds memory access";
  }
  if (exn.RE_EXN_ID === Memory.SizeOverflow) {
    return "memory size overflow";
  }
  if (exn.RE_EXN_ID === Memory.SizeLimit) {
    return "memory size limit reached";
  }
  if (exn.RE_EXN_ID === Memory.Type) {
    return Curry._2(Crash.error, at, "type mismatch at memory access");
  }
  throw exn;
}

function numeric_error(at, exn) {
  if (exn.RE_EXN_ID === Ixx.Overflow) {
    return "integer overflow";
  }
  if (exn.RE_EXN_ID === Ixx.DivideByZero) {
    return "integer divide by zero";
  }
  if (exn.RE_EXN_ID === Ixx.InvalidConversion) {
    return "invalid conversion to integer";
  }
  if (exn.RE_EXN_ID === Values.$$TypeError) {
    return Curry._2(Crash.error, at, "type error, expected " + (Types.string_of_num_type(exn._3) + (" as operand " + (String(exn._1) + (", got " + Types.string_of_num_type(Values.type_of_num(exn._2)))))));
  }
  throw exn;
}

function config(inst, vs, es) {
  return {
          frame: {
            inst: inst,
            locals: /* [] */0
          },
          code: [
            vs,
            es
          ],
          budget: 300
        };
}

function plain(e) {
  return Source.$at$at({
              TAG: /* Plain */0,
              _0: e.it
            }, e.at);
}

function lookup(category, list, x) {
  try {
    return Lib.List32.nth(list, x.it);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return Curry._2(Crash.error, x.at, "undefined " + (category + (" " + Int32.to_string(x.it))));
    }
    throw exn;
  }
}

function type_(inst, x) {
  return lookup("type", inst.types, x);
}

function func(inst, x) {
  return lookup("function", inst.funcs, x);
}

function table(inst, x) {
  return lookup("table", inst.tables, x);
}

function memory(inst, x) {
  return lookup("memory", inst.memories, x);
}

function $$global(inst, x) {
  return lookup("global", inst.globals, x);
}

function elem(inst, x) {
  return lookup("element segment", inst.elems, x);
}

function data(inst, x) {
  return lookup("data segment", inst.datas, x);
}

function local(frame, x) {
  return lookup("local", frame.locals, x);
}

function any_ref(inst, x, i, at) {
  try {
    return Table.load(table(inst, x), i);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Table.Bounds) {
      return Curry._2(Trap.error, at, "undefined element " + Int32.to_string(i));
    }
    throw exn;
  }
}

function func_ref(inst, x, i, at) {
  var f = any_ref(inst, x, i, at);
  if (f.RE_EXN_ID === Instance.FuncRef) {
    return f._1;
  } else if (f.RE_EXN_ID === Values.NullRef) {
    return Curry._2(Trap.error, at, "uninitialized element " + Int32.to_string(i));
  } else {
    return Curry._2(Crash.error, at, "type mismatch for element " + Int32.to_string(i));
  }
}

function func_type_of(param) {
  return param._0;
}

function block_type(inst, bt) {
  if (bt.TAG === /* VarBlockType */0) {
    return type_(inst, bt._0);
  }
  var t = bt._0;
  if (t !== undefined) {
    return /* FuncType */{
            _0: /* [] */0,
            _1: {
              hd: t,
              tl: /* [] */0
            }
          };
  } else {
    return /* FuncType */{
            _0: /* [] */0,
            _1: /* [] */0
          };
  }
}

function take(n, vs, at) {
  try {
    return Lib.List32.take(n, vs);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return Curry._2(Crash.error, at, "stack underflow");
    }
    throw exn;
  }
}

function drop(n, vs, at) {
  try {
    return Lib.List32.drop(n, vs);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return Curry._2(Crash.error, at, "stack underflow");
    }
    throw exn;
  }
}

function mem_oob(frame, x, i, n) {
  return Curry._2(I64.gt_u, Curry._2(I64.add, I64_convert.extend_i32_u(i), I64_convert.extend_i32_u(n)), Memory.bound(memory(frame.inst, x)));
}

function data_oob(frame, x, i, n) {
  return Curry._2(I64.gt_u, Curry._2(I64.add, I64_convert.extend_i32_u(i), I64_convert.extend_i32_u(n)), Curry._1(I64.of_int_u, data(frame.inst, x).contents.length));
}

function table_oob(frame, x, i, n) {
  return Curry._2(I64.gt_u, Curry._2(I64.add, I64_convert.extend_i32_u(i), I64_convert.extend_i32_u(n)), I64_convert.extend_i32_u(Table.size(table(frame.inst, x))));
}

function elem_oob(frame, x, i, n) {
  return Curry._2(I64.gt_u, Curry._2(I64.add, I64_convert.extend_i32_u(i), I64_convert.extend_i32_u(n)), Curry._1(I64.of_int_u, List.length(elem(frame.inst, x).contents)));
}

function step(c) {
  var match = c.code;
  var es = match[1];
  var vs = match[0];
  var frame = c.frame;
  var e = List.hd(es);
  var match$1 = e.it;
  var match$2;
  switch (match$1.TAG | 0) {
    case /* Plain */0 :
        var e$p = match$1._0;
        var exit = 0;
        if (typeof e$p === "number") {
          switch (e$p) {
            case /* Unreachable */0 :
                match$2 = [
                  vs,
                  {
                    hd: Source.$at$at({
                          TAG: /* Trapping */3,
                          _0: "unreachable executed"
                        }, e.at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* Nop */1 :
                match$2 = [
                  vs,
                  /* [] */0
                ];
                break;
            case /* Drop */2 :
                if (vs) {
                  match$2 = [
                    vs.tl,
                    /* [] */0
                  ];
                } else {
                  exit = 1;
                }
                break;
            case /* Return */3 :
                match$2 = [
                  /* [] */0,
                  {
                    hd: Source.$at$at({
                          TAG: /* Returning */4,
                          _0: vs
                        }, e.at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* MemorySize */4 :
                var mem = memory(frame.inst, Source.$at$at(0, e.at));
                match$2 = [
                  {
                    hd: {
                      TAG: /* Num */0,
                      _0: {
                        TAG: /* I32 */0,
                        _0: Memory.size(mem)
                      }
                    },
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* MemoryGrow */5 :
                if (vs) {
                  var match$3 = vs.hd;
                  switch (match$3.TAG | 0) {
                    case /* Num */0 :
                        var delta = match$3._0;
                        if (delta.TAG === /* I32 */0) {
                          var mem$1 = memory(frame.inst, Source.$at$at(0, e.at));
                          var old_size = Memory.size(mem$1);
                          var result;
                          try {
                            Memory.grow(mem$1)(delta._0);
                            result = old_size;
                          }
                          catch (raw_exn){
                            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                            if (exn.RE_EXN_ID === Memory.SizeOverflow || exn.RE_EXN_ID === Memory.SizeLimit || exn.RE_EXN_ID === Memory.OutOfMemory) {
                              result = -1;
                            } else {
                              throw exn;
                            }
                          }
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Num */0,
                                _0: {
                                  TAG: /* I32 */0,
                                  _0: result
                                }
                              },
                              tl: vs.tl
                            },
                            /* [] */0
                          ];
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* MemoryFill */6 :
                if (vs) {
                  var match$4 = vs.hd;
                  switch (match$4.TAG | 0) {
                    case /* Num */0 :
                        var n = match$4._0;
                        if (n.TAG === /* I32 */0) {
                          var match$5 = vs.tl;
                          if (match$5) {
                            var k = match$5.hd;
                            var n$1 = n._0;
                            switch (k.TAG | 0) {
                              case /* Num */0 :
                                  var match$6 = match$5.tl;
                                  if (match$6) {
                                    var match$7 = match$6.hd;
                                    var k$1 = k._0;
                                    switch (match$7.TAG | 0) {
                                      case /* Num */0 :
                                          var i = match$7._0;
                                          if (i.TAG === /* I32 */0) {
                                            var vs$p = match$6.tl;
                                            var i$1 = i._0;
                                            if (mem_oob(frame, Source.$at$at(0, e.at), i$1, n$1)) {
                                              match$2 = [
                                                vs$p,
                                                {
                                                  hd: Source.$at$at({
                                                        TAG: /* Trapping */3,
                                                        _0: memory_error(e.at, {
                                                              RE_EXN_ID: Memory.Bounds
                                                            })
                                                      }, e.at),
                                                  tl: /* [] */0
                                                }
                                              ];
                                            } else if (n$1 === 0) {
                                              match$2 = [
                                                vs$p,
                                                /* [] */0
                                              ];
                                            } else {
                                              var partial_arg = e.at;
                                              match$2 = [
                                                vs$p,
                                                List.map((function (param) {
                                                        return Source.at(partial_arg, param);
                                                      }), {
                                                      hd: {
                                                        TAG: /* Plain */0,
                                                        _0: {
                                                          TAG: /* Const */32,
                                                          _0: Source.$at$at({
                                                                TAG: /* I32 */0,
                                                                _0: i$1
                                                              }, e.at)
                                                        }
                                                      },
                                                      tl: {
                                                        hd: {
                                                          TAG: /* Plain */0,
                                                          _0: {
                                                            TAG: /* Const */32,
                                                            _0: Source.$at$at(k$1, e.at)
                                                          }
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Plain */0,
                                                            _0: {
                                                              TAG: /* Store */23,
                                                              _0: {
                                                                ty: /* I32Type */0,
                                                                align: 0,
                                                                offset: 0,
                                                                pack: /* Pack8 */0
                                                              }
                                                            }
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* Const */32,
                                                                _0: Source.$at$at({
                                                                      TAG: /* I32 */0,
                                                                      _0: Curry._2(I32.add, i$1, 1)
                                                                    }, e.at)
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Plain */0,
                                                                _0: {
                                                                  TAG: /* Const */32,
                                                                  _0: Source.$at$at(k$1, e.at)
                                                                }
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: Curry._2(I32.sub, n$1, 1)
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: /* MemoryFill */6
                                                                  },
                                                                  tl: /* [] */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    })
                                              ];
                                            }
                                          } else {
                                            exit = 1;
                                          }
                                          break;
                                      case /* Vec */1 :
                                      case /* Ref */2 :
                                          exit = 1;
                                          break;
                                      
                                    }
                                  } else {
                                    exit = 1;
                                  }
                                  break;
                              case /* Vec */1 :
                              case /* Ref */2 :
                                  exit = 1;
                                  break;
                              
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* MemoryCopy */7 :
                if (vs) {
                  var match$8 = vs.hd;
                  switch (match$8.TAG | 0) {
                    case /* Num */0 :
                        var n$2 = match$8._0;
                        if (n$2.TAG === /* I32 */0) {
                          var match$9 = vs.tl;
                          if (match$9) {
                            var match$10 = match$9.hd;
                            var n$3 = n$2._0;
                            switch (match$10.TAG | 0) {
                              case /* Num */0 :
                                  var s = match$10._0;
                                  if (s.TAG === /* I32 */0) {
                                    var match$11 = match$9.tl;
                                    if (match$11) {
                                      var match$12 = match$11.hd;
                                      var s$1 = s._0;
                                      switch (match$12.TAG | 0) {
                                        case /* Num */0 :
                                            var d = match$12._0;
                                            if (d.TAG === /* I32 */0) {
                                              var vs$p$1 = match$11.tl;
                                              var d$1 = d._0;
                                              if (mem_oob(frame, Source.$at$at(0, e.at), s$1, n$3) || mem_oob(frame, Source.$at$at(0, e.at), d$1, n$3)) {
                                                match$2 = [
                                                  vs$p$1,
                                                  {
                                                    hd: Source.$at$at({
                                                          TAG: /* Trapping */3,
                                                          _0: memory_error(e.at, {
                                                                RE_EXN_ID: Memory.Bounds
                                                              })
                                                        }, e.at),
                                                    tl: /* [] */0
                                                  }
                                                ];
                                              } else if (n$3 === 0) {
                                                match$2 = [
                                                  vs$p$1,
                                                  /* [] */0
                                                ];
                                              } else if (Curry._2(I32.le_u, d$1, s$1)) {
                                                var partial_arg$1 = e.at;
                                                match$2 = [
                                                  vs$p$1,
                                                  List.map((function (param) {
                                                          return Source.at(partial_arg$1, param);
                                                        }), {
                                                        hd: {
                                                          TAG: /* Plain */0,
                                                          _0: {
                                                            TAG: /* Const */32,
                                                            _0: Source.$at$at({
                                                                  TAG: /* I32 */0,
                                                                  _0: d$1
                                                                }, e.at)
                                                          }
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Plain */0,
                                                            _0: {
                                                              TAG: /* Const */32,
                                                              _0: Source.$at$at({
                                                                    TAG: /* I32 */0,
                                                                    _0: s$1
                                                                  }, e.at)
                                                            }
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* Load */22,
                                                                _0: {
                                                                  ty: /* I32Type */0,
                                                                  align: 0,
                                                                  offset: 0,
                                                                  pack: [
                                                                    /* Pack8 */0,
                                                                    /* ZX */1
                                                                  ]
                                                                }
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Plain */0,
                                                                _0: {
                                                                  TAG: /* Store */23,
                                                                  _0: {
                                                                    ty: /* I32Type */0,
                                                                    align: 0,
                                                                    offset: 0,
                                                                    pack: /* Pack8 */0
                                                                  }
                                                                }
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: Curry._2(I32.add, d$1, 1)
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: {
                                                                      TAG: /* Const */32,
                                                                      _0: Source.$at$at({
                                                                            TAG: /* I32 */0,
                                                                            _0: Curry._2(I32.add, s$1, 1)
                                                                          }, e.at)
                                                                    }
                                                                  },
                                                                  tl: {
                                                                    hd: {
                                                                      TAG: /* Plain */0,
                                                                      _0: {
                                                                        TAG: /* Const */32,
                                                                        _0: Source.$at$at({
                                                                              TAG: /* I32 */0,
                                                                              _0: Curry._2(I32.sub, n$3, 1)
                                                                            }, e.at)
                                                                      }
                                                                    },
                                                                    tl: {
                                                                      hd: {
                                                                        TAG: /* Plain */0,
                                                                        _0: /* MemoryCopy */7
                                                                      },
                                                                      tl: /* [] */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      })
                                                ];
                                              } else {
                                                var partial_arg$2 = e.at;
                                                match$2 = [
                                                  vs$p$1,
                                                  List.map((function (param) {
                                                          return Source.at(partial_arg$2, param);
                                                        }), {
                                                        hd: {
                                                          TAG: /* Plain */0,
                                                          _0: {
                                                            TAG: /* Const */32,
                                                            _0: Source.$at$at({
                                                                  TAG: /* I32 */0,
                                                                  _0: Curry._2(I32.add, d$1, 1)
                                                                }, e.at)
                                                          }
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Plain */0,
                                                            _0: {
                                                              TAG: /* Const */32,
                                                              _0: Source.$at$at({
                                                                    TAG: /* I32 */0,
                                                                    _0: Curry._2(I32.add, s$1, 1)
                                                                  }, e.at)
                                                            }
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* Const */32,
                                                                _0: Source.$at$at({
                                                                      TAG: /* I32 */0,
                                                                      _0: Curry._2(I32.sub, n$3, 1)
                                                                    }, e.at)
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Plain */0,
                                                                _0: /* MemoryCopy */7
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: d$1
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: {
                                                                      TAG: /* Const */32,
                                                                      _0: Source.$at$at({
                                                                            TAG: /* I32 */0,
                                                                            _0: s$1
                                                                          }, e.at)
                                                                    }
                                                                  },
                                                                  tl: {
                                                                    hd: {
                                                                      TAG: /* Plain */0,
                                                                      _0: {
                                                                        TAG: /* Load */22,
                                                                        _0: {
                                                                          ty: /* I32Type */0,
                                                                          align: 0,
                                                                          offset: 0,
                                                                          pack: [
                                                                            /* Pack8 */0,
                                                                            /* ZX */1
                                                                          ]
                                                                        }
                                                                      }
                                                                    },
                                                                    tl: {
                                                                      hd: {
                                                                        TAG: /* Plain */0,
                                                                        _0: {
                                                                          TAG: /* Store */23,
                                                                          _0: {
                                                                            ty: /* I32Type */0,
                                                                            align: 0,
                                                                            offset: 0,
                                                                            pack: /* Pack8 */0
                                                                          }
                                                                        }
                                                                      },
                                                                      tl: /* [] */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      })
                                                ];
                                              }
                                            } else {
                                              exit = 1;
                                            }
                                            break;
                                        case /* Vec */1 :
                                        case /* Ref */2 :
                                            exit = 1;
                                            break;
                                        
                                      }
                                    } else {
                                      exit = 1;
                                    }
                                  } else {
                                    exit = 1;
                                  }
                                  break;
                              case /* Vec */1 :
                              case /* Ref */2 :
                                  exit = 1;
                                  break;
                              
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* RefIsNull */8 :
                if (vs) {
                  var r = vs.hd;
                  switch (r.TAG | 0) {
                    case /* Num */0 :
                    case /* Vec */1 :
                        exit = 1;
                        break;
                    case /* Ref */2 :
                        var vs$p$2 = vs.tl;
                        match$2 = r._0.RE_EXN_ID === Values.NullRef ? [
                            {
                              hd: {
                                TAG: /* Num */0,
                                _0: {
                                  TAG: /* I32 */0,
                                  _0: 1
                                }
                              },
                              tl: vs$p$2
                            },
                            /* [] */0
                          ] : [
                            {
                              hd: {
                                TAG: /* Num */0,
                                _0: {
                                  TAG: /* I32 */0,
                                  _0: 0
                                }
                              },
                              tl: vs$p$2
                            },
                            /* [] */0
                          ];
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            
          }
        } else {
          switch (e$p.TAG | 0) {
            case /* Select */0 :
                if (vs) {
                  var match$13 = vs.hd;
                  switch (match$13.TAG | 0) {
                    case /* Num */0 :
                        var i$2 = match$13._0;
                        if (i$2.TAG === /* I32 */0) {
                          var match$14 = vs.tl;
                          if (match$14) {
                            var match$15 = match$14.tl;
                            if (match$15) {
                              var vs$p$3 = match$15.tl;
                              match$2 = i$2._0 === 0 ? [
                                  {
                                    hd: match$14.hd,
                                    tl: vs$p$3
                                  },
                                  /* [] */0
                                ] : [
                                  {
                                    hd: match$15.hd,
                                    tl: vs$p$3
                                  },
                                  /* [] */0
                                ];
                            } else {
                              exit = 1;
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Block */1 :
                var match$16 = block_type(frame.inst, e$p._0);
                var n1 = Lib.List32.length(match$16._0);
                var n2 = Lib.List32.length(match$16._1);
                var args = take(n1, vs, e.at);
                var vs$p$4 = drop(n1, vs, e.at);
                match$2 = [
                  vs$p$4,
                  {
                    hd: Source.$at$at({
                          TAG: /* Label */6,
                          _0: n2,
                          _1: /* [] */0,
                          _2: [
                            args,
                            List.map(plain, e$p._1)
                          ]
                        }, e.at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* Loop */2 :
                var match$17 = block_type(frame.inst, e$p._0);
                var n1$1 = Lib.List32.length(match$17._0);
                var args$1 = take(n1$1, vs, e.at);
                var vs$p$5 = drop(n1$1, vs, e.at);
                match$2 = [
                  vs$p$5,
                  {
                    hd: Source.$at$at({
                          TAG: /* Label */6,
                          _0: n1$1,
                          _1: {
                            hd: Source.$at$at(e$p, e.at),
                            tl: /* [] */0
                          },
                          _2: [
                            args$1,
                            List.map(plain, e$p._1)
                          ]
                        }, e.at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* If */3 :
                if (vs) {
                  var match$18 = vs.hd;
                  var bt = e$p._0;
                  switch (match$18.TAG | 0) {
                    case /* Num */0 :
                        var i$3 = match$18._0;
                        if (i$3.TAG === /* I32 */0) {
                          var vs$p$6 = vs.tl;
                          match$2 = i$3._0 === 0 ? [
                              vs$p$6,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Plain */0,
                                      _0: {
                                        TAG: /* Block */1,
                                        _0: bt,
                                        _1: e$p._2
                                      }
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ] : [
                              vs$p$6,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Plain */0,
                                      _0: {
                                        TAG: /* Block */1,
                                        _0: bt,
                                        _1: e$p._1
                                      }
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ];
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Br */4 :
                match$2 = [
                  /* [] */0,
                  {
                    hd: Source.$at$at({
                          TAG: /* Breaking */5,
                          _0: e$p._0.it,
                          _1: vs
                        }, e.at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* BrIf */5 :
                if (vs) {
                  var match$19 = vs.hd;
                  switch (match$19.TAG | 0) {
                    case /* Num */0 :
                        var i$4 = match$19._0;
                        if (i$4.TAG === /* I32 */0) {
                          var vs$p$7 = vs.tl;
                          match$2 = i$4._0 === 0 ? [
                              vs$p$7,
                              /* [] */0
                            ] : [
                              vs$p$7,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Plain */0,
                                      _0: {
                                        TAG: /* Br */4,
                                        _0: e$p._0
                                      }
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ];
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* BrTable */6 :
                if (vs) {
                  var match$20 = vs.hd;
                  var xs = e$p._0;
                  switch (match$20.TAG | 0) {
                    case /* Num */0 :
                        var i$5 = match$20._0;
                        if (i$5.TAG === /* I32 */0) {
                          var vs$p$8 = vs.tl;
                          var i$6 = i$5._0;
                          match$2 = Curry._2(I32.ge_u, i$6, Lib.List32.length(xs)) ? [
                              vs$p$8,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Plain */0,
                                      _0: {
                                        TAG: /* Br */4,
                                        _0: e$p._1
                                      }
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ] : [
                              vs$p$8,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Plain */0,
                                      _0: {
                                        TAG: /* Br */4,
                                        _0: Lib.List32.nth(xs, i$6)
                                      }
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ];
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Call */7 :
                match$2 = [
                  vs,
                  {
                    hd: Source.$at$at({
                          TAG: /* Invoke */2,
                          _0: func(frame.inst, e$p._0)
                        }, e.at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* CallIndirect */8 :
                if (vs) {
                  var match$21 = vs.hd;
                  switch (match$21.TAG | 0) {
                    case /* Num */0 :
                        var i$7 = match$21._0;
                        if (i$7.TAG === /* I32 */0) {
                          var vs$1 = vs.tl;
                          var func$1 = func_ref(frame.inst, e$p._0, i$7._0, e.at);
                          match$2 = Caml_obj.caml_notequal(type_(frame.inst, e$p._1), Func.type_of(func$1)) ? [
                              vs$1,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Trapping */3,
                                      _0: "indirect call type mismatch"
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ] : [
                              vs$1,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Invoke */2,
                                      _0: func$1
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ];
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* LocalGet */9 :
                match$2 = [
                  {
                    hd: local(frame, e$p._0).contents,
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* LocalSet */10 :
                if (vs) {
                  local(frame, e$p._0).contents = vs.hd;
                  match$2 = [
                    vs.tl,
                    /* [] */0
                  ];
                } else {
                  exit = 1;
                }
                break;
            case /* LocalTee */11 :
                if (vs) {
                  var v = vs.hd;
                  local(frame, e$p._0).contents = v;
                  match$2 = [
                    {
                      hd: v,
                      tl: vs.tl
                    },
                    /* [] */0
                  ];
                } else {
                  exit = 1;
                }
                break;
            case /* GlobalGet */12 :
                match$2 = [
                  {
                    hd: Global.load($$global(frame.inst, e$p._0)),
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* GlobalSet */13 :
                if (vs) {
                  try {
                    Global.store($$global(frame.inst, e$p._0), vs.hd);
                    match$2 = [
                      vs.tl,
                      /* [] */0
                    ];
                  }
                  catch (raw_exn$1){
                    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                    if (exn$1.RE_EXN_ID === Global.NotMutable) {
                      match$2 = Curry._2(Crash.error, e.at, "write to immutable global");
                    } else if (exn$1.RE_EXN_ID === Global.Type) {
                      match$2 = Curry._2(Crash.error, e.at, "type mismatch at global write");
                    } else {
                      throw exn$1;
                    }
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* TableGet */14 :
                if (vs) {
                  var match$22 = vs.hd;
                  switch (match$22.TAG | 0) {
                    case /* Num */0 :
                        var i$8 = match$22._0;
                        if (i$8.TAG === /* I32 */0) {
                          var vs$p$9 = vs.tl;
                          try {
                            match$2 = [
                              {
                                hd: {
                                  TAG: /* Ref */2,
                                  _0: Table.load(table(frame.inst, e$p._0), i$8._0)
                                },
                                tl: vs$p$9
                              },
                              /* [] */0
                            ];
                          }
                          catch (raw_exn$2){
                            var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                            match$2 = [
                              vs$p$9,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Trapping */3,
                                      _0: table_error(e.at, exn$2)
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ];
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* TableSet */15 :
                if (vs) {
                  var r$1 = vs.hd;
                  switch (r$1.TAG | 0) {
                    case /* Num */0 :
                    case /* Vec */1 :
                        exit = 1;
                        break;
                    case /* Ref */2 :
                        var match$23 = vs.tl;
                        if (match$23) {
                          var match$24 = match$23.hd;
                          switch (match$24.TAG | 0) {
                            case /* Num */0 :
                                var i$9 = match$24._0;
                                if (i$9.TAG === /* I32 */0) {
                                  var vs$p$10 = match$23.tl;
                                  try {
                                    Table.store(table(frame.inst, e$p._0), i$9._0, r$1._0);
                                    match$2 = [
                                      vs$p$10,
                                      /* [] */0
                                    ];
                                  }
                                  catch (raw_exn$3){
                                    var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                                    match$2 = [
                                      vs$p$10,
                                      {
                                        hd: Source.$at$at({
                                              TAG: /* Trapping */3,
                                              _0: table_error(e.at, exn$3)
                                            }, e.at),
                                        tl: /* [] */0
                                      }
                                    ];
                                  }
                                } else {
                                  exit = 1;
                                }
                                break;
                            case /* Vec */1 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* TableSize */16 :
                match$2 = [
                  {
                    hd: {
                      TAG: /* Num */0,
                      _0: {
                        TAG: /* I32 */0,
                        _0: Table.size(table(frame.inst, e$p._0))
                      }
                    },
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* TableGrow */17 :
                if (vs) {
                  var match$25 = vs.hd;
                  switch (match$25.TAG | 0) {
                    case /* Num */0 :
                        var delta$1 = match$25._0;
                        if (delta$1.TAG === /* I32 */0) {
                          var match$26 = vs.tl;
                          if (match$26) {
                            var r$2 = match$26.hd;
                            switch (r$2.TAG | 0) {
                              case /* Num */0 :
                              case /* Vec */1 :
                                  exit = 1;
                                  break;
                              case /* Ref */2 :
                                  var tab = table(frame.inst, e$p._0);
                                  var old_size$1 = Table.size(tab);
                                  var result$1;
                                  try {
                                    Table.grow(tab, delta$1._0, r$2._0);
                                    result$1 = old_size$1;
                                  }
                                  catch (raw_exn$4){
                                    var exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
                                    if (exn$4.RE_EXN_ID === Table.SizeOverflow || exn$4.RE_EXN_ID === Table.SizeLimit || exn$4.RE_EXN_ID === Table.OutOfMemory) {
                                      result$1 = -1;
                                    } else {
                                      throw exn$4;
                                    }
                                  }
                                  match$2 = [
                                    {
                                      hd: {
                                        TAG: /* Num */0,
                                        _0: {
                                          TAG: /* I32 */0,
                                          _0: result$1
                                        }
                                      },
                                      tl: match$26.tl
                                    },
                                    /* [] */0
                                  ];
                                  break;
                              
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* TableFill */18 :
                if (vs) {
                  var match$27 = vs.hd;
                  var x = e$p._0;
                  switch (match$27.TAG | 0) {
                    case /* Num */0 :
                        var n$4 = match$27._0;
                        if (n$4.TAG === /* I32 */0) {
                          var match$28 = vs.tl;
                          if (match$28) {
                            var r$3 = match$28.hd;
                            var n$5 = n$4._0;
                            switch (r$3.TAG | 0) {
                              case /* Num */0 :
                              case /* Vec */1 :
                                  exit = 1;
                                  break;
                              case /* Ref */2 :
                                  var match$29 = match$28.tl;
                                  if (match$29) {
                                    var match$30 = match$29.hd;
                                    var r$4 = r$3._0;
                                    switch (match$30.TAG | 0) {
                                      case /* Num */0 :
                                          var i$10 = match$30._0;
                                          if (i$10.TAG === /* I32 */0) {
                                            var vs$p$11 = match$29.tl;
                                            var i$11 = i$10._0;
                                            if (table_oob(frame, x, i$11, n$5)) {
                                              match$2 = [
                                                vs$p$11,
                                                {
                                                  hd: Source.$at$at({
                                                        TAG: /* Trapping */3,
                                                        _0: table_error(e.at, {
                                                              RE_EXN_ID: Table.Bounds
                                                            })
                                                      }, e.at),
                                                  tl: /* [] */0
                                                }
                                              ];
                                            } else if (n$5 === 0) {
                                              match$2 = [
                                                vs$p$11,
                                                /* [] */0
                                              ];
                                            } else {
                                              if (!Curry._2(I32.lt_u, i$11, -1)) {
                                                throw {
                                                      RE_EXN_ID: "Assert_failure",
                                                      _1: [
                                                        "eval.ml",
                                                        260,
                                                        18
                                                      ],
                                                      Error: new Error()
                                                    };
                                              }
                                              var partial_arg$3 = e.at;
                                              match$2 = [
                                                vs$p$11,
                                                List.map((function (param) {
                                                        return Source.at(partial_arg$3, param);
                                                      }), {
                                                      hd: {
                                                        TAG: /* Plain */0,
                                                        _0: {
                                                          TAG: /* Const */32,
                                                          _0: Source.$at$at({
                                                                TAG: /* I32 */0,
                                                                _0: i$11
                                                              }, e.at)
                                                        }
                                                      },
                                                      tl: {
                                                        hd: {
                                                          TAG: /* Refer */1,
                                                          _0: r$4
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Plain */0,
                                                            _0: {
                                                              TAG: /* TableSet */15,
                                                              _0: x
                                                            }
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* Const */32,
                                                                _0: Source.$at$at({
                                                                      TAG: /* I32 */0,
                                                                      _0: Curry._2(I32.add, i$11, 1)
                                                                    }, e.at)
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Refer */1,
                                                                _0: r$4
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: Curry._2(I32.sub, n$5, 1)
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: {
                                                                      TAG: /* TableFill */18,
                                                                      _0: x
                                                                    }
                                                                  },
                                                                  tl: /* [] */0
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    })
                                              ];
                                            }
                                          } else {
                                            exit = 1;
                                          }
                                          break;
                                      case /* Vec */1 :
                                      case /* Ref */2 :
                                          exit = 1;
                                          break;
                                      
                                    }
                                  } else {
                                    exit = 1;
                                  }
                                  break;
                              
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* TableCopy */19 :
                if (vs) {
                  var match$31 = vs.hd;
                  var y = e$p._1;
                  var x$1 = e$p._0;
                  switch (match$31.TAG | 0) {
                    case /* Num */0 :
                        var n$6 = match$31._0;
                        if (n$6.TAG === /* I32 */0) {
                          var match$32 = vs.tl;
                          if (match$32) {
                            var match$33 = match$32.hd;
                            var n$7 = n$6._0;
                            switch (match$33.TAG | 0) {
                              case /* Num */0 :
                                  var s$2 = match$33._0;
                                  if (s$2.TAG === /* I32 */0) {
                                    var match$34 = match$32.tl;
                                    if (match$34) {
                                      var match$35 = match$34.hd;
                                      var s$3 = s$2._0;
                                      switch (match$35.TAG | 0) {
                                        case /* Num */0 :
                                            var d$2 = match$35._0;
                                            if (d$2.TAG === /* I32 */0) {
                                              var vs$p$12 = match$34.tl;
                                              var d$3 = d$2._0;
                                              if (table_oob(frame, x$1, d$3, n$7) || table_oob(frame, y, s$3, n$7)) {
                                                match$2 = [
                                                  vs$p$12,
                                                  {
                                                    hd: Source.$at$at({
                                                          TAG: /* Trapping */3,
                                                          _0: table_error(e.at, {
                                                                RE_EXN_ID: Table.Bounds
                                                              })
                                                        }, e.at),
                                                    tl: /* [] */0
                                                  }
                                                ];
                                              } else if (n$7 === 0) {
                                                match$2 = [
                                                  vs$p$12,
                                                  /* [] */0
                                                ];
                                              } else if (Curry._2(I32.le_u, d$3, s$3)) {
                                                var partial_arg$4 = e.at;
                                                match$2 = [
                                                  vs$p$12,
                                                  List.map((function (param) {
                                                          return Source.at(partial_arg$4, param);
                                                        }), {
                                                        hd: {
                                                          TAG: /* Plain */0,
                                                          _0: {
                                                            TAG: /* Const */32,
                                                            _0: Source.$at$at({
                                                                  TAG: /* I32 */0,
                                                                  _0: d$3
                                                                }, e.at)
                                                          }
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Plain */0,
                                                            _0: {
                                                              TAG: /* Const */32,
                                                              _0: Source.$at$at({
                                                                    TAG: /* I32 */0,
                                                                    _0: s$3
                                                                  }, e.at)
                                                            }
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* TableGet */14,
                                                                _0: y
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Plain */0,
                                                                _0: {
                                                                  TAG: /* TableSet */15,
                                                                  _0: x$1
                                                                }
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: Curry._2(I32.add, d$3, 1)
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: {
                                                                      TAG: /* Const */32,
                                                                      _0: Source.$at$at({
                                                                            TAG: /* I32 */0,
                                                                            _0: Curry._2(I32.add, s$3, 1)
                                                                          }, e.at)
                                                                    }
                                                                  },
                                                                  tl: {
                                                                    hd: {
                                                                      TAG: /* Plain */0,
                                                                      _0: {
                                                                        TAG: /* Const */32,
                                                                        _0: Source.$at$at({
                                                                              TAG: /* I32 */0,
                                                                              _0: Curry._2(I32.sub, n$7, 1)
                                                                            }, e.at)
                                                                      }
                                                                    },
                                                                    tl: {
                                                                      hd: {
                                                                        TAG: /* Plain */0,
                                                                        _0: {
                                                                          TAG: /* TableCopy */19,
                                                                          _0: x$1,
                                                                          _1: y
                                                                        }
                                                                      },
                                                                      tl: /* [] */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      })
                                                ];
                                              } else {
                                                var partial_arg$5 = e.at;
                                                match$2 = [
                                                  vs$p$12,
                                                  List.map((function (param) {
                                                          return Source.at(partial_arg$5, param);
                                                        }), {
                                                        hd: {
                                                          TAG: /* Plain */0,
                                                          _0: {
                                                            TAG: /* Const */32,
                                                            _0: Source.$at$at({
                                                                  TAG: /* I32 */0,
                                                                  _0: Curry._2(I32.add, d$3, 1)
                                                                }, e.at)
                                                          }
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Plain */0,
                                                            _0: {
                                                              TAG: /* Const */32,
                                                              _0: Source.$at$at({
                                                                    TAG: /* I32 */0,
                                                                    _0: Curry._2(I32.add, s$3, 1)
                                                                  }, e.at)
                                                            }
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* Const */32,
                                                                _0: Source.$at$at({
                                                                      TAG: /* I32 */0,
                                                                      _0: Curry._2(I32.sub, n$7, 1)
                                                                    }, e.at)
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Plain */0,
                                                                _0: {
                                                                  TAG: /* TableCopy */19,
                                                                  _0: x$1,
                                                                  _1: y
                                                                }
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: d$3
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: {
                                                                      TAG: /* Const */32,
                                                                      _0: Source.$at$at({
                                                                            TAG: /* I32 */0,
                                                                            _0: s$3
                                                                          }, e.at)
                                                                    }
                                                                  },
                                                                  tl: {
                                                                    hd: {
                                                                      TAG: /* Plain */0,
                                                                      _0: {
                                                                        TAG: /* TableGet */14,
                                                                        _0: y
                                                                      }
                                                                    },
                                                                    tl: {
                                                                      hd: {
                                                                        TAG: /* Plain */0,
                                                                        _0: {
                                                                          TAG: /* TableSet */15,
                                                                          _0: x$1
                                                                        }
                                                                      },
                                                                      tl: /* [] */0
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      })
                                                ];
                                              }
                                            } else {
                                              exit = 1;
                                            }
                                            break;
                                        case /* Vec */1 :
                                        case /* Ref */2 :
                                            exit = 1;
                                            break;
                                        
                                      }
                                    } else {
                                      exit = 1;
                                    }
                                  } else {
                                    exit = 1;
                                  }
                                  break;
                              case /* Vec */1 :
                              case /* Ref */2 :
                                  exit = 1;
                                  break;
                              
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* TableInit */20 :
                if (vs) {
                  var match$36 = vs.hd;
                  var y$1 = e$p._1;
                  var x$2 = e$p._0;
                  switch (match$36.TAG | 0) {
                    case /* Num */0 :
                        var n$8 = match$36._0;
                        if (n$8.TAG === /* I32 */0) {
                          var match$37 = vs.tl;
                          if (match$37) {
                            var match$38 = match$37.hd;
                            var n$9 = n$8._0;
                            switch (match$38.TAG | 0) {
                              case /* Num */0 :
                                  var s$4 = match$38._0;
                                  if (s$4.TAG === /* I32 */0) {
                                    var match$39 = match$37.tl;
                                    if (match$39) {
                                      var match$40 = match$39.hd;
                                      var s$5 = s$4._0;
                                      switch (match$40.TAG | 0) {
                                        case /* Num */0 :
                                            var d$4 = match$40._0;
                                            if (d$4.TAG === /* I32 */0) {
                                              var vs$p$13 = match$39.tl;
                                              var d$5 = d$4._0;
                                              if (table_oob(frame, x$2, d$5, n$9) || elem_oob(frame, y$1, s$5, n$9)) {
                                                match$2 = [
                                                  vs$p$13,
                                                  {
                                                    hd: Source.$at$at({
                                                          TAG: /* Trapping */3,
                                                          _0: table_error(e.at, {
                                                                RE_EXN_ID: Table.Bounds
                                                              })
                                                        }, e.at),
                                                    tl: /* [] */0
                                                  }
                                                ];
                                              } else if (n$9 === 0) {
                                                match$2 = [
                                                  vs$p$13,
                                                  /* [] */0
                                                ];
                                              } else {
                                                var seg = elem(frame.inst, y$1).contents;
                                                var partial_arg$6 = e.at;
                                                match$2 = [
                                                  vs$p$13,
                                                  List.map((function (param) {
                                                          return Source.at(partial_arg$6, param);
                                                        }), {
                                                        hd: {
                                                          TAG: /* Plain */0,
                                                          _0: {
                                                            TAG: /* Const */32,
                                                            _0: Source.$at$at({
                                                                  TAG: /* I32 */0,
                                                                  _0: d$5
                                                                }, e.at)
                                                          }
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Refer */1,
                                                            _0: List.nth(seg, s$5)
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* TableSet */15,
                                                                _0: x$2
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Plain */0,
                                                                _0: {
                                                                  TAG: /* Const */32,
                                                                  _0: Source.$at$at({
                                                                        TAG: /* I32 */0,
                                                                        _0: Curry._2(I32.add, d$5, 1)
                                                                      }, e.at)
                                                                }
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: Curry._2(I32.add, s$5, 1)
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: {
                                                                      TAG: /* Const */32,
                                                                      _0: Source.$at$at({
                                                                            TAG: /* I32 */0,
                                                                            _0: Curry._2(I32.sub, n$9, 1)
                                                                          }, e.at)
                                                                    }
                                                                  },
                                                                  tl: {
                                                                    hd: {
                                                                      TAG: /* Plain */0,
                                                                      _0: {
                                                                        TAG: /* TableInit */20,
                                                                        _0: x$2,
                                                                        _1: y$1
                                                                      }
                                                                    },
                                                                    tl: /* [] */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      })
                                                ];
                                              }
                                            } else {
                                              exit = 1;
                                            }
                                            break;
                                        case /* Vec */1 :
                                        case /* Ref */2 :
                                            exit = 1;
                                            break;
                                        
                                      }
                                    } else {
                                      exit = 1;
                                    }
                                  } else {
                                    exit = 1;
                                  }
                                  break;
                              case /* Vec */1 :
                              case /* Ref */2 :
                                  exit = 1;
                                  break;
                              
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* ElemDrop */21 :
                var seg$1 = elem(frame.inst, e$p._0);
                seg$1.contents = /* [] */0;
                match$2 = [
                  vs,
                  /* [] */0
                ];
                break;
            case /* Load */22 :
                if (vs) {
                  var match$41 = vs.hd;
                  var match$42 = e$p._0;
                  var pack = match$42.pack;
                  var offset = match$42.offset;
                  var ty = match$42.ty;
                  switch (match$41.TAG | 0) {
                    case /* Num */0 :
                        var i$12 = match$41._0;
                        if (i$12.TAG === /* I32 */0) {
                          var vs$p$14 = vs.tl;
                          var mem$2 = memory(frame.inst, Source.$at$at(0, e.at));
                          var a = I64_convert.extend_i32_u(i$12._0);
                          try {
                            var n$10 = pack !== undefined ? Curry._3(Memory.load_num_packed(pack[0], pack[1])(mem$2), a, offset, ty) : Curry._1(Memory.load_num(mem$2, a)(offset), ty);
                            match$2 = [
                              {
                                hd: {
                                  TAG: /* Num */0,
                                  _0: n$10
                                },
                                tl: vs$p$14
                              },
                              /* [] */0
                            ];
                          }
                          catch (raw_exn$5){
                            var exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$5);
                            match$2 = [
                              vs$p$14,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Trapping */3,
                                      _0: memory_error(e.at, exn$5)
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ];
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Store */23 :
                if (vs) {
                  var n$11 = vs.hd;
                  var match$43 = e$p._0;
                  var pack$1 = match$43.pack;
                  var offset$1 = match$43.offset;
                  switch (n$11.TAG | 0) {
                    case /* Num */0 :
                        var match$44 = vs.tl;
                        if (match$44) {
                          var match$45 = match$44.hd;
                          var n$12 = n$11._0;
                          switch (match$45.TAG | 0) {
                            case /* Num */0 :
                                var i$13 = match$45._0;
                                if (i$13.TAG === /* I32 */0) {
                                  var vs$p$15 = match$44.tl;
                                  var mem$3 = memory(frame.inst, Source.$at$at(0, e.at));
                                  var a$1 = I64_convert.extend_i32_u(i$13._0);
                                  try {
                                    if (pack$1 !== undefined) {
                                      Curry._2(Memory.store_num_packed(pack$1, mem$3)(a$1), offset$1, n$12);
                                    } else {
                                      Curry._1(Memory.store_num(mem$3, a$1)(offset$1), n$12);
                                    }
                                    match$2 = [
                                      vs$p$15,
                                      /* [] */0
                                    ];
                                  }
                                  catch (raw_exn$6){
                                    var exn$6 = Caml_js_exceptions.internalToOCamlException(raw_exn$6);
                                    match$2 = [
                                      vs$p$15,
                                      {
                                        hd: Source.$at$at({
                                              TAG: /* Trapping */3,
                                              _0: memory_error(e.at, exn$6)
                                            }, e.at),
                                        tl: /* [] */0
                                      }
                                    ];
                                  }
                                } else {
                                  exit = 1;
                                }
                                break;
                            case /* Vec */1 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecLoad */24 :
                if (vs) {
                  var match$46 = vs.hd;
                  var match$47 = e$p._0;
                  var pack$2 = match$47.pack;
                  var offset$2 = match$47.offset;
                  var ty$1 = match$47.ty;
                  switch (match$46.TAG | 0) {
                    case /* Num */0 :
                        var i$14 = match$46._0;
                        if (i$14.TAG === /* I32 */0) {
                          var vs$p$16 = vs.tl;
                          var mem$4 = memory(frame.inst, Source.$at$at(0, e.at));
                          var addr = I64_convert.extend_i32_u(i$14._0);
                          try {
                            var v$1 = pack$2 !== undefined ? Memory.load_vec_packed(pack$2[0], pack$2[1], mem$4, addr, offset$2)(ty$1) : Memory.load_vec(mem$4, addr, offset$2)(ty$1);
                            match$2 = [
                              {
                                hd: {
                                  TAG: /* Vec */1,
                                  _0: v$1
                                },
                                tl: vs$p$16
                              },
                              /* [] */0
                            ];
                          }
                          catch (raw_exn$7){
                            var exn$7 = Caml_js_exceptions.internalToOCamlException(raw_exn$7);
                            match$2 = [
                              vs$p$16,
                              {
                                hd: Source.$at$at({
                                      TAG: /* Trapping */3,
                                      _0: memory_error(e.at, exn$7)
                                    }, e.at),
                                tl: /* [] */0
                              }
                            ];
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecStore */25 :
                if (vs) {
                  var v$2 = vs.hd;
                  switch (v$2.TAG | 0) {
                    case /* Vec */1 :
                        var match$48 = vs.tl;
                        if (match$48) {
                          var match$49 = match$48.hd;
                          switch (match$49.TAG | 0) {
                            case /* Num */0 :
                                var i$15 = match$49._0;
                                if (i$15.TAG === /* I32 */0) {
                                  var vs$p$17 = match$48.tl;
                                  var mem$5 = memory(frame.inst, Source.$at$at(0, e.at));
                                  var addr$1 = I64_convert.extend_i32_u(i$15._0);
                                  try {
                                    Memory.store_vec(mem$5, addr$1, e$p._0.offset)(v$2._0);
                                    match$2 = [
                                      vs$p$17,
                                      /* [] */0
                                    ];
                                  }
                                  catch (raw_exn$8){
                                    var exn$8 = Caml_js_exceptions.internalToOCamlException(raw_exn$8);
                                    match$2 = [
                                      vs$p$17,
                                      {
                                        hd: Source.$at$at({
                                              TAG: /* Trapping */3,
                                              _0: memory_error(e.at, exn$8)
                                            }, e.at),
                                        tl: /* [] */0
                                      }
                                    ];
                                  }
                                } else {
                                  exit = 1;
                                }
                                break;
                            case /* Vec */1 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecLoadLane */26 :
                if (vs) {
                  var match$50 = vs.hd;
                  var match$51 = e$p._0;
                  var j = match$51[1];
                  var match$52 = match$51[0];
                  var offset$3 = match$52.offset;
                  switch (match$50.TAG | 0) {
                    case /* Vec */1 :
                        var match$53 = vs.tl;
                        if (match$53) {
                          var match$54 = match$53.hd;
                          var v$3 = match$50._0._0;
                          switch (match$54.TAG | 0) {
                            case /* Num */0 :
                                var i$16 = match$54._0;
                                if (i$16.TAG === /* I32 */0) {
                                  var vs$p$18 = match$53.tl;
                                  var mem$6 = memory(frame.inst, Source.$at$at(0, e.at));
                                  var addr$2 = I64_convert.extend_i32_u(i$16._0);
                                  try {
                                    var v$4;
                                    switch (match$52.pack) {
                                      case /* Pack8 */0 :
                                          v$4 = Curry._3(V128.I8x16.replace_lane, j, v$3, Values.I32Num.of_num(0, Curry._3(Memory.load_num_packed(/* Pack8 */0, /* SX */0)(mem$6), addr$2, offset$3, /* I32Type */0)));
                                          break;
                                      case /* Pack16 */1 :
                                          v$4 = Curry._3(V128.I16x8.replace_lane, j, v$3, Values.I32Num.of_num(0, Curry._3(Memory.load_num_packed(/* Pack16 */1, /* SX */0)(mem$6), addr$2, offset$3, /* I32Type */0)));
                                          break;
                                      case /* Pack32 */2 :
                                          v$4 = Curry._3(V128.I32x4.replace_lane, j, v$3, Values.I32Num.of_num(0, Curry._1(Memory.load_num(mem$6, addr$2)(offset$3), /* I32Type */0)));
                                          break;
                                      case /* Pack64 */3 :
                                          v$4 = Curry._3(V128.I64x2.replace_lane, j, v$3, Values.I64Num.of_num(0, Curry._1(Memory.load_num(mem$6, addr$2)(offset$3), /* I64Type */1)));
                                          break;
                                      
                                    }
                                    match$2 = [
                                      {
                                        hd: {
                                          TAG: /* Vec */1,
                                          _0: /* V128 */{
                                            _0: v$4
                                          }
                                        },
                                        tl: vs$p$18
                                      },
                                      /* [] */0
                                    ];
                                  }
                                  catch (raw_exn$9){
                                    var exn$9 = Caml_js_exceptions.internalToOCamlException(raw_exn$9);
                                    match$2 = [
                                      vs$p$18,
                                      {
                                        hd: Source.$at$at({
                                              TAG: /* Trapping */3,
                                              _0: memory_error(e.at, exn$9)
                                            }, e.at),
                                        tl: /* [] */0
                                      }
                                    ];
                                  }
                                } else {
                                  exit = 1;
                                }
                                break;
                            case /* Vec */1 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecStoreLane */27 :
                if (vs) {
                  var match$55 = vs.hd;
                  var match$56 = e$p._0;
                  var j$1 = match$56[1];
                  var match$57 = match$56[0];
                  var offset$4 = match$57.offset;
                  switch (match$55.TAG | 0) {
                    case /* Vec */1 :
                        var match$58 = vs.tl;
                        if (match$58) {
                          var match$59 = match$58.hd;
                          var v$5 = match$55._0._0;
                          switch (match$59.TAG | 0) {
                            case /* Num */0 :
                                var i$17 = match$59._0;
                                if (i$17.TAG === /* I32 */0) {
                                  var vs$p$19 = match$58.tl;
                                  var mem$7 = memory(frame.inst, Source.$at$at(0, e.at));
                                  var addr$3 = I64_convert.extend_i32_u(i$17._0);
                                  try {
                                    switch (match$57.pack) {
                                      case /* Pack8 */0 :
                                          Curry._2(Memory.store_num_packed(/* Pack8 */0, mem$7)(addr$3), offset$4, {
                                                TAG: /* I32 */0,
                                                _0: Curry._2(V128.I8x16.extract_lane_s, j$1, v$5)
                                              });
                                          break;
                                      case /* Pack16 */1 :
                                          Curry._2(Memory.store_num_packed(/* Pack16 */1, mem$7)(addr$3), offset$4, {
                                                TAG: /* I32 */0,
                                                _0: Curry._2(V128.I16x8.extract_lane_s, j$1, v$5)
                                              });
                                          break;
                                      case /* Pack32 */2 :
                                          Curry._1(Memory.store_num(mem$7, addr$3)(offset$4), {
                                                TAG: /* I32 */0,
                                                _0: Curry._2(V128.I32x4.extract_lane_s, j$1, v$5)
                                              });
                                          break;
                                      case /* Pack64 */3 :
                                          Curry._1(Memory.store_num(mem$7, addr$3)(offset$4), {
                                                TAG: /* I64 */1,
                                                _0: Curry._2(V128.I64x2.extract_lane_s, j$1, v$5)
                                              });
                                          break;
                                      
                                    }
                                    match$2 = [
                                      vs$p$19,
                                      /* [] */0
                                    ];
                                  }
                                  catch (raw_exn$10){
                                    var exn$10 = Caml_js_exceptions.internalToOCamlException(raw_exn$10);
                                    match$2 = [
                                      vs$p$19,
                                      {
                                        hd: Source.$at$at({
                                              TAG: /* Trapping */3,
                                              _0: memory_error(e.at, exn$10)
                                            }, e.at),
                                        tl: /* [] */0
                                      }
                                    ];
                                  }
                                } else {
                                  exit = 1;
                                }
                                break;
                            case /* Vec */1 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* MemoryInit */28 :
                if (vs) {
                  var match$60 = vs.hd;
                  var x$3 = e$p._0;
                  switch (match$60.TAG | 0) {
                    case /* Num */0 :
                        var n$13 = match$60._0;
                        if (n$13.TAG === /* I32 */0) {
                          var match$61 = vs.tl;
                          if (match$61) {
                            var match$62 = match$61.hd;
                            var n$14 = n$13._0;
                            switch (match$62.TAG | 0) {
                              case /* Num */0 :
                                  var s$6 = match$62._0;
                                  if (s$6.TAG === /* I32 */0) {
                                    var match$63 = match$61.tl;
                                    if (match$63) {
                                      var match$64 = match$63.hd;
                                      var s$7 = s$6._0;
                                      switch (match$64.TAG | 0) {
                                        case /* Num */0 :
                                            var d$6 = match$64._0;
                                            if (d$6.TAG === /* I32 */0) {
                                              var vs$p$20 = match$63.tl;
                                              var d$7 = d$6._0;
                                              if (mem_oob(frame, Source.$at$at(0, e.at), d$7, n$14) || data_oob(frame, x$3, s$7, n$14)) {
                                                match$2 = [
                                                  vs$p$20,
                                                  {
                                                    hd: Source.$at$at({
                                                          TAG: /* Trapping */3,
                                                          _0: memory_error(e.at, {
                                                                RE_EXN_ID: Memory.Bounds
                                                              })
                                                        }, e.at),
                                                    tl: /* [] */0
                                                  }
                                                ];
                                              } else if (n$14 === 0) {
                                                match$2 = [
                                                  vs$p$20,
                                                  /* [] */0
                                                ];
                                              } else {
                                                var seg$2 = data(frame.inst, x$3).contents;
                                                var b = Caml_string.get(seg$2, s$7);
                                                var partial_arg$7 = e.at;
                                                match$2 = [
                                                  vs$p$20,
                                                  List.map((function (param) {
                                                          return Source.at(partial_arg$7, param);
                                                        }), {
                                                        hd: {
                                                          TAG: /* Plain */0,
                                                          _0: {
                                                            TAG: /* Const */32,
                                                            _0: Source.$at$at({
                                                                  TAG: /* I32 */0,
                                                                  _0: d$7
                                                                }, e.at)
                                                          }
                                                        },
                                                        tl: {
                                                          hd: {
                                                            TAG: /* Plain */0,
                                                            _0: {
                                                              TAG: /* Const */32,
                                                              _0: Source.$at$at({
                                                                    TAG: /* I32 */0,
                                                                    _0: b
                                                                  }, e.at)
                                                            }
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Plain */0,
                                                              _0: {
                                                                TAG: /* Store */23,
                                                                _0: {
                                                                  ty: /* I32Type */0,
                                                                  align: 0,
                                                                  offset: 0,
                                                                  pack: /* Pack8 */0
                                                                }
                                                              }
                                                            },
                                                            tl: {
                                                              hd: {
                                                                TAG: /* Plain */0,
                                                                _0: {
                                                                  TAG: /* Const */32,
                                                                  _0: Source.$at$at({
                                                                        TAG: /* I32 */0,
                                                                        _0: Curry._2(I32.add, d$7, 1)
                                                                      }, e.at)
                                                                }
                                                              },
                                                              tl: {
                                                                hd: {
                                                                  TAG: /* Plain */0,
                                                                  _0: {
                                                                    TAG: /* Const */32,
                                                                    _0: Source.$at$at({
                                                                          TAG: /* I32 */0,
                                                                          _0: Curry._2(I32.add, s$7, 1)
                                                                        }, e.at)
                                                                  }
                                                                },
                                                                tl: {
                                                                  hd: {
                                                                    TAG: /* Plain */0,
                                                                    _0: {
                                                                      TAG: /* Const */32,
                                                                      _0: Source.$at$at({
                                                                            TAG: /* I32 */0,
                                                                            _0: Curry._2(I32.sub, n$14, 1)
                                                                          }, e.at)
                                                                    }
                                                                  },
                                                                  tl: {
                                                                    hd: {
                                                                      TAG: /* Plain */0,
                                                                      _0: {
                                                                        TAG: /* MemoryInit */28,
                                                                        _0: x$3
                                                                      }
                                                                    },
                                                                    tl: /* [] */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      })
                                                ];
                                              }
                                            } else {
                                              exit = 1;
                                            }
                                            break;
                                        case /* Vec */1 :
                                        case /* Ref */2 :
                                            exit = 1;
                                            break;
                                        
                                      }
                                    } else {
                                      exit = 1;
                                    }
                                  } else {
                                    exit = 1;
                                  }
                                  break;
                              case /* Vec */1 :
                              case /* Ref */2 :
                                  exit = 1;
                                  break;
                              
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* DataDrop */29 :
                var seg$3 = data(frame.inst, e$p._0);
                seg$3.contents = "";
                match$2 = [
                  vs,
                  /* [] */0
                ];
                break;
            case /* RefNull */30 :
                match$2 = [
                  {
                    hd: {
                      TAG: /* Ref */2,
                      _0: {
                        RE_EXN_ID: Values.NullRef,
                        _1: e$p._0
                      }
                    },
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* RefFunc */31 :
                var f = func(frame.inst, e$p._0);
                match$2 = [
                  {
                    hd: {
                      TAG: /* Ref */2,
                      _0: {
                        RE_EXN_ID: Instance.FuncRef,
                        _1: f
                      }
                    },
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* Const */32 :
                match$2 = [
                  {
                    hd: {
                      TAG: /* Num */0,
                      _0: e$p._0.it
                    },
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* Test */33 :
                if (vs) {
                  var n$15 = vs.hd;
                  switch (n$15.TAG | 0) {
                    case /* Num */0 :
                        var vs$p$21 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: Values.value_of_bool(Curry._1(Eval_num.eval_testop(e$p._0), n$15._0)),
                              tl: vs$p$21
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$11){
                          var exn$11 = Caml_js_exceptions.internalToOCamlException(raw_exn$11);
                          match$2 = [
                            vs$p$21,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$11)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Compare */34 :
                if (vs) {
                  var n2$1 = vs.hd;
                  switch (n2$1.TAG | 0) {
                    case /* Num */0 :
                        var match$65 = vs.tl;
                        if (match$65) {
                          var n1$2 = match$65.hd;
                          switch (n1$2.TAG | 0) {
                            case /* Num */0 :
                                var vs$p$22 = match$65.tl;
                                try {
                                  match$2 = [
                                    {
                                      hd: Values.value_of_bool(Curry._2(Eval_num.eval_relop(e$p._0), n1$2._0, n2$1._0)),
                                      tl: vs$p$22
                                    },
                                    /* [] */0
                                  ];
                                }
                                catch (raw_exn$12){
                                  var exn$12 = Caml_js_exceptions.internalToOCamlException(raw_exn$12);
                                  match$2 = [
                                    vs$p$22,
                                    {
                                      hd: Source.$at$at({
                                            TAG: /* Trapping */3,
                                            _0: numeric_error(e.at, exn$12)
                                          }, e.at),
                                      tl: /* [] */0
                                    }
                                  ];
                                }
                                break;
                            case /* Vec */1 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Unary */35 :
                if (vs) {
                  var n$16 = vs.hd;
                  switch (n$16.TAG | 0) {
                    case /* Num */0 :
                        var vs$p$23 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Num */0,
                                _0: Curry._1(Eval_num.eval_unop(e$p._0), n$16._0)
                              },
                              tl: vs$p$23
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$13){
                          var exn$13 = Caml_js_exceptions.internalToOCamlException(raw_exn$13);
                          match$2 = [
                            vs$p$23,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$13)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Binary */36 :
                if (vs) {
                  var n2$2 = vs.hd;
                  switch (n2$2.TAG | 0) {
                    case /* Num */0 :
                        var match$66 = vs.tl;
                        if (match$66) {
                          var n1$3 = match$66.hd;
                          switch (n1$3.TAG | 0) {
                            case /* Num */0 :
                                var vs$p$24 = match$66.tl;
                                try {
                                  match$2 = [
                                    {
                                      hd: {
                                        TAG: /* Num */0,
                                        _0: Curry._2(Eval_num.eval_binop(e$p._0), n1$3._0, n2$2._0)
                                      },
                                      tl: vs$p$24
                                    },
                                    /* [] */0
                                  ];
                                }
                                catch (raw_exn$14){
                                  var exn$14 = Caml_js_exceptions.internalToOCamlException(raw_exn$14);
                                  match$2 = [
                                    vs$p$24,
                                    {
                                      hd: Source.$at$at({
                                            TAG: /* Trapping */3,
                                            _0: numeric_error(e.at, exn$14)
                                          }, e.at),
                                      tl: /* [] */0
                                    }
                                  ];
                                }
                                break;
                            case /* Vec */1 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* Convert */37 :
                if (vs) {
                  var n$17 = vs.hd;
                  switch (n$17.TAG | 0) {
                    case /* Num */0 :
                        var vs$p$25 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Num */0,
                                _0: Curry._1(Eval_num.eval_cvtop(e$p._0), n$17._0)
                              },
                              tl: vs$p$25
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$15){
                          var exn$15 = Caml_js_exceptions.internalToOCamlException(raw_exn$15);
                          match$2 = [
                            vs$p$25,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$15)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecConst */38 :
                match$2 = [
                  {
                    hd: {
                      TAG: /* Vec */1,
                      _0: e$p._0.it
                    },
                    tl: vs
                  },
                  /* [] */0
                ];
                break;
            case /* VecTest */39 :
                if (vs) {
                  var n$18 = vs.hd;
                  switch (n$18.TAG | 0) {
                    case /* Vec */1 :
                        var vs$p$26 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: Values.value_of_bool(Curry._1(Eval_vec.eval_testop(e$p._0), n$18._0)),
                              tl: vs$p$26
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$16){
                          var exn$16 = Caml_js_exceptions.internalToOCamlException(raw_exn$16);
                          match$2 = [
                            vs$p$26,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$16)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecCompare */40 :
                if (vs) {
                  var n2$3 = vs.hd;
                  switch (n2$3.TAG | 0) {
                    case /* Vec */1 :
                        var match$67 = vs.tl;
                        if (match$67) {
                          var n1$4 = match$67.hd;
                          switch (n1$4.TAG | 0) {
                            case /* Vec */1 :
                                var vs$p$27 = match$67.tl;
                                try {
                                  match$2 = [
                                    {
                                      hd: {
                                        TAG: /* Vec */1,
                                        _0: Curry._2(Eval_vec.eval_relop(e$p._0), n1$4._0, n2$3._0)
                                      },
                                      tl: vs$p$27
                                    },
                                    /* [] */0
                                  ];
                                }
                                catch (raw_exn$17){
                                  var exn$17 = Caml_js_exceptions.internalToOCamlException(raw_exn$17);
                                  match$2 = [
                                    vs$p$27,
                                    {
                                      hd: Source.$at$at({
                                            TAG: /* Trapping */3,
                                            _0: numeric_error(e.at, exn$17)
                                          }, e.at),
                                      tl: /* [] */0
                                    }
                                  ];
                                }
                                break;
                            case /* Num */0 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecUnary */41 :
                if (vs) {
                  var n$19 = vs.hd;
                  switch (n$19.TAG | 0) {
                    case /* Vec */1 :
                        var vs$p$28 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Vec */1,
                                _0: Curry._1(Eval_vec.eval_unop(e$p._0), n$19._0)
                              },
                              tl: vs$p$28
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$18){
                          var exn$18 = Caml_js_exceptions.internalToOCamlException(raw_exn$18);
                          match$2 = [
                            vs$p$28,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$18)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecBinary */42 :
                if (vs) {
                  var n2$4 = vs.hd;
                  switch (n2$4.TAG | 0) {
                    case /* Vec */1 :
                        var match$68 = vs.tl;
                        if (match$68) {
                          var n1$5 = match$68.hd;
                          switch (n1$5.TAG | 0) {
                            case /* Vec */1 :
                                var vs$p$29 = match$68.tl;
                                try {
                                  match$2 = [
                                    {
                                      hd: {
                                        TAG: /* Vec */1,
                                        _0: Curry._2(Eval_vec.eval_binop(e$p._0), n1$5._0, n2$4._0)
                                      },
                                      tl: vs$p$29
                                    },
                                    /* [] */0
                                  ];
                                }
                                catch (raw_exn$19){
                                  var exn$19 = Caml_js_exceptions.internalToOCamlException(raw_exn$19);
                                  match$2 = [
                                    vs$p$29,
                                    {
                                      hd: Source.$at$at({
                                            TAG: /* Trapping */3,
                                            _0: numeric_error(e.at, exn$19)
                                          }, e.at),
                                      tl: /* [] */0
                                    }
                                  ];
                                }
                                break;
                            case /* Num */0 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecConvert */43 :
                if (vs) {
                  var n$20 = vs.hd;
                  switch (n$20.TAG | 0) {
                    case /* Vec */1 :
                        var vs$p$30 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Vec */1,
                                _0: Curry._1(Eval_vec.eval_cvtop(e$p._0), n$20._0)
                              },
                              tl: vs$p$30
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$20){
                          var exn$20 = Caml_js_exceptions.internalToOCamlException(raw_exn$20);
                          match$2 = [
                            vs$p$30,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$20)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecShift */44 :
                if (vs) {
                  var s$8 = vs.hd;
                  switch (s$8.TAG | 0) {
                    case /* Num */0 :
                        var match$69 = vs.tl;
                        if (match$69) {
                          var v$6 = match$69.hd;
                          switch (v$6.TAG | 0) {
                            case /* Vec */1 :
                                var vs$p$31 = match$69.tl;
                                try {
                                  match$2 = [
                                    {
                                      hd: {
                                        TAG: /* Vec */1,
                                        _0: Curry._2(Eval_vec.eval_shiftop(e$p._0), v$6._0, s$8._0)
                                      },
                                      tl: vs$p$31
                                    },
                                    /* [] */0
                                  ];
                                }
                                catch (raw_exn$21){
                                  var exn$21 = Caml_js_exceptions.internalToOCamlException(raw_exn$21);
                                  match$2 = [
                                    vs$p$31,
                                    {
                                      hd: Source.$at$at({
                                            TAG: /* Trapping */3,
                                            _0: numeric_error(e.at, exn$21)
                                          }, e.at),
                                      tl: /* [] */0
                                    }
                                  ];
                                }
                                break;
                            case /* Num */0 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecBitmask */45 :
                if (vs) {
                  var v$7 = vs.hd;
                  switch (v$7.TAG | 0) {
                    case /* Vec */1 :
                        var vs$p$32 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Num */0,
                                _0: Curry._1(Eval_vec.eval_bitmaskop(e$p._0), v$7._0)
                              },
                              tl: vs$p$32
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$22){
                          var exn$22 = Caml_js_exceptions.internalToOCamlException(raw_exn$22);
                          match$2 = [
                            vs$p$32,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$22)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecTestBits */46 :
                if (vs) {
                  var n$21 = vs.hd;
                  switch (n$21.TAG | 0) {
                    case /* Vec */1 :
                        var vs$p$33 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: Values.value_of_bool(Curry._1(Eval_vec.eval_vtestop(e$p._0), n$21._0)),
                              tl: vs$p$33
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$23){
                          var exn$23 = Caml_js_exceptions.internalToOCamlException(raw_exn$23);
                          match$2 = [
                            vs$p$33,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$23)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecUnaryBits */47 :
                if (vs) {
                  var n$22 = vs.hd;
                  switch (n$22.TAG | 0) {
                    case /* Vec */1 :
                        var vs$p$34 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Vec */1,
                                _0: Curry._1(Eval_vec.eval_vunop(e$p._0), n$22._0)
                              },
                              tl: vs$p$34
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$24){
                          var exn$24 = Caml_js_exceptions.internalToOCamlException(raw_exn$24);
                          match$2 = [
                            vs$p$34,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$24)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecBinaryBits */48 :
                if (vs) {
                  var n2$5 = vs.hd;
                  switch (n2$5.TAG | 0) {
                    case /* Vec */1 :
                        var match$70 = vs.tl;
                        if (match$70) {
                          var n1$6 = match$70.hd;
                          switch (n1$6.TAG | 0) {
                            case /* Vec */1 :
                                var vs$p$35 = match$70.tl;
                                try {
                                  match$2 = [
                                    {
                                      hd: {
                                        TAG: /* Vec */1,
                                        _0: Curry._2(Eval_vec.eval_vbinop(e$p._0), n1$6._0, n2$5._0)
                                      },
                                      tl: vs$p$35
                                    },
                                    /* [] */0
                                  ];
                                }
                                catch (raw_exn$25){
                                  var exn$25 = Caml_js_exceptions.internalToOCamlException(raw_exn$25);
                                  match$2 = [
                                    vs$p$35,
                                    {
                                      hd: Source.$at$at({
                                            TAG: /* Trapping */3,
                                            _0: numeric_error(e.at, exn$25)
                                          }, e.at),
                                      tl: /* [] */0
                                    }
                                  ];
                                }
                                break;
                            case /* Num */0 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecTernaryBits */49 :
                if (vs) {
                  var v3 = vs.hd;
                  switch (v3.TAG | 0) {
                    case /* Vec */1 :
                        var match$71 = vs.tl;
                        if (match$71) {
                          var v2 = match$71.hd;
                          switch (v2.TAG | 0) {
                            case /* Vec */1 :
                                var match$72 = match$71.tl;
                                if (match$72) {
                                  var v1 = match$72.hd;
                                  switch (v1.TAG | 0) {
                                    case /* Vec */1 :
                                        var vs$p$36 = match$72.tl;
                                        try {
                                          match$2 = [
                                            {
                                              hd: {
                                                TAG: /* Vec */1,
                                                _0: Curry._3(Eval_vec.eval_vternop(e$p._0), v1._0, v2._0, v3._0)
                                              },
                                              tl: vs$p$36
                                            },
                                            /* [] */0
                                          ];
                                        }
                                        catch (raw_exn$26){
                                          var exn$26 = Caml_js_exceptions.internalToOCamlException(raw_exn$26);
                                          match$2 = [
                                            vs$p$36,
                                            {
                                              hd: Source.$at$at({
                                                    TAG: /* Trapping */3,
                                                    _0: numeric_error(e.at, exn$26)
                                                  }, e.at),
                                              tl: /* [] */0
                                            }
                                          ];
                                        }
                                        break;
                                    case /* Num */0 :
                                    case /* Ref */2 :
                                        exit = 1;
                                        break;
                                    
                                  }
                                } else {
                                  exit = 1;
                                }
                                break;
                            case /* Num */0 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecSplat */50 :
                if (vs) {
                  var n$23 = vs.hd;
                  switch (n$23.TAG | 0) {
                    case /* Num */0 :
                        var vs$p$37 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Vec */1,
                                _0: Curry._1(Eval_vec.eval_splatop(e$p._0), n$23._0)
                              },
                              tl: vs$p$37
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$27){
                          var exn$27 = Caml_js_exceptions.internalToOCamlException(raw_exn$27);
                          match$2 = [
                            vs$p$37,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$27)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecExtract */51 :
                if (vs) {
                  var v$8 = vs.hd;
                  switch (v$8.TAG | 0) {
                    case /* Vec */1 :
                        var vs$p$38 = vs.tl;
                        try {
                          match$2 = [
                            {
                              hd: {
                                TAG: /* Num */0,
                                _0: Curry._1(Eval_vec.eval_extractop(e$p._0), v$8._0)
                              },
                              tl: vs$p$38
                            },
                            /* [] */0
                          ];
                        }
                        catch (raw_exn$28){
                          var exn$28 = Caml_js_exceptions.internalToOCamlException(raw_exn$28);
                          match$2 = [
                            vs$p$38,
                            {
                              hd: Source.$at$at({
                                    TAG: /* Trapping */3,
                                    _0: numeric_error(e.at, exn$28)
                                  }, e.at),
                              tl: /* [] */0
                            }
                          ];
                        }
                        break;
                    case /* Num */0 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            case /* VecReplace */52 :
                if (vs) {
                  var r$5 = vs.hd;
                  switch (r$5.TAG | 0) {
                    case /* Num */0 :
                        var match$73 = vs.tl;
                        if (match$73) {
                          var v$9 = match$73.hd;
                          switch (v$9.TAG | 0) {
                            case /* Vec */1 :
                                var vs$p$39 = match$73.tl;
                                try {
                                  match$2 = [
                                    {
                                      hd: {
                                        TAG: /* Vec */1,
                                        _0: Curry._2(Eval_vec.eval_replaceop(e$p._0), v$9._0, r$5._0)
                                      },
                                      tl: vs$p$39
                                    },
                                    /* [] */0
                                  ];
                                }
                                catch (raw_exn$29){
                                  var exn$29 = Caml_js_exceptions.internalToOCamlException(raw_exn$29);
                                  match$2 = [
                                    vs$p$39,
                                    {
                                      hd: Source.$at$at({
                                            TAG: /* Trapping */3,
                                            _0: numeric_error(e.at, exn$29)
                                          }, e.at),
                                      tl: /* [] */0
                                    }
                                  ];
                                }
                                break;
                            case /* Num */0 :
                            case /* Ref */2 :
                                exit = 1;
                                break;
                            
                          }
                        } else {
                          exit = 1;
                        }
                        break;
                    case /* Vec */1 :
                    case /* Ref */2 :
                        exit = 1;
                        break;
                    
                  }
                } else {
                  exit = 1;
                }
                break;
            
          }
        }
        if (exit === 1) {
          var s1 = Values.string_of_values(List.rev(vs));
          var s2 = Types.string_of_value_types(List.map(Values.type_of_value, List.rev(vs)));
          match$2 = Curry._2(Crash.error, e.at, "missing or ill-typed operand on stack (" + (s1 + (" : " + (s2 + ")"))));
        }
        break;
    case /* Refer */1 :
        match$2 = [
          {
            hd: {
              TAG: /* Ref */2,
              _0: match$1._0
            },
            tl: vs
          },
          /* [] */0
        ];
        break;
    case /* Invoke */2 :
        var func$2 = match$1._0;
        if (c.budget === 0) {
          match$2 = Curry._2(Exhaustion.error, e.at, "call stack exhausted");
        } else {
          var match$74 = func_type_of(func$2);
          var n1$7 = Lib.List32.length(match$74._0);
          var n2$6 = Lib.List32.length(match$74._1);
          var args$2 = take(n1$7, vs, e.at);
          var vs$p$40 = drop(n1$7, vs, e.at);
          if (func$2.TAG === /* AstFunc */0) {
            var f$1 = func$2._2;
            var locals$p = Pervasives.$at(List.rev(args$2), List.map(Values.default_value, f$1.it.locals));
            var frame$p_inst = func$2._1.contents;
            var frame$p_locals = List.map((function (prim) {
                    return {
                            contents: prim
                          };
                  }), locals$p);
            var frame$p = {
              inst: frame$p_inst,
              locals: frame$p_locals
            };
            var instr$p_0 = Source.$at$at({
                  TAG: /* Label */6,
                  _0: n2$6,
                  _1: /* [] */0,
                  _2: [
                    /* [] */0,
                    List.map(plain, f$1.it.body)
                  ]
                }, f$1.at);
            var instr$p = {
              hd: instr$p_0,
              tl: /* [] */0
            };
            match$2 = [
              vs$p$40,
              {
                hd: Source.$at$at({
                      TAG: /* Frame */7,
                      _0: n2$6,
                      _1: frame$p,
                      _2: [
                        /* [] */0,
                        instr$p
                      ]
                    }, e.at),
                tl: /* [] */0
              }
            ];
          } else {
            try {
              match$2 = [
                Pervasives.$at(List.rev(Curry._1(func$2._1, List.rev(args$2))), vs$p$40),
                /* [] */0
              ];
            }
            catch (raw_exn$30){
              var exn$30 = Caml_js_exceptions.internalToOCamlException(raw_exn$30);
              if (exn$30.RE_EXN_ID === Crash$1) {
                match$2 = Curry._2(Crash.error, e.at, exn$30._2);
              } else {
                throw exn$30;
              }
            }
          }
        }
        break;
    case /* Trapping */3 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "eval.ml",
                594,
                6
              ],
              Error: new Error()
            };
    case /* Returning */4 :
        match$2 = Curry._2(Crash.error, e.at, "undefined frame");
        break;
    case /* Breaking */5 :
        match$2 = Curry._2(Crash.error, e.at, "undefined label");
        break;
    case /* Label */6 :
        var code$p = match$1._2;
        var match$75 = code$p[1];
        var es0 = match$1._1;
        var n$24 = match$1._0;
        if (match$75) {
          var match$76 = match$75.hd;
          var msg = match$76.it;
          var at = match$76.at;
          switch (msg.TAG | 0) {
            case /* Trapping */3 :
                match$2 = [
                  vs,
                  {
                    hd: Source.$at$at({
                          TAG: /* Trapping */3,
                          _0: msg._0
                        }, at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* Returning */4 :
                match$2 = [
                  vs,
                  {
                    hd: Source.$at$at({
                          TAG: /* Returning */4,
                          _0: msg._0
                        }, at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* Breaking */5 :
                var k$2 = msg._0;
                match$2 = k$2 !== 0 ? [
                    vs,
                    {
                      hd: Source.$at$at({
                            TAG: /* Breaking */5,
                            _0: k$2 - 1 | 0,
                            _1: msg._1
                          }, at),
                      tl: /* [] */0
                    }
                  ] : [
                    Pervasives.$at(take(n$24, msg._1, e.at), vs),
                    List.map(plain, es0)
                  ];
                break;
            default:
              var c$p = step({
                    frame: c.frame,
                    code: code$p,
                    budget: c.budget
                  });
              match$2 = [
                vs,
                {
                  hd: Source.$at$at({
                        TAG: /* Label */6,
                        _0: n$24,
                        _1: es0,
                        _2: c$p.code
                      }, e.at),
                  tl: /* [] */0
                }
              ];
          }
        } else {
          match$2 = [
            Pervasives.$at(code$p[0], vs),
            /* [] */0
          ];
        }
        break;
    case /* Frame */7 :
        var code$p$1 = match$1._2;
        var match$77 = code$p$1[1];
        var n$25 = match$1._0;
        if (match$77) {
          var match$78 = match$77.hd;
          var msg$1 = match$78.it;
          switch (msg$1.TAG | 0) {
            case /* Trapping */3 :
                match$2 = [
                  vs,
                  {
                    hd: Source.$at$at({
                          TAG: /* Trapping */3,
                          _0: msg$1._0
                        }, match$78.at),
                    tl: /* [] */0
                  }
                ];
                break;
            case /* Returning */4 :
                match$2 = [
                  Pervasives.$at(take(n$25, msg$1._0, e.at), vs),
                  /* [] */0
                ];
                break;
            default:
              var c$p$1 = step({
                    frame: match$1._1,
                    code: code$p$1,
                    budget: c.budget - 1 | 0
                  });
              match$2 = [
                vs,
                {
                  hd: Source.$at$at({
                        TAG: /* Frame */7,
                        _0: n$25,
                        _1: c$p$1.frame,
                        _2: c$p$1.code
                      }, e.at),
                  tl: /* [] */0
                }
              ];
          }
        } else {
          match$2 = [
            Pervasives.$at(code$p$1[0], vs),
            /* [] */0
          ];
        }
        break;
    
  }
  return {
          frame: c.frame,
          code: [
            match$2[0],
            Pervasives.$at(match$2[1], List.tl(es))
          ],
          budget: c.budget
        };
}

function $$eval(_c) {
  while(true) {
    var c = _c;
    var match = c.code;
    var es = match[1];
    if (!es) {
      return match[0];
    }
    var match$1 = es.hd;
    var msg = match$1.it;
    if (msg.TAG === /* Trapping */3) {
      return Curry._2(Trap.error, match$1.at, msg._0);
    }
    _c = step(c);
    continue ;
  };
}

function invoke(func, vs) {
  var at;
  at = func.TAG === /* AstFunc */0 ? func._2.at : Source.no_region;
  var match = Func.type_of(func);
  var ins = match._0;
  if (List.length(vs) !== List.length(ins)) {
    Curry._2(Crash.error, at, "wrong number of arguments");
  }
  if (!List.for_all2((function (v) {
            var partial_arg = Values.type_of_value(v);
            return function (param) {
              return Caml_obj.caml_equal(partial_arg, param);
            };
          }), vs, ins)) {
    Curry._2(Crash.error, at, "wrong types of arguments");
  }
  var c = config(Instance.empty_module_inst, List.rev(vs), {
        hd: Source.$at$at({
              TAG: /* Invoke */2,
              _0: func
            }, at),
        tl: /* [] */0
      });
  try {
    return List.rev($$eval(c));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Stack_overflow") {
      return Curry._2(Exhaustion.error, at, "call stack exhausted");
    }
    throw exn;
  }
}

function eval_const(inst, $$const) {
  var c = config(inst, /* [] */0, List.map(plain, $$const.it));
  var vs = $$eval(c);
  if (vs && !vs.tl) {
    return vs.hd;
  } else {
    return Curry._2(Crash.error, $$const.at, "wrong number of results on stack");
  }
}

function run_elem(i, elem) {
  var at = elem.it.emode.at;
  var x = Source.$at$at(i, at);
  var match = elem.it.emode.it;
  if (typeof match === "number") {
    if (match !== 0) {
      return {
              hd: Source.$at$at({
                    TAG: /* ElemDrop */21,
                    _0: x
                  }, at),
              tl: /* [] */0
            };
    } else {
      return /* [] */0;
    }
  } else {
    return Pervasives.$at(match.offset.it, {
                hd: Source.$at$at({
                      TAG: /* Const */32,
                      _0: Source.$at$at({
                            TAG: /* I32 */0,
                            _0: 0
                          }, at)
                    }, at),
                tl: {
                  hd: Source.$at$at({
                        TAG: /* Const */32,
                        _0: Source.$at$at({
                              TAG: /* I32 */0,
                              _0: Lib.List32.length(elem.it.einit)
                            }, at)
                      }, at),
                  tl: {
                    hd: Source.$at$at({
                          TAG: /* TableInit */20,
                          _0: match.index,
                          _1: x
                        }, at),
                    tl: {
                      hd: Source.$at$at({
                            TAG: /* ElemDrop */21,
                            _0: x
                          }, at),
                      tl: /* [] */0
                    }
                  }
                }
              });
  }
}

function run_data(i, data) {
  var at = data.it.dmode.at;
  var x = Source.$at$at(i, at);
  var match = data.it.dmode.it;
  if (typeof match === "number") {
    if (match === 0) {
      return /* [] */0;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "eval.ml",
            772,
            19
          ],
          Error: new Error()
        };
  }
  if (match.index.it !== 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "eval.ml",
            765,
            4
          ],
          Error: new Error()
        };
  }
  return Pervasives.$at(match.offset.it, {
              hd: Source.$at$at({
                    TAG: /* Const */32,
                    _0: Source.$at$at({
                          TAG: /* I32 */0,
                          _0: 0
                        }, at)
                  }, at),
              tl: {
                hd: Source.$at$at({
                      TAG: /* Const */32,
                      _0: Source.$at$at({
                            TAG: /* I32 */0,
                            _0: data.it.dinit.length
                          }, at)
                    }, at),
                tl: {
                  hd: Source.$at$at({
                        TAG: /* MemoryInit */28,
                        _0: x
                      }, at),
                  tl: {
                    hd: Source.$at$at({
                          TAG: /* DataDrop */29,
                          _0: x
                        }, at),
                    tl: /* [] */0
                  }
                }
              }
            });
}

function run_start(start) {
  return {
          hd: Source.$at$at({
                TAG: /* Call */7,
                _0: start.it.sfunc
              }, start.at),
          tl: /* [] */0
        };
}

function init(m, exts) {
  var match = m.it;
  var imports = match.imports;
  var datas = match.datas;
  var elems = match.elems;
  if (List.length(exts) !== List.length(imports)) {
    Curry._2(Link.error, m.at, "wrong number of imports provided for initialisation");
  }
  var init$1 = List.fold_right2((function (param, param$1, param$2) {
          if (!Types.match_extern_type(Instance.extern_type_of(param), Ast.import_type(m, param$1))) {
            Curry._2(Link.error, param$1.at, "incompatible import type for \"" + (Utf8.encode(param$1.it.module_name) + ("\" \"" + (Utf8.encode(param$1.it.item_name) + ("\": expected " + (Types.string_of_extern_type(Ast.import_type(m, param$1)) + (", got " + Types.string_of_extern_type(Instance.extern_type_of(param)))))))));
          }
          switch (param.TAG | 0) {
            case /* ExternFunc */0 :
                return {
                        types: param$2.types,
                        funcs: {
                          hd: param._0,
                          tl: param$2.funcs
                        },
                        tables: param$2.tables,
                        memories: param$2.memories,
                        globals: param$2.globals,
                        exports: param$2.exports,
                        elems: param$2.elems,
                        datas: param$2.datas
                      };
            case /* ExternTable */1 :
                return {
                        types: param$2.types,
                        funcs: param$2.funcs,
                        tables: {
                          hd: param._0,
                          tl: param$2.tables
                        },
                        memories: param$2.memories,
                        globals: param$2.globals,
                        exports: param$2.exports,
                        elems: param$2.elems,
                        datas: param$2.datas
                      };
            case /* ExternMemory */2 :
                return {
                        types: param$2.types,
                        funcs: param$2.funcs,
                        tables: param$2.tables,
                        memories: {
                          hd: param._0,
                          tl: param$2.memories
                        },
                        globals: param$2.globals,
                        exports: param$2.exports,
                        elems: param$2.elems,
                        datas: param$2.datas
                      };
            case /* ExternGlobal */3 :
                return {
                        types: param$2.types,
                        funcs: param$2.funcs,
                        tables: param$2.tables,
                        memories: param$2.memories,
                        globals: {
                          hd: param._0,
                          tl: param$2.globals
                        },
                        exports: param$2.exports,
                        elems: param$2.elems,
                        datas: param$2.datas
                      };
            
          }
        }), exts, imports, Instance.empty_module_inst);
  var inst0_types = List.map((function (type_) {
          return type_.it;
        }), match.types);
  var inst0_funcs = init$1.funcs;
  var inst0_tables = init$1.tables;
  var inst0_memories = init$1.memories;
  var inst0_globals = init$1.globals;
  var inst0_exports = init$1.exports;
  var inst0_elems = init$1.elems;
  var inst0_datas = init$1.datas;
  var inst0 = {
    types: inst0_types,
    funcs: inst0_funcs,
    tables: inst0_tables,
    memories: inst0_memories,
    globals: inst0_globals,
    exports: inst0_exports,
    elems: inst0_elems,
    datas: inst0_datas
  };
  var fs = List.map((function (param) {
          return Func.alloc(type_(inst0, param.it.ftype), {
                      contents: inst0
                    }, param);
        }), match.funcs);
  var inst1_types = inst0_types;
  var inst1_funcs = Pervasives.$at(inst0_funcs, fs);
  var inst1_tables = inst0_tables;
  var inst1_memories = inst0_memories;
  var inst1_globals = inst0_globals;
  var inst1_exports = inst0_exports;
  var inst1_elems = inst0_elems;
  var inst1_datas = inst0_datas;
  var inst1 = {
    types: inst1_types,
    funcs: inst1_funcs,
    tables: inst1_tables,
    memories: inst1_memories,
    globals: inst1_globals,
    exports: inst1_exports,
    elems: inst1_elems,
    datas: inst1_datas
  };
  var inst2_types = inst1_types;
  var inst2_funcs = inst1_funcs;
  var inst2_tables = Pervasives.$at(inst1_tables, List.map((function (param) {
              var match = param.it;
              var ttype = match.ttype;
              return Table.alloc(ttype, {
                          RE_EXN_ID: Values.NullRef,
                          _1: ttype._1
                        });
            }), match.tables));
  var inst2_memories = Pervasives.$at(inst1_memories, List.map((function (param) {
              var match = param.it;
              return Memory.alloc(match.mtype);
            }), match.memories));
  var inst2_globals = Pervasives.$at(inst1_globals, List.map((function (param) {
              var match = param.it;
              var v = eval_const(inst1, match.ginit);
              return Global.alloc(match.gtype, v);
            }), match.globals));
  var inst2_exports = inst1_exports;
  var inst2_elems = inst1_elems;
  var inst2_datas = inst1_datas;
  var inst2 = {
    types: inst2_types,
    funcs: inst2_funcs,
    tables: inst2_tables,
    memories: inst2_memories,
    globals: inst2_globals,
    exports: inst2_exports,
    elems: inst2_elems,
    datas: inst2_datas
  };
  var inst_types = inst2_types;
  var inst_funcs = inst2_funcs;
  var inst_tables = inst2_tables;
  var inst_memories = inst2_memories;
  var inst_globals = inst2_globals;
  var inst_exports = List.map((function (param) {
          var match = param.it;
          var x = match.edesc.it;
          var ext;
          switch (x.TAG | 0) {
            case /* FuncExport */0 :
                ext = {
                  TAG: /* ExternFunc */0,
                  _0: func(inst2, x._0)
                };
                break;
            case /* TableExport */1 :
                ext = {
                  TAG: /* ExternTable */1,
                  _0: table(inst2, x._0)
                };
                break;
            case /* MemoryExport */2 :
                ext = {
                  TAG: /* ExternMemory */2,
                  _0: memory(inst2, x._0)
                };
                break;
            case /* GlobalExport */3 :
                ext = {
                  TAG: /* ExternGlobal */3,
                  _0: $$global(inst2, x._0)
                };
                break;
            
          }
          return [
                  match.name,
                  ext
                ];
        }), match.exports);
  var inst_elems = List.map((function (param) {
          var match = param.it;
          return {
                  contents: List.map((function (c) {
                          return Values.as_ref(eval_const(inst2, c));
                        }), match.einit)
                };
        }), elems);
  var inst_datas = List.map((function (param) {
          var match = param.it;
          return {
                  contents: match.dinit
                };
        }), datas);
  var inst = {
    types: inst_types,
    funcs: inst_funcs,
    tables: inst_tables,
    memories: inst_memories,
    globals: inst_globals,
    exports: inst_exports,
    elems: inst_elems,
    datas: inst_datas
  };
  List.iter((function (param) {
          if (param.TAG === /* AstFunc */0) {
            param._1.contents = inst;
            return ;
          }
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "eval.ml",
                  742,
                  9
                ],
                Error: new Error()
              };
        }), fs);
  var es_elem = List.concat(Lib.List32.mapi(run_elem, elems));
  var es_data = List.concat(Lib.List32.mapi(run_data, datas));
  var es_start = Lib.$$Option.get(Lib.$$Option.map(run_start, match.start), /* [] */0);
  $$eval(config(inst, /* [] */0, List.map(plain, Pervasives.$at(es_elem, Pervasives.$at(es_data, es_start)))));
  return inst;
}

var Link$1 = Link.$$Error;

var Trap$1 = Trap.$$Error;

var Exhaustion$1 = Exhaustion.$$Error;

export {
  Link$1 as Link,
  Trap$1 as Trap,
  Crash$1 as Crash,
  Exhaustion$1 as Exhaustion,
  init ,
  invoke ,
  
}
/* Link Not a pure module */
