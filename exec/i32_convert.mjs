// Generated by ReScript, PLEASE EDIT WITH CARE

import * as F32 from "./f32.mjs";
import * as F64 from "./f64.mjs";
import * as Ixx from "./ixx.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Int32 from "rescript/lib/es6/int32.js";
import * as Caml_int64 from "rescript/lib/es6/caml_int64.js";

var wrap_i64 = Caml_int64.to_int32;

function trunc_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Int32.min_int || xf < Int32.min_int) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return xf | 0;
}

function trunc_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf >= -Int32.min_int * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.to_int32(Caml_int64.of_float(xf));
}

function trunc_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Int32.min_int || xf <= Int32.min_int - 1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return xf | 0;
}

function trunc_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    throw {
          RE_EXN_ID: Ixx.InvalidConversion,
          Error: new Error()
        };
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf >= -Int32.min_int * 2.0 || xf <= -1.0) {
    throw {
          RE_EXN_ID: Ixx.Overflow,
          Error: new Error()
        };
  }
  return Caml_int64.to_int32(Caml_int64.of_float(xf));
}

function trunc_sat_f32_s(x) {
  if (Curry._2(F32.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf < Int32.min_int) {
    return Int32.min_int;
  } else if (xf >= -Int32.min_int) {
    return Int32.max_int;
  } else {
    return xf | 0;
  }
}

function trunc_sat_f32_u(x) {
  if (Curry._2(F32.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F32.to_float, x);
  if (xf <= -1.0) {
    return 0;
  } else if (xf >= -Int32.min_int * 2.0) {
    return -1;
  } else {
    return Caml_int64.to_int32(Caml_int64.of_float(xf));
  }
}

function trunc_sat_f64_s(x) {
  if (Curry._2(F64.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf < Int32.min_int) {
    return Int32.min_int;
  } else if (xf >= -Int32.min_int) {
    return Int32.max_int;
  } else {
    return xf | 0;
  }
}

function trunc_sat_f64_u(x) {
  if (Curry._2(F64.ne, x, x)) {
    return 0;
  }
  var xf = Curry._1(F64.to_float, x);
  if (xf <= -1.0) {
    return 0;
  } else if (xf >= -Int32.min_int * 2.0) {
    return -1;
  } else {
    return Caml_int64.to_int32(Caml_int64.of_float(xf));
  }
}

var reinterpret_f32 = F32.to_bits;

export {
  wrap_i64 ,
  trunc_f32_s ,
  trunc_f32_u ,
  trunc_f64_s ,
  trunc_f64_u ,
  trunc_sat_f32_s ,
  trunc_sat_f32_u ,
  trunc_sat_f64_s ,
  trunc_sat_f64_u ,
  reinterpret_f32 ,
  
}
/* F32 Not a pure module */
