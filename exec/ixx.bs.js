// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Int64 = require("rescript/lib/js/int64.js");
var $$Buffer = require("rescript/lib/js/buffer.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Caml_int64 = require("rescript/lib/js/caml_int64.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_string = require("rescript/lib/js/caml_string.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var Overflow = /* @__PURE__ */Caml_exceptions.create("Ixx.Overflow");

var DivideByZero = /* @__PURE__ */Caml_exceptions.create("Ixx.DivideByZero");

var InvalidConversion = /* @__PURE__ */Caml_exceptions.create("Ixx.InvalidConversion");

function Make(Rep) {
  var cmp_u = function (x, op, y) {
    return Curry._2(op, Curry._2(Rep.add, x, Rep.min_int), Curry._2(Rep.add, y, Rep.min_int));
  };
  var divrem_u = function (n, d) {
    if (Caml_obj.caml_equal(d, Rep.zero)) {
      throw {
            RE_EXN_ID: DivideByZero,
            Error: new Error()
          };
    }
    var t = Curry._2(Rep.shift_right, d, Rep.bitwidth - 1 | 0);
    var n$p = Curry._2(Rep.logand, n, Curry._1(Rep.lognot, t));
    var q = Curry._2(Rep.shift_left, Curry._2(Rep.div, Curry._2(Rep.shift_right_logical, n$p, 1), d), 1);
    var r = Curry._2(Rep.sub, n, Curry._2(Rep.mul, q, d));
    if (cmp_u(r, Caml_obj.caml_lessthan, d)) {
      return [
              q,
              r
            ];
    } else {
      return [
              Curry._2(Rep.add, q, Rep.one),
              Curry._2(Rep.sub, r, d)
            ];
    }
  };
  var of_bits = function (x) {
    return x;
  };
  var to_bits = function (x) {
    return x;
  };
  var zero = Rep.zero;
  var one = Rep.one;
  var ten = Curry._1(Rep.of_int, 10);
  var sx = function (x) {
    var i = 64 - Rep.bitwidth | 0;
    return Curry._1(Rep.of_int64, Caml_int64.asr_(Caml_int64.lsl_(Curry._1(Rep.to_int64, x), i), i));
  };
  var add = function (x, y) {
    return sx(Curry._2(Rep.add, x, y));
  };
  var sub = function (x, y) {
    return sx(Curry._2(Rep.sub, x, y));
  };
  var mul = function (x, y) {
    return sx(Curry._2(Rep.mul, x, y));
  };
  var low_int = Curry._2(Rep.shift_left, Rep.minus_one, Rep.bitwidth - 1 | 0);
  var high_int = Curry._2(Rep.logxor, low_int, Rep.minus_one);
  var div_s = function (x, y) {
    if (Caml_obj.caml_equal(y, Rep.zero)) {
      throw {
            RE_EXN_ID: DivideByZero,
            Error: new Error()
          };
    }
    if (Caml_obj.caml_equal(x, low_int) && Caml_obj.caml_equal(y, Rep.minus_one)) {
      throw {
            RE_EXN_ID: Overflow,
            Error: new Error()
          };
    }
    return Curry._2(Rep.div, x, y);
  };
  var div_u = function (x, y) {
    return divrem_u(x, y)[0];
  };
  var rem_s = function (x, y) {
    if (Caml_obj.caml_equal(y, Rep.zero)) {
      throw {
            RE_EXN_ID: DivideByZero,
            Error: new Error()
          };
    }
    return Curry._2(Rep.rem, x, y);
  };
  var rem_u = function (x, y) {
    return divrem_u(x, y)[1];
  };
  var avgr_u = function (x, y) {
    var mask = Caml_int64.lsr_(Int64.minus_one, 64 - Rep.bitwidth | 0);
    var x64 = Caml_int64.and_(mask, Curry._1(Rep.to_int64, x));
    var y64 = Caml_int64.and_(mask, Curry._1(Rep.to_int64, y));
    return Curry._1(Rep.of_int64, Caml_int64.div(Caml_int64.add(Caml_int64.add(x64, y64), Int64.one), [
                    0,
                    2
                  ]));
  };
  var and_ = Rep.logand;
  var or_ = Rep.logor;
  var shift = function (f, x, y) {
    return Curry._2(f, x, Curry._1(Rep.to_int, Curry._2(Rep.logand, y, Curry._1(Rep.of_int, Rep.bitwidth - 1 | 0))));
  };
  var shl = function (x, y) {
    return sx(shift(Rep.shift_left, x, y));
  };
  var shr_s = function (x, y) {
    return shift(Rep.shift_right, x, y);
  };
  var needs_extend = Caml_obj.caml_notequal(shl(one, Curry._1(Rep.of_int, Rep.bitwidth - 1 | 0)), Rep.min_int);
  var as_unsigned = function (x) {
    if (!needs_extend) {
      return x;
    }
    var mask = Curry._2(Rep.shift_right_logical, Rep.minus_one, 32 - Rep.bitwidth | 0);
    return Curry._2(Rep.logand, x, mask);
  };
  var shr_u = function (x, y) {
    return sx(shift(Rep.shift_right_logical, as_unsigned(x), y));
  };
  var clamp_rotate_count = function (n) {
    return Curry._1(Rep.to_int, Curry._2(Rep.logand, n, Curry._1(Rep.of_int, Rep.bitwidth - 1 | 0)));
  };
  var rotl = function (x, y) {
    var n = clamp_rotate_count(y);
    return Curry._2(or_, shl(x, Curry._1(Rep.of_int, n)), shr_u(x, Curry._1(Rep.of_int, Rep.bitwidth - n | 0)));
  };
  var rotr = function (x, y) {
    var n = clamp_rotate_count(y);
    return Curry._2(or_, shr_u(x, Curry._1(Rep.of_int, n)), shl(x, Curry._1(Rep.of_int, Rep.bitwidth - n | 0)));
  };
  var clz = function (x) {
    var loop = function (_acc, _n) {
      while(true) {
        var n = _n;
        var acc = _acc;
        if (Caml_obj.caml_equal(n, Rep.zero)) {
          return Rep.bitwidth;
        }
        if (!Caml_obj.caml_equal(Curry._2(and_, n, Curry._2(Rep.shift_left, Rep.one, Rep.bitwidth - 1 | 0)), zero)) {
          return acc;
        }
        _n = Curry._2(Rep.shift_left, n, 1);
        _acc = 1 + acc | 0;
        continue ;
      };
    };
    return Curry._1(Rep.of_int, loop(0, x));
  };
  var ctz = function (x) {
    var loop = function (_acc, _n) {
      while(true) {
        var n = _n;
        var acc = _acc;
        if (Caml_obj.caml_equal(n, Rep.zero)) {
          return Rep.bitwidth;
        }
        if (Caml_obj.caml_equal(Curry._2(and_, n, Rep.one), Rep.one)) {
          return acc;
        }
        _n = Curry._2(Rep.shift_right_logical, n, 1);
        _acc = 1 + acc | 0;
        continue ;
      };
    };
    return Curry._1(Rep.of_int, loop(0, x));
  };
  var popcnt = function (x) {
    var loop = function (_acc, _i, _n) {
      while(true) {
        var n = _n;
        var i = _i;
        var acc = _acc;
        if (i === 0) {
          return acc;
        }
        var acc$p = Caml_obj.caml_equal(Curry._2(and_, n, Rep.one), Rep.one) ? acc + 1 | 0 : acc;
        _n = Curry._2(Rep.shift_right_logical, n, 1);
        _i = i - 1 | 0;
        _acc = acc$p;
        continue ;
      };
    };
    return Curry._1(Rep.of_int, loop(0, Rep.bitwidth, x));
  };
  var extend_s = function (n, x) {
    var shift = Rep.bitwidth - n | 0;
    return Curry._2(Rep.shift_right, Curry._2(Rep.shift_left, x, shift), shift);
  };
  var eqz = function (x) {
    return Caml_obj.caml_equal(x, Rep.zero);
  };
  var eq = Caml_obj.caml_equal;
  var ne = Caml_obj.caml_notequal;
  var lt_s = Caml_obj.caml_lessthan;
  var lt_u = function (x, y) {
    return cmp_u(x, Caml_obj.caml_lessthan, y);
  };
  var le_s = Caml_obj.caml_lessequal;
  var le_u = function (x, y) {
    return cmp_u(x, Caml_obj.caml_lessequal, y);
  };
  var gt_s = Caml_obj.caml_greaterthan;
  var gt_u = function (x, y) {
    return cmp_u(x, Caml_obj.caml_greaterthan, y);
  };
  var ge_s = Caml_obj.caml_greaterequal;
  var ge_u = function (x, y) {
    return cmp_u(x, Caml_obj.caml_greaterequal, y);
  };
  var saturate_s = function (x) {
    return sx(Caml_obj.caml_min(Caml_obj.caml_max(x, low_int), high_int));
  };
  var saturate_u = function (x) {
    return sx(Caml_obj.caml_min(Caml_obj.caml_max(x, Rep.zero), as_unsigned(Rep.minus_one)));
  };
  var add_int = function (x, y) {
    if (Rep.bitwidth >= 32) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "ixx.ml",
              294,
              4
            ],
            Error: new Error()
          };
    }
    return Curry._1(Rep.of_int, Curry._1(Rep.to_int, x) + Curry._1(Rep.to_int, y) | 0);
  };
  var sub_int = function (x, y) {
    if (Rep.bitwidth >= 32) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "ixx.ml",
              298,
              4
            ],
            Error: new Error()
          };
    }
    return Curry._1(Rep.of_int, Curry._1(Rep.to_int, x) - Curry._1(Rep.to_int, y) | 0);
  };
  var add_sat_s = function (x, y) {
    return saturate_s(add_int(x, y));
  };
  var add_sat_u = function (x, y) {
    return saturate_u(add_int(as_unsigned(x), as_unsigned(y)));
  };
  var sub_sat_s = function (x, y) {
    return saturate_s(sub_int(x, y));
  };
  var sub_sat_u = function (x, y) {
    return saturate_u(sub_int(as_unsigned(x), as_unsigned(y)));
  };
  var q15mulr_sat_s = function (x, y) {
    if (Rep.bitwidth >= 32) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "ixx.ml",
              309,
              4
            ],
            Error: new Error()
          };
    }
    var x64 = Curry._1(Rep.to_int64, x);
    var y64 = Curry._1(Rep.to_int64, y);
    return saturate_s(Curry._1(Rep.of_int64, Caml_int64.asr_(Caml_int64.add(Caml_int64.mul(x64, y64), [
                            0,
                            16384
                          ]), 15)));
  };
  var to_int_u = function (i) {
    return Curry._1(Rep.to_int, i) & ((Curry._1(Rep.to_int, Rep.max_int) << 1) | 1);
  };
  var of_int_u = function (i) {
    return Curry._2(and_, Curry._1(Rep.of_int, i), Curry._2(or_, shl(Curry._1(Rep.of_int, Pervasives.max_int), one), one));
  };
  var $$require = function (b) {
    if (!b) {
      return Pervasives.failwith("of_string");
    }
    
  };
  var dec_digit = function (c) {
    if (c > 57 || c < 48) {
      return Pervasives.failwith("of_string");
    } else {
      return c - /* '0' */48 | 0;
    }
  };
  var hex_digit = function (c) {
    if (c >= 65) {
      if (c >= 97) {
        if (c >= 103) {
          return Pervasives.failwith("of_string");
        } else {
          return (10 + c | 0) - /* 'a' */97 | 0;
        }
      } else if (c >= 71) {
        return Pervasives.failwith("of_string");
      } else {
        return (10 + c | 0) - /* 'A' */65 | 0;
      }
    } else if (c > 57 || c < 48) {
      return Pervasives.failwith("of_string");
    } else {
      return c - /* '0' */48 | 0;
    }
  };
  var match = divrem_u(Rep.minus_one, ten);
  var max_lower = match[1];
  var max_upper = match[0];
  var sign_extend = function (i) {
    if (!needs_extend) {
      return i;
    }
    var sign_bit = Curry._2(Rep.logand, Curry._1(Rep.of_int, (1 << (Rep.bitwidth - 1 | 0))), i);
    if (Caml_obj.caml_equal(sign_bit, Rep.zero)) {
      return i;
    }
    var sign_mask = Curry._2(Rep.shift_left, Rep.minus_one, Rep.bitwidth);
    return Curry._2(Rep.logor, sign_mask, i);
  };
  var of_string = function (s) {
    var len = s.length;
    var parse_int = function (i) {
      $$require((len - i | 0) > 0);
      if ((i + 2 | 0) <= len && Caml_string.get(s, i) === /* '0' */48 && Caml_string.get(s, i + 1 | 0) === /* 'x' */120) {
        var _i = i + 2 | 0;
        var _num = Rep.zero;
        while(true) {
          var num = _num;
          var i$1 = _i;
          if (i$1 === len) {
            return num;
          }
          if (Caml_string.get(s, i$1) === /* '_' */95) {
            _i = i$1 + 1 | 0;
            continue ;
          }
          var digit = Curry._1(Rep.of_int, hex_digit(Caml_string.get(s, i$1)));
          $$require(le_u(num, shr_u(Rep.minus_one, Curry._1(Rep.of_int, 4))));
          _num = Curry._2(Rep.logor, Curry._2(Rep.shift_left, num, 4), digit);
          _i = i$1 + 1 | 0;
          continue ;
        };
      } else {
        var _i$1 = i;
        var _num$1 = Rep.zero;
        while(true) {
          var num$1 = _num$1;
          var i$2 = _i$1;
          if (i$2 === len) {
            return num$1;
          }
          if (Caml_string.get(s, i$2) === /* '_' */95) {
            _i$1 = i$2 + 1 | 0;
            continue ;
          }
          var digit$1 = Curry._1(Rep.of_int, dec_digit(Caml_string.get(s, i$2)));
          $$require(lt_u(num$1, max_upper) || Caml_obj.caml_equal(num$1, max_upper) && le_u(digit$1, max_lower));
          _num$1 = Curry._2(Rep.add, Curry._2(Rep.mul, num$1, ten), digit$1);
          _i$1 = i$2 + 1 | 0;
          continue ;
        };
      }
    };
    $$require(len > 0);
    var match = Caml_string.get(s, 0);
    var parsed;
    switch (match) {
      case 43 :
          parsed = parse_int(1);
          break;
      case 44 :
          parsed = parse_int(0);
          break;
      case 45 :
          var n = parse_int(1);
          $$require(Caml_obj.caml_greaterequal(Curry._2(Rep.sub, n, Rep.one), Rep.minus_one));
          parsed = Curry._1(Rep.neg, n);
          break;
      default:
        parsed = parse_int(0);
    }
    var n$1 = sign_extend(parsed);
    $$require(Caml_obj.caml_lessequal(low_int, n$1) && Caml_obj.caml_lessequal(n$1, high_int));
    return n$1;
  };
  var of_string_s = function (s) {
    var n = of_string(s);
    $$require(Caml_string.get(s, 0) === /* '-' */45 || Caml_obj.caml_greaterequal(n, Rep.zero));
    return n;
  };
  var of_string_u = function (s) {
    var n = of_string(s);
    $$require(Caml_string.get(s, 0) !== /* '+' */43 && Caml_string.get(s, 0) !== /* '-' */45);
    return n;
  };
  var add_digits = function (buf, s, _i, j, _k, n) {
    while(true) {
      var k = _k;
      var i = _i;
      if (i >= j) {
        return ;
      }
      if (k === 0) {
        $$Buffer.add_char(buf, /* '_' */95);
      }
      $$Buffer.add_char(buf, Caml_string.get(s, i));
      _k = Caml_int32.mod_((k + n | 0) - 1 | 0, n);
      _i = i + 1 | 0;
      continue ;
    };
  };
  var group_digits = function (n, s) {
    var len = s.length;
    var num = Caml_string.get(s, 0) === /* '-' */45 ? 1 : 0;
    var buf = $$Buffer.create(Caml_int32.div(Math.imul(len, n + 1 | 0), n));
    $$Buffer.add_substring(buf, s, 0, num);
    add_digits(buf, s, num, len, Caml_int32.mod_(len - num | 0, n) + n | 0, n);
    return $$Buffer.contents(buf);
  };
  var to_string_s = function (i) {
    return group_digits(3, Curry._1(Rep.to_string, i));
  };
  var to_string_u = function (i) {
    if (Caml_obj.caml_greaterequal(i, Rep.zero)) {
      return group_digits(3, Curry._1(Rep.to_string, i));
    } else {
      return group_digits(3, Curry._1(Rep.to_string, div_u(i, ten)) + Curry._1(Rep.to_string, rem_u(i, ten)));
    }
  };
  var to_hex_string = function (i) {
    return "0x" + group_digits(4, Curry._1(Rep.to_hex_string, i));
  };
  return {
          of_bits: of_bits,
          to_bits: to_bits,
          zero: zero,
          lognot: Rep.lognot,
          abs: Rep.abs,
          neg: Rep.neg,
          add: add,
          sub: sub,
          mul: mul,
          div_s: div_s,
          div_u: div_u,
          rem_s: rem_s,
          rem_u: rem_u,
          avgr_u: avgr_u,
          and_: and_,
          or_: or_,
          xor: Rep.logxor,
          shl: shl,
          shr_s: shr_s,
          shr_u: shr_u,
          rotl: rotl,
          rotr: rotr,
          clz: clz,
          ctz: ctz,
          popcnt: popcnt,
          extend_s: extend_s,
          eqz: eqz,
          eq: eq,
          ne: ne,
          lt_s: lt_s,
          lt_u: lt_u,
          le_s: le_s,
          le_u: le_u,
          gt_s: gt_s,
          gt_u: gt_u,
          ge_s: ge_s,
          ge_u: ge_u,
          as_unsigned: as_unsigned,
          saturate_s: saturate_s,
          saturate_u: saturate_u,
          add_sat_s: add_sat_s,
          add_sat_u: add_sat_u,
          sub_sat_s: sub_sat_s,
          sub_sat_u: sub_sat_u,
          q15mulr_sat_s: q15mulr_sat_s,
          of_int_s: Rep.of_int,
          of_int_u: of_int_u,
          of_string_s: of_string_s,
          of_string_u: of_string_u,
          of_string: of_string,
          to_int_s: Rep.to_int,
          to_int_u: to_int_u,
          to_string_s: to_string_s,
          to_string_u: to_string_u,
          to_hex_string: to_hex_string
        };
}

exports.Overflow = Overflow;
exports.DivideByZero = DivideByZero;
exports.InvalidConversion = InvalidConversion;
exports.Make = Make;
/* No side effect */
